GET /repos/golang/go/commits/cc8f5441980a8c2f9e6c8ec3222985ed488e76ba?access_token=token
host: api.github.com
accept: application/vnd.github.v3+json

HTTP/1.1 200 OK
server: GitHub.com
date: Sun, 28 Feb 2016 20:37:58 GMT
content-type: application/json; charset=utf-8
content-length: 9569
connection: close
status: 200 OK
x-ratelimit-limit: 5000
x-ratelimit-remaining: 4826
x-ratelimit-reset: 1456694697
cache-control: private, max-age=60, s-maxage=60
vary: Accept, Authorization, Cookie, X-GitHub-OTP, Accept-Encoding
etag: "f1d947fe66f5d65cf9fcb863e5b2b6a1"
last-modified: Fri, 17 Jul 2015 03:34:11 GMT
x-oauth-scopes: public_repo
x-accepted-oauth-scopes: 
x-github-media-type: github.v3; format=json
access-control-allow-credentials: true
access-control-expose-headers: ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval
access-control-allow-origin: *
content-security-policy: default-src 'none'
strict-transport-security: max-age=31536000; includeSubdomains; preload
x-content-type-options: nosniff
x-frame-options: deny
x-xss-protection: 1; mode=block
x-served-by: 173530fed4bbeb1e264b2ed22e8b5c20
x-github-request-id: 4E320659:99A9:2214EB5:56D35AA4

{"sha":"cc8f5441980a8c2f9e6c8ec3222985ed488e76ba","commit":{"author":{"name":"Austin Clements","email":"austin@google.com","date":"2015-07-16T20:27:09Z"},"committer":{"name":"Rob Pike","email":"r@golang.org","date":"2015-07-17T03:34:11Z"},"message":"runtime: don't free large spans until heapBitsSweepSpan returns\n\nThis fixes a race between 1) sweeping and freeing an unmarked large\nspan and 2) reusing that span and allocating from it. This race arises\nbecause mSpan_Sweep returns spans for large objects to the heap\n*before* heapBitsSweepSpan clears the mark bit on the object in the\nspan.\n\nSpecifically, the following sequence of events can lead to an\nincorrectly zeroed bitmap byte, which causes the garbage collector to\nnot trace any pointers in that object (the pointer bits for the first\nfour words are cleared, and the scan bits are also cleared, so it\nlooks like a no-scan object).\n\n1) P0 calls mSpan_Sweep on a large span S0 with an unmarked object on it.\n\n2) mSpan_Sweep calls heapBitsSweepSpan, which invokes the callback for\n   the one (unmarked) object on the span.\n\n3) The callback calls mHeap_Free, which makes span S0 available for\n   allocation, but this is too early.\n\n4) P1 grabs this S0 from the heap to use for allocation.\n\n5) P1 allocates an object on this span and writes that object's type\n   bits to the bitmap.\n\n6) P0 returns from the callback to heapBitsSweepSpan.\n   heapBitsSweepSpan clears the byte containing the mark, even though\n   this span is now owned by P1 and this byte contains important\n   bitmap information.\n\nThis fixes this problem by simply delaying the mHeap_Free until after\nthe heapBitsSweepSpan. I think the overall logic of mSpan_Sweep could\nbe simplified now, but this seems like the minimal change.\n\nFixes #11617.\n\nChange-Id: I6b1382c7e7cc35f81984467c0772fe9848b7522a\nReviewed-on: https://go-review.googlesource.com/12320\nRun-TryBot: Austin Clements <austin@google.com>\nTryBot-Result: Gobot Gobot <gobot@golang.org>\nReviewed-by: Matthew Dempsky <mdempsky@google.com>\nReviewed-by: Rob Pike <r@golang.org>","tree":{"sha":"7b635689a0167b73c07707e20e290a30e098c08b","url":"https://api.github.com/repos/golang/go/git/trees/7b635689a0167b73c07707e20e290a30e098c08b"},"url":"https://api.github.com/repos/golang/go/git/commits/cc8f5441980a8c2f9e6c8ec3222985ed488e76ba","comment_count":0},"url":"https://api.github.com/repos/golang/go/commits/cc8f5441980a8c2f9e6c8ec3222985ed488e76ba","html_url":"https://github.com/golang/go/commit/cc8f5441980a8c2f9e6c8ec3222985ed488e76ba","comments_url":"https://api.github.com/repos/golang/go/commits/cc8f5441980a8c2f9e6c8ec3222985ed488e76ba/comments","author":{"login":"aclements","id":2688315,"avatar_url":"https://avatars.githubusercontent.com/u/2688315?v=3","gravatar_id":"","url":"https://api.github.com/users/aclements","html_url":"https://github.com/aclements","followers_url":"https://api.github.com/users/aclements/followers","following_url":"https://api.github.com/users/aclements/following{/other_user}","gists_url":"https://api.github.com/users/aclements/gists{/gist_id}","starred_url":"https://api.github.com/users/aclements/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aclements/subscriptions","organizations_url":"https://api.github.com/users/aclements/orgs","repos_url":"https://api.github.com/users/aclements/repos","events_url":"https://api.github.com/users/aclements/events{/privacy}","received_events_url":"https://api.github.com/users/aclements/received_events","type":"User","site_admin":false},"committer":{"login":"robpike","id":4324516,"avatar_url":"https://avatars.githubusercontent.com/u/4324516?v=3","gravatar_id":"","url":"https://api.github.com/users/robpike","html_url":"https://github.com/robpike","followers_url":"https://api.github.com/users/robpike/followers","following_url":"https://api.github.com/users/robpike/following{/other_user}","gists_url":"https://api.github.com/users/robpike/gists{/gist_id}","starred_url":"https://api.github.com/users/robpike/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/robpike/subscriptions","organizations_url":"https://api.github.com/users/robpike/orgs","repos_url":"https://api.github.com/users/robpike/repos","events_url":"https://api.github.com/users/robpike/events{/privacy}","received_events_url":"https://api.github.com/users/robpike/received_events","type":"User","site_admin":false},"parents":[{"sha":"5c62e5f9da1fa0b16fa8da918b8fd1eb807b38c1","url":"https://api.github.com/repos/golang/go/commits/5c62e5f9da1fa0b16fa8da918b8fd1eb807b38c1","html_url":"https://github.com/golang/go/commit/5c62e5f9da1fa0b16fa8da918b8fd1eb807b38c1"}],"stats":{"total":64,"additions":36,"deletions":28},"files":[{"sha":"acad55e7771da9ab1bffe15ec7de555d9c9c9d0e","filename":"src/runtime/mgcsweep.go","status":"modified","additions":36,"deletions":28,"changes":64,"blob_url":"https://github.com/golang/go/blob/cc8f5441980a8c2f9e6c8ec3222985ed488e76ba/src/runtime/mgcsweep.go","raw_url":"https://github.com/golang/go/raw/cc8f5441980a8c2f9e6c8ec3222985ed488e76ba/src/runtime/mgcsweep.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/runtime/mgcsweep.go?ref=cc8f5441980a8c2f9e6c8ec3222985ed488e76ba","patch":"@@ -170,12 +170,12 @@ func mSpan_Sweep(s *mspan, preserve bool) bool {\n \tcl := s.sizeclass\n \tsize := s.elemsize\n \tres := false\n-\tnfree := 0\n+\tnfree := 0 // Set to -1 for large span\n \n \tvar head, end gclinkptr\n \n \tc := _g_.m.mcache\n-\tsweepgenset := false\n+\tfreeToHeap := false\n \n \t// Mark any free objects in this span so we don't collect them.\n \tsstart := uintptr(s.start << _PageShift)\n@@ -237,31 +237,10 @@ func mSpan_Sweep(s *mspan, preserve bool) bool {\n \n \t\t\t// important to set sweepgen before returning it to heap\n \t\t\tatomicstore(&s.sweepgen, sweepgen)\n-\t\t\tsweepgenset = true\n-\n-\t\t\t// NOTE(rsc,dvyukov): The original implementation of efence\n-\t\t\t// in CL 22060046 used SysFree instead of SysFault, so that\n-\t\t\t// the operating system would eventually give the memory\n-\t\t\t// back to us again, so that an efence program could run\n-\t\t\t// longer without running out of memory. Unfortunately,\n-\t\t\t// calling SysFree here without any kind of adjustment of the\n-\t\t\t// heap data structures means that when the memory does\n-\t\t\t// come back to us, we have the wrong metadata for it, either in\n-\t\t\t// the MSpan structures or in the garbage collection bitmap.\n-\t\t\t// Using SysFault here means that the program will run out of\n-\t\t\t// memory fairly quickly in efence mode, but at least it won't\n-\t\t\t// have mysterious crashes due to confused memory reuse.\n-\t\t\t// It should be possible to switch back to SysFree if we also\n-\t\t\t// implement and then call some kind of MHeap_DeleteSpan.\n-\t\t\tif debug.efence > 0 {\n-\t\t\t\ts.limit = 0 // prevent mlookup from finding this span\n-\t\t\t\tsysFault(unsafe.Pointer(p), size)\n-\t\t\t} else {\n-\t\t\t\tmHeap_Free(&mheap_, s, 1)\n-\t\t\t}\n-\t\t\tc.local_nlargefree++\n-\t\t\tc.local_largefree += size\n-\t\t\tres = true\n+\n+\t\t\t// Free the span after heapBitsSweepSpan\n+\t\t\t// returns, since it's not done with the span.\n+\t\t\tfreeToHeap = true\n \t\t} else {\n \t\t\t// Free small object.\n \t\t\tif size > 2*ptrSize {\n@@ -285,7 +264,10 @@ func mSpan_Sweep(s *mspan, preserve bool) bool {\n \t// But we need to set it before we make the span available for allocation\n \t// (return it to heap or mcentral), because allocation code assumes that a\n \t// span is already swept if available for allocation.\n-\tif !sweepgenset && nfree == 0 {\n+\t//\n+\t// TODO(austin): Clean this up by consolidating atomicstore in\n+\t// large span path above with this.\n+\tif !freeToHeap && nfree == 0 {\n \t\t// The span must be in our exclusive ownership until we update sweepgen,\n \t\t// check for potential races.\n \t\tif s.state != mSpanInUse || s.sweepgen != sweepgen-1 {\n@@ -298,6 +280,32 @@ func mSpan_Sweep(s *mspan, preserve bool) bool {\n \t\tc.local_nsmallfree[cl] += uintptr(nfree)\n \t\tres = mCentral_FreeSpan(&mheap_.central[cl].mcentral, s, int32(nfree), head, end, preserve)\n \t\t// MCentral_FreeSpan updates sweepgen\n+\t} else if freeToHeap {\n+\t\t// Free large span to heap\n+\n+\t\t// NOTE(rsc,dvyukov): The original implementation of efence\n+\t\t// in CL 22060046 used SysFree instead of SysFault, so that\n+\t\t// the operating system would eventually give the memory\n+\t\t// back to us again, so that an efence program could run\n+\t\t// longer without running out of memory. Unfortunately,\n+\t\t// calling SysFree here without any kind of adjustment of the\n+\t\t// heap data structures means that when the memory does\n+\t\t// come back to us, we have the wrong metadata for it, either in\n+\t\t// the MSpan structures or in the garbage collection bitmap.\n+\t\t// Using SysFault here means that the program will run out of\n+\t\t// memory fairly quickly in efence mode, but at least it won't\n+\t\t// have mysterious crashes due to confused memory reuse.\n+\t\t// It should be possible to switch back to SysFree if we also\n+\t\t// implement and then call some kind of MHeap_DeleteSpan.\n+\t\tif debug.efence > 0 {\n+\t\t\ts.limit = 0 // prevent mlookup from finding this span\n+\t\t\tsysFault(unsafe.Pointer(uintptr(s.start<<_PageShift)), size)\n+\t\t} else {\n+\t\t\tmHeap_Free(&mheap_, s, 1)\n+\t\t}\n+\t\tc.local_nlargefree++\n+\t\tc.local_largefree += size\n+\t\tres = true\n \t}\n \tif trace.enabled {\n \t\ttraceGCSweepDone()"}]}