GET /repos/golang/go/commits/5d9765785dff74784bbdad43f7847b6825509032?access_token=token
host: api.github.com
accept: application/vnd.github.v3+json

HTTP/1.1 200 OK
server: GitHub.com
date: Sun, 28 Feb 2016 20:36:00 GMT
content-type: application/json; charset=utf-8
content-length: 9223
connection: close
status: 200 OK
x-ratelimit-limit: 5000
x-ratelimit-remaining: 4865
x-ratelimit-reset: 1456694697
cache-control: private, max-age=60, s-maxage=60
vary: Accept, Authorization, Cookie, X-GitHub-OTP, Accept-Encoding
etag: "ab84fa35217b70f0a70ff8e964ff670e"
last-modified: Sun, 31 Jul 2011 22:37:01 GMT
x-oauth-scopes: public_repo
x-accepted-oauth-scopes: 
x-github-media-type: github.v3; format=json
access-control-allow-credentials: true
access-control-expose-headers: ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval
access-control-allow-origin: *
content-security-policy: default-src 'none'
strict-transport-security: max-age=31536000; includeSubdomains; preload
x-content-type-options: nosniff
x-frame-options: deny
x-xss-protection: 1; mode=block
x-served-by: 52437fedc85beec8da3449496900fb9a
x-github-request-id: 4E320659:6DAC:18BB0E0:56D35A30

{"sha":"5d9765785dff74784bbdad43f7847b6825509032","commit":{"author":{"name":"Andrew Gerrand","email":"adg@golang.org","date":"2011-07-31T22:37:01Z"},"committer":{"name":"Andrew Gerrand","email":"adg@golang.org","date":"2011-07-31T22:37:01Z"},"message":"[release-branch.r59] gc: fix closure bug\n\n««« CL 4709042 / d30305e2898a\ngc: fix closure bug\n\nFixes #2056.\n\nR=rsc\nCC=golang-dev\nhttps://golang.org/cl/4709042\n»»»\n\nR=golang-dev, r\nCC=golang-dev\nhttps://golang.org/cl/4814061","tree":{"sha":"f82fe78729649d0d95c5411b3acea2910ff3e79d","url":"https://api.github.com/repos/golang/go/git/trees/f82fe78729649d0d95c5411b3acea2910ff3e79d"},"url":"https://api.github.com/repos/golang/go/git/commits/5d9765785dff74784bbdad43f7847b6825509032","comment_count":0},"url":"https://api.github.com/repos/golang/go/commits/5d9765785dff74784bbdad43f7847b6825509032","html_url":"https://github.com/golang/go/commit/5d9765785dff74784bbdad43f7847b6825509032","comments_url":"https://api.github.com/repos/golang/go/commits/5d9765785dff74784bbdad43f7847b6825509032/comments","author":{"login":"adg","id":8446613,"avatar_url":"https://avatars.githubusercontent.com/u/8446613?v=3","gravatar_id":"","url":"https://api.github.com/users/adg","html_url":"https://github.com/adg","followers_url":"https://api.github.com/users/adg/followers","following_url":"https://api.github.com/users/adg/following{/other_user}","gists_url":"https://api.github.com/users/adg/gists{/gist_id}","starred_url":"https://api.github.com/users/adg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/adg/subscriptions","organizations_url":"https://api.github.com/users/adg/orgs","repos_url":"https://api.github.com/users/adg/repos","events_url":"https://api.github.com/users/adg/events{/privacy}","received_events_url":"https://api.github.com/users/adg/received_events","type":"User","site_admin":false},"committer":{"login":"adg","id":8446613,"avatar_url":"https://avatars.githubusercontent.com/u/8446613?v=3","gravatar_id":"","url":"https://api.github.com/users/adg","html_url":"https://github.com/adg","followers_url":"https://api.github.com/users/adg/followers","following_url":"https://api.github.com/users/adg/following{/other_user}","gists_url":"https://api.github.com/users/adg/gists{/gist_id}","starred_url":"https://api.github.com/users/adg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/adg/subscriptions","organizations_url":"https://api.github.com/users/adg/orgs","repos_url":"https://api.github.com/users/adg/repos","events_url":"https://api.github.com/users/adg/events{/privacy}","received_events_url":"https://api.github.com/users/adg/received_events","type":"User","site_admin":false},"parents":[{"sha":"6b0d25d8ee85795575aaf8d7d0174ba73ee04bea","url":"https://api.github.com/repos/golang/go/commits/6b0d25d8ee85795575aaf8d7d0174ba73ee04bea","html_url":"https://github.com/golang/go/commit/6b0d25d8ee85795575aaf8d7d0174ba73ee04bea"}],"stats":{"total":101,"additions":62,"deletions":39},"files":[{"sha":"7e7b405260cf48307b8a74eb803037f70d4c6f0a","filename":"src/cmd/gc/closure.c","status":"modified","additions":41,"deletions":37,"changes":78,"blob_url":"https://github.com/golang/go/blob/5d9765785dff74784bbdad43f7847b6825509032/src/cmd/gc/closure.c","raw_url":"https://github.com/golang/go/raw/5d9765785dff74784bbdad43f7847b6825509032/src/cmd/gc/closure.c","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/gc/closure.c?ref=5d9765785dff74784bbdad43f7847b6825509032","patch":"@@ -116,12 +116,11 @@ typecheckclosure(Node *func, int top)\n \t}\n }\n \n-Node*\n-walkclosure(Node *func, NodeList **init)\n+static Node*\n+makeclosure(Node *func, NodeList **init, int nowrap)\n {\n-\tint narg;\n-\tNode *xtype, *v, *addr, *xfunc, *call, *clos;\n-\tNodeList *l, *in;\n+\tNode *xtype, *v, *addr, *xfunc;\n+\tNodeList *l;\n \tstatic int closgen;\n \tchar *p;\n \n@@ -133,7 +132,6 @@ walkclosure(Node *func, NodeList **init)\n \n \t// each closure variable has a corresponding\n \t// address parameter.\n-\tnarg = 0;\n \tfor(l=func->cvars; l; l=l->next) {\n \t\tv = l->n;\n \t\tif(v->op == 0)\n@@ -146,7 +144,6 @@ walkclosure(Node *func, NodeList **init)\n \t\taddr->class = PPARAM;\n \t\taddr->addable = 1;\n \t\taddr->ullman = 1;\n-\t\tnarg++;\n \n \t\tv->heapaddr = addr;\n \n@@ -154,7 +151,8 @@ walkclosure(Node *func, NodeList **init)\n \t}\n \n \t// then a dummy arg where the closure's caller pc sits\n-\txtype->list = list(xtype->list, nod(ODCLFIELD, N, typenod(types[TUINTPTR])));\n+\tif (!nowrap)\n+\t\txtype->list = list(xtype->list, nod(ODCLFIELD, N, typenod(types[TUINTPTR])));\n \n \t// then the function arguments\n \txtype->list = concat(xtype->list, func->list);\n@@ -176,15 +174,36 @@ walkclosure(Node *func, NodeList **init)\n \ttypecheck(&xfunc, Etop);\n \tclosures = list(closures, xfunc);\n \n+\treturn xfunc;\n+}\n+\n+Node*\n+walkclosure(Node *func, NodeList **init)\n+{\n+\tint narg;\n+\tNode *xtype, *xfunc, *call, *clos;\n+\tNodeList *l, *in;\n+\n+\t/*\n+\t * wrap body in external function\n+\t * with extra closure parameters.\n+\t */\n+\n+\t// create the function\n+\txfunc = makeclosure(func, init, 0);\n+\txtype = xfunc->nname->ntype;\n+\n \t// prepare call of sys.closure that turns external func into func literal value.\n \tclos = syslook(\"closure\", 1);\n \tclos->type = T;\n \tclos->ntype = nod(OTFUNC, N, N);\n \tin = list1(nod(ODCLFIELD, N, typenod(types[TINT])));\t// siz\n \tin = list(in, nod(ODCLFIELD, N, xtype));\n+\tnarg = 0;\n \tfor(l=func->cvars; l; l=l->next) {\n \t\tif(l->n->op == 0)\n \t\t\tcontinue;\n+\t\tnarg++;\n \t\tin = list(in, nod(ODCLFIELD, N, l->n->heapaddr->ntype));\n \t}\n \tclos->ntype->list = in;\n@@ -211,33 +230,18 @@ walkclosure(Node *func, NodeList **init)\n void\n walkcallclosure(Node *n, NodeList **init)\n {\n-\tNode *z;\n-\tNodeList *ll, *cargs;\n-\n-\twalkexpr(&n->left, init);\n-\tcargs =\tn->left    // FUNC runtime.closure\n-\t\t->list     // arguments\n-\t\t->next     // skip first\n-\t\t->next;    // skip second\n-\n-\tn->left = n->left  // FUNC runtime.closure\n-\t\t->list     // arguments\n-\t\t->next     // skip first\n-\t\t->n        // AS (to indreg) \n-\t\t->right;   // argument  == the generated function \n-\n-\t// New arg list for n. First the closure-args, stolen from\n-\t// runtime.closure's 3rd and following,\n-\tll = nil;\n-\tfor (; cargs; cargs = cargs->next)\n-\t\tll = list(ll, cargs->n->right);  // cargs->n is the OAS(INDREG, arg)\n-\n-\t// then an extra zero, to fill the dummy return pointer slot,\n-\tz = nod(OXXX, N, N);\n-\tnodconst(z, types[TUINTPTR], 0);\n-\tz->typecheck = 1;\n-\tll = list(ll, z);\n-\n-\t// and finally the original parameter list.\n-\tn->list = concat(ll, n->list);\n+\tif (n->op != OCALLFUNC || n->left->op != OCLOSURE) {\n+\t\tdump(\"walkcallclosure\", n);\n+\t\tfatal(\"abuse of walkcallclosure\");\n+\t}\n+\n+\t// New arg list for n. First the closure-args\n+\t// and then the original parameter list.\n+\tn->list = concat(n->left->enter, n->list);\n+\tn->left = makeclosure(n->left, init, 1)->nname;\n+\tdowidth(n->left->type);\n+\tn->type = getoutargx(n->left->type);\n+\t// for a single valued function, pull the field type out of the struct\n+\tif (n->type && n->type->type && !n->type->type->down)\n+\t\tn->type = n->type->type->type;\n }"},{"sha":"c9ca9b3b37d25e301906d7fb9206da2d5dcccb00","filename":"src/cmd/gc/walk.c","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/golang/go/blob/5d9765785dff74784bbdad43f7847b6825509032/src/cmd/gc/walk.c","raw_url":"https://github.com/golang/go/raw/5d9765785dff74784bbdad43f7847b6825509032/src/cmd/gc/walk.c","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/gc/walk.c?ref=5d9765785dff74784bbdad43f7847b6825509032","patch":"@@ -494,9 +494,9 @@ walkexpr(Node **np, NodeList **init)\n \t\tif(n->left->op == OCLOSURE) {\n \t\t\twalkcallclosure(n, init);\n \t\t\tt = n->left->type;\n-\t\t} else\n-\t\t\twalkexpr(&n->left, init);\n+\t\t}\n \n+\t\twalkexpr(&n->left, init);\n \t\twalkexprlist(n->list, init);\n \n \t\tll = ascompatte(n->op, n->isddd, getinarg(t), n->list, 0, init);"},{"sha":"31284c31a1d8368a2ac45d3e6071c208efcbbc54","filename":"test/fixedbugs/bug346.go","status":"added","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/golang/go/blob/5d9765785dff74784bbdad43f7847b6825509032/test/fixedbugs/bug346.go","raw_url":"https://github.com/golang/go/raw/5d9765785dff74784bbdad43f7847b6825509032/test/fixedbugs/bug346.go","contents_url":"https://api.github.com/repos/golang/go/contents/test/fixedbugs/bug346.go?ref=5d9765785dff74784bbdad43f7847b6825509032","patch":"@@ -0,0 +1,19 @@\n+// $G $D/$F.go && $L $F.$A && ./$A.out || echo BUG: issue2056\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"os\"\n+\n+func main() {\n+\tx := 4\n+\ta, b, c, d := func(i int) (p int, q int, r int, s int) { return 1, i, 3, x }(2)\n+\n+\tif a != 1 || b != 2 || c != 3 || d != 4 {\n+\t\tprintln(\"abcd: expected 1 2 3 4 got\", a, b, c, d)\n+\t\tos.Exit(1)\n+\t}\n+}"}]}