GET /repos/golang/go/commits/036b8fd40b60830ca1d152f17148e52b96d8aa6c?access_token=token
host: api.github.com
accept: application/vnd.github.v3+json

HTTP/1.1 200 OK
server: GitHub.com
date: Sun, 28 Feb 2016 20:36:47 GMT
content-type: application/json; charset=utf-8
content-length: 138142
connection: close
status: 200 OK
x-ratelimit-limit: 5000
x-ratelimit-remaining: 4844
x-ratelimit-reset: 1456694697
cache-control: private, max-age=60, s-maxage=60
vary: Accept, Authorization, Cookie, X-GitHub-OTP, Accept-Encoding
etag: "ae5c3d46e2438fd581119814e80150a2"
last-modified: Thu, 28 Jan 2016 00:06:14 GMT
x-oauth-scopes: public_repo
x-accepted-oauth-scopes: 
x-github-media-type: github.v3; format=json
access-control-allow-credentials: true
access-control-expose-headers: ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval
access-control-allow-origin: *
content-security-policy: default-src 'none'
strict-transport-security: max-age=31536000; includeSubdomains; preload
x-content-type-options: nosniff
x-frame-options: deny
x-xss-protection: 1; mode=block
x-served-by: 474556b853193c38f1b14328ce2d1b7d
x-github-request-id: 4E320659:3F84:D0B321:56D35A5E

{"sha":"036b8fd40b60830ca1d152f17148e52b96d8aa6c","commit":{"author":{"name":"Chris Broadfoot","email":"cbro@golang.org","date":"2016-01-27T23:44:35Z"},"committer":{"name":"Chris Broadfoot","email":"cbro@golang.org","date":"2016-01-28T00:06:14Z"},"message":"[release-branch.go1.6] cmd/newlink: remove from release branch\n\nChange-Id: Iec73b9a4279b5d6b458615c265e75b6becff320e\nReviewed-on: https://go-review.googlesource.com/19023\nRun-TryBot: Chris Broadfoot <cbro@golang.org>\nTryBot-Result: Gobot Gobot <gobot@golang.org>\nReviewed-by: Brad Fitzpatrick <bradfitz@golang.org>","tree":{"sha":"854edbcd7a831050e04eecd63ce8cf580c6e833a","url":"https://api.github.com/repos/golang/go/git/trees/854edbcd7a831050e04eecd63ce8cf580c6e833a"},"url":"https://api.github.com/repos/golang/go/git/commits/036b8fd40b60830ca1d152f17148e52b96d8aa6c","comment_count":0},"url":"https://api.github.com/repos/golang/go/commits/036b8fd40b60830ca1d152f17148e52b96d8aa6c","html_url":"https://github.com/golang/go/commit/036b8fd40b60830ca1d152f17148e52b96d8aa6c","comments_url":"https://api.github.com/repos/golang/go/commits/036b8fd40b60830ca1d152f17148e52b96d8aa6c/comments","author":{"login":"broady","id":24982,"avatar_url":"https://avatars.githubusercontent.com/u/24982?v=3","gravatar_id":"","url":"https://api.github.com/users/broady","html_url":"https://github.com/broady","followers_url":"https://api.github.com/users/broady/followers","following_url":"https://api.github.com/users/broady/following{/other_user}","gists_url":"https://api.github.com/users/broady/gists{/gist_id}","starred_url":"https://api.github.com/users/broady/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/broady/subscriptions","organizations_url":"https://api.github.com/users/broady/orgs","repos_url":"https://api.github.com/users/broady/repos","events_url":"https://api.github.com/users/broady/events{/privacy}","received_events_url":"https://api.github.com/users/broady/received_events","type":"User","site_admin":false},"committer":{"login":"broady","id":24982,"avatar_url":"https://avatars.githubusercontent.com/u/24982?v=3","gravatar_id":"","url":"https://api.github.com/users/broady","html_url":"https://github.com/broady","followers_url":"https://api.github.com/users/broady/followers","following_url":"https://api.github.com/users/broady/following{/other_user}","gists_url":"https://api.github.com/users/broady/gists{/gist_id}","starred_url":"https://api.github.com/users/broady/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/broady/subscriptions","organizations_url":"https://api.github.com/users/broady/orgs","repos_url":"https://api.github.com/users/broady/repos","events_url":"https://api.github.com/users/broady/events{/privacy}","received_events_url":"https://api.github.com/users/broady/received_events","type":"User","site_admin":false},"parents":[{"sha":"6c6aabe0bca7209d646c840d6274b1ffd199bba0","url":"https://api.github.com/repos/golang/go/commits/6c6aabe0bca7209d646c840d6274b1ffd199bba0","html_url":"https://github.com/golang/go/commit/6c6aabe0bca7209d646c840d6274b1ffd199bba0"}],"stats":{"total":5267,"additions":0,"deletions":5267},"files":[{"sha":"c8ab18ea20e7aa4fe94da66e4b3fe812a172ffd9","filename":"misc/nacl/testzip.proto","status":"modified","additions":0,"deletions":3,"changes":3,"blob_url":"https://github.com/golang/go/blob/036b8fd40b60830ca1d152f17148e52b96d8aa6c/misc/nacl/testzip.proto","raw_url":"https://github.com/golang/go/raw/036b8fd40b60830ca1d152f17148e52b96d8aa6c/misc/nacl/testzip.proto","contents_url":"https://api.github.com/repos/golang/go/contents/misc/nacl/testzip.proto?ref=036b8fd40b60830ca1d152f17148e52b96d8aa6c","patch":"@@ -32,9 +32,6 @@ go\tsrc=..\n \t\t\t\tgofmt_test.go\n \t\t\t\ttestdata\n \t\t\t\t\t+\n-\t\t\tnewlink\n-\t\t\t\ttestdata\n-\t\t\t\t\t+\n \t\t\tvendor\n \t\t\t\tgolang.org\n \t\t\t\t\t\tx"},{"sha":"21f6d6082722d923beb93b47a797e246ebcb8908","filename":"src/cmd/newlink/auto.go","status":"removed","additions":0,"deletions":117,"changes":117,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/auto.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/auto.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/auto.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,117 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Automatic symbol generation.\n-\n-// TODO(rsc): Handle go.typelink, go.track symbols.\n-// TODO(rsc): Do not handle $f64. and $f32. symbols. Instead, generate those\n-// from the compiler and assemblers as dupok data, and then remove autoData below.\n-package main\n-\n-import (\n-\t\"cmd/internal/goobj\"\n-\t\"strconv\"\n-\t\"strings\"\n-)\n-\n-// linkerDefined lists the symbols supplied by other parts of the linker\n-// (runtime.go and layout.go).\n-var linkerDefined = map[string]bool{\n-\t\"runtime.bss\":        true,\n-\t\"runtime.data\":       true,\n-\t\"runtime.ebss\":       true,\n-\t\"runtime.edata\":      true,\n-\t\"runtime.efunctab\":   true,\n-\t\"runtime.end\":        true,\n-\t\"runtime.enoptrbss\":  true,\n-\t\"runtime.enoptrdata\": true,\n-\t\"runtime.erodata\":    true,\n-\t\"runtime.etext\":      true,\n-\t\"runtime.etypelink\":  true,\n-\t\"runtime.functab\":    true,\n-\t\"runtime.gcbss\":      true,\n-\t\"runtime.gcdata\":     true,\n-\t\"runtime.noptrbss\":   true,\n-\t\"runtime.noptrdata\":  true,\n-\t\"runtime.pclntab\":    true,\n-\t\"runtime.rodata\":     true,\n-\t\"runtime.text\":       true,\n-\t\"runtime.typelink\":   true,\n-}\n-\n-// isAuto reports whether sym is an automatically-generated data or constant symbol.\n-func (p *Prog) isAuto(sym goobj.SymID) bool {\n-\treturn strings.HasPrefix(sym.Name, \"go.weak.\") ||\n-\t\tstrings.HasPrefix(sym.Name, \"$f64.\") ||\n-\t\tstrings.HasPrefix(sym.Name, \"$f32.\") ||\n-\t\tlinkerDefined[sym.Name]\n-}\n-\n-// autoData defines the automatically generated data symbols needed by p.\n-func (p *Prog) autoData() {\n-\tfor sym := range p.Missing {\n-\t\tswitch {\n-\t\t// Floating-point constants that need to be loaded from memory are\n-\t\t// written as $f64.{16 hex digits} or $f32.{8 hex digits}; the hex digits\n-\t\t// give the IEEE bit pattern of the constant. As far as the layout into\n-\t\t// memory is concerned, we interpret these as uint64 or uint32 constants.\n-\t\tcase strings.HasPrefix(sym.Name, \"$f64.\"), strings.HasPrefix(sym.Name, \"$f32.\"):\n-\t\t\tsize := 64\n-\t\t\tif sym.Name[2:4] == \"32\" {\n-\t\t\t\tsize = 32\n-\t\t\t}\n-\t\t\tdelete(p.Missing, sym)\n-\t\t\tfbits, err := strconv.ParseUint(sym.Name[len(\"$f64.\"):], 16, size)\n-\t\t\tif err != nil {\n-\t\t\t\tp.errorf(\"unexpected floating point symbol %s\", sym)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tdata := make([]byte, size/8)\n-\t\t\tif size == 64 {\n-\t\t\t\tp.byteorder.PutUint64(data, fbits)\n-\t\t\t} else {\n-\t\t\t\tp.byteorder.PutUint32(data, uint32(fbits))\n-\t\t\t}\n-\t\t\tp.addSym(&Sym{\n-\t\t\t\tSym: &goobj.Sym{\n-\t\t\t\t\tSymID: sym,\n-\t\t\t\t\tKind:  goobj.SRODATA,\n-\t\t\t\t\tSize:  size / 8,\n-\t\t\t\t},\n-\t\t\t\tBytes: data,\n-\t\t\t})\n-\t\t}\n-\t}\n-}\n-\n-// autoConst defines the automatically generated constant symbols needed by p.\n-func (p *Prog) autoConst() {\n-\tfor sym := range p.Missing {\n-\t\tswitch {\n-\t\tcase strings.HasPrefix(sym.Name, \"go.weak.\"):\n-\t\t\t// weak symbol resolves to actual symbol if present, or else nil.\n-\t\t\tdelete(p.Missing, sym)\n-\t\t\ttarg := sym\n-\t\t\ttarg.Name = sym.Name[len(\"go.weak.\"):]\n-\t\t\tvar addr Addr\n-\t\t\tif s := p.Syms[targ]; s != nil {\n-\t\t\t\taddr = s.Addr\n-\t\t\t}\n-\t\t\tp.defineConst(sym.Name, addr)\n-\t\t}\n-\t}\n-}\n-\n-// defineConst defines a new symbol with the given name and constant address.\n-func (p *Prog) defineConst(name string, addr Addr) {\n-\tsym := goobj.SymID{Name: name}\n-\tp.addSym(&Sym{\n-\t\tSym: &goobj.Sym{\n-\t\t\tSymID: sym,\n-\t\t\tKind:  goobj.SCONST,\n-\t\t},\n-\t\tPackage: nil,\n-\t\tAddr:    addr,\n-\t})\n-}"},{"sha":"f99e097a9c382f3d936beadd05b41855e86437ab","filename":"src/cmd/newlink/auto_test.go","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/auto_test.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/auto_test.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/auto_test.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,72 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Test for auto-generated symbols.\n-\n-// There is no test for $f64. and $f32. symbols, because those are\n-// not possible to write in the assembler syntax. Instead of changing\n-// the assembler to allow that, we plan to change the compilers\n-// not to generate such symbols (plain dupok data is sufficient).\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"cmd/internal/goobj\"\n-\t\"testing\"\n-)\n-\n-// Each test case is an object file, generated from a corresponding .s file.\n-// The image of the autotab symbol should be a sequence of pairs of\n-// identical 8-byte sequences.\n-var autoTests = []string{\n-\t\"testdata/autosection.6\",\n-\t\"testdata/autoweak.6\",\n-}\n-\n-func TestAuto(t *testing.T) {\n-\tfor _, obj := range autoTests {\n-\t\tp := Prog{GOOS: \"darwin\", GOARCH: \"amd64\", StartSym: \"start\"}\n-\t\tp.omitRuntime = true\n-\t\tp.Error = func(s string) { t.Error(s) }\n-\t\tvar buf bytes.Buffer\n-\t\tp.link(&buf, obj)\n-\t\tif p.NumError > 0 {\n-\t\t\tcontinue // already reported\n-\t\t}\n-\n-\t\tconst name = \"autotab\"\n-\t\tsym := p.Syms[goobj.SymID{Name: name}]\n-\t\tif sym == nil {\n-\t\t\tt.Errorf(\"%s is missing %s symbol\", obj, name)\n-\t\t\treturn\n-\t\t}\n-\t\tif sym.Size == 0 {\n-\t\t\treturn\n-\t\t}\n-\n-\t\tseg := sym.Section.Segment\n-\t\toff := sym.Addr - seg.VirtAddr\n-\t\tdata := seg.Data[off : off+Addr(sym.Size)]\n-\t\tif len(data)%16 != 0 {\n-\t\t\tt.Errorf(\"%s: %s.Size = %d, want multiple of 16\", obj, name, len(data))\n-\t\t\treturn\n-\t\t}\n-\tData:\n-\t\tfor i := 0; i < len(data); i += 16 {\n-\t\t\thave := p.byteorder.Uint64(data[i : i+8])\n-\t\t\twant := p.byteorder.Uint64(data[i+8 : i+16])\n-\t\t\tif have != want {\n-\t\t\t\t// Look for relocation so we can explain what went wrong.\n-\t\t\t\tfor _, r := range sym.Reloc {\n-\t\t\t\t\tif r.Offset == i {\n-\t\t\t\t\t\tt.Errorf(\"%s: %s+%#x: %s: have %#x want %#x\", obj, name, i, r.Sym, have, want)\n-\t\t\t\t\t\tcontinue Data\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tt.Errorf(\"%s: %s+%#x: have %#x want %#x\", obj, name, i, have, want)\n-\t\t\t}\n-\t\t}\n-\t}\n-}"},{"sha":"ee23a61f81f96c097fc367e3e4e603bf6b848611","filename":"src/cmd/newlink/dead.go","status":"removed","additions":0,"deletions":74,"changes":74,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/dead.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/dead.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/dead.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,74 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Removal of dead code and data.\n-\n-package main\n-\n-import \"cmd/internal/goobj\"\n-\n-// dead removes unreachable code and data from the program.\n-// It is basically a mark-sweep garbage collection: traverse all the\n-// symbols reachable from the entry (startSymID) and then delete\n-// the rest.\n-func (p *Prog) dead() {\n-\tp.Dead = make(map[goobj.SymID]bool)\n-\treachable := make(map[goobj.SymID]bool)\n-\tp.walkDead(p.startSym, reachable)\n-\n-\tfor sym := range p.Syms {\n-\t\tif !reachable[sym] {\n-\t\t\tdelete(p.Syms, sym)\n-\t\t\tp.Dead[sym] = true\n-\t\t}\n-\t}\n-\n-\tfor sym := range p.Missing {\n-\t\tif !reachable[sym] {\n-\t\t\tdelete(p.Missing, sym)\n-\t\t\tp.Dead[sym] = true\n-\t\t}\n-\t}\n-\n-\tp.SymOrder = removeDead(p.SymOrder, reachable)\n-\n-\tfor _, pkg := range p.Packages {\n-\t\tpkg.Syms = removeDead(pkg.Syms, reachable)\n-\t}\n-}\n-\n-// walkDead traverses the symbols reachable from sym, adding them to reachable.\n-// The caller has verified that reachable[sym] = false.\n-func (p *Prog) walkDead(sym goobj.SymID, reachable map[goobj.SymID]bool) {\n-\treachable[sym] = true\n-\ts := p.Syms[sym]\n-\tif s == nil {\n-\t\treturn\n-\t}\n-\tfor i := range s.Reloc {\n-\t\tr := &s.Reloc[i]\n-\t\tif !reachable[r.Sym] {\n-\t\t\tp.walkDead(r.Sym, reachable)\n-\t\t}\n-\t}\n-\tif s.Func != nil {\n-\t\tfor _, fdata := range s.Func.FuncData {\n-\t\t\tif fdata.Sym.Name != \"\" && !reachable[fdata.Sym] {\n-\t\t\t\tp.walkDead(fdata.Sym, reachable)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// removeDead removes unreachable (dead) symbols from syms,\n-// returning a shortened slice using the same underlying array.\n-func removeDead(syms []*Sym, reachable map[goobj.SymID]bool) []*Sym {\n-\tkeep := syms[:0]\n-\tfor _, sym := range syms {\n-\t\tif reachable[sym.SymID] {\n-\t\t\tkeep = append(keep, sym)\n-\t\t}\n-\t}\n-\treturn keep\n-}"},{"sha":"eb34d0580d1889e486ee29c220d01b4f7c1b5c2b","filename":"src/cmd/newlink/dead_test.go","status":"removed","additions":0,"deletions":97,"changes":97,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/dead_test.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/dead_test.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/dead_test.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,97 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"cmd/internal/goobj\"\n-\t\"reflect\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-// Each test case is an object file, generated from a corresponding .s file.\n-// The symbols in the object file with a dead_ prefix are the ones that\n-// should be removed from the program.\n-var deadTests = []string{\n-\t\"testdata/dead.6\",\n-}\n-\n-func TestDead(t *testing.T) {\n-\tfor _, obj := range deadTests {\n-\t\tp := Prog{GOOS: \"darwin\", GOARCH: \"amd64\", StartSym: \"start\"}\n-\t\tp.omitRuntime = true\n-\t\tp.Error = func(s string) { t.Error(s) }\n-\t\tp.init()\n-\t\tp.scan(obj)\n-\t\tif p.NumError > 0 {\n-\t\t\tcontinue // already reported\n-\t\t}\n-\t\torigSyms := copyMap(p.Syms)\n-\t\torigMissing := copyMap(p.Missing)\n-\t\torigSymOrder := copySlice(p.SymOrder)\n-\t\torigPkgSyms := copySlice(p.Packages[\"main\"].Syms)\n-\t\tp.dead()\n-\t\tcheckDeadMap(t, obj, \"p.Syms\", origSyms, p.Syms)\n-\t\tcheckDeadMap(t, obj, \"p.Missing\", origMissing, p.Missing)\n-\t\tcheckDeadSlice(t, obj, \"p.SymOrder\", origSymOrder, p.SymOrder)\n-\t\tcheckDeadSlice(t, obj, `p.Packages[\"main\"].Syms`, origPkgSyms, p.Packages[\"main\"].Syms)\n-\t}\n-}\n-\n-func copyMap(m interface{}) interface{} {\n-\tv := reflect.ValueOf(m)\n-\tout := reflect.MakeMap(v.Type())\n-\tfor _, key := range v.MapKeys() {\n-\t\tout.SetMapIndex(key, v.MapIndex(key))\n-\t}\n-\treturn out.Interface()\n-}\n-\n-func checkDeadMap(t *testing.T, obj, name string, old, new interface{}) {\n-\tvold := reflect.ValueOf(old)\n-\tvnew := reflect.ValueOf(new)\n-\tfor _, vid := range vold.MapKeys() {\n-\t\tid := vid.Interface().(goobj.SymID)\n-\t\tif strings.HasPrefix(id.Name, \"dead_\") {\n-\t\t\tif vnew.MapIndex(vid).IsValid() {\n-\t\t\t\tt.Errorf(\"%s: %s contains unnecessary symbol %s\", obj, name, id)\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif !vnew.MapIndex(vid).IsValid() {\n-\t\t\t\tt.Errorf(\"%s: %s is missing symbol %s\", obj, name, id)\n-\t\t\t}\n-\t\t}\n-\t}\n-\tfor _, vid := range vnew.MapKeys() {\n-\t\tid := vid.Interface().(goobj.SymID)\n-\t\tif !vold.MapIndex(vid).IsValid() {\n-\t\t\tt.Errorf(\"%s: %s contains unexpected symbol %s\", obj, name, id)\n-\t\t}\n-\t}\n-}\n-\n-func copySlice(x []*Sym) (out []*Sym) {\n-\treturn append(out, x...)\n-}\n-\n-func checkDeadSlice(t *testing.T, obj, name string, old, new []*Sym) {\n-\tfor i, s := range old {\n-\t\tif strings.HasPrefix(s.Name, \"dead_\") {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif len(new) == 0 {\n-\t\t\tt.Errorf(\"%s: %s is missing symbol %s\\nhave%v\\nwant%v\", obj, name, s, new, old[i:])\n-\t\t\treturn\n-\t\t}\n-\t\tif new[0].SymID != s.SymID {\n-\t\t\tt.Errorf(\"%s: %s is incorrect: have %s, want %s\\nhave%v\\nwant%v\", obj, name, new[0].SymID, s.SymID, new, old[i:])\n-\t\t\treturn\n-\t\t}\n-\t\tnew = new[1:]\n-\t}\n-\tif len(new) > 0 {\n-\t\tt.Errorf(\"%s: %s has unexpected symbols: %v\", obj, name, new)\n-\t}\n-}"},{"sha":"ee20644fd08917c41d923b247e13dbd5375fb4fb","filename":"src/cmd/newlink/debug.go","status":"removed","additions":0,"deletions":11,"changes":11,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/debug.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/debug.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/debug.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,11 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Generation of debug data structures (in the executable but not mapped at run time).\n-// See also runtime.go.\n-\n-package main\n-\n-func (p *Prog) debug() {\n-}"},{"sha":"b76b26655851dcf812b53dc3e9c9688a7a75ce8a","filename":"src/cmd/newlink/hex_test.go","status":"removed","additions":0,"deletions":74,"changes":74,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/hex_test.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/hex_test.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/hex_test.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,74 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"encoding/hex\"\n-\t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"regexp\"\n-\t\"strconv\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-// mustParseHexdumpFile returns a block of data generated by\n-// parsing the hex dump in the named file.\n-// If the file cannot be read or does not contain a valid hex dump,\n-// mustParseHexdumpFile calls t.Fatal.\n-func mustParseHexdumpFile(t *testing.T, file string) []byte {\n-\thex, err := ioutil.ReadFile(file)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdata, err := parseHexdump(string(hex))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\treturn data\n-}\n-\n-// parseHexdump parses the hex dump in text, which should be the\n-// output of \"hexdump -C\" or Plan 9's \"xd -b\",\n-// and returns the original data used to produce the dump.\n-// It is meant to enable storing golden binary files as text, so that\n-// changes to the golden files can be seen during code reviews.\n-func parseHexdump(text string) ([]byte, error) {\n-\tvar out []byte\n-\tfor _, line := range strings.Split(text, \"\\n\") {\n-\t\tif i := strings.Index(line, \"|\"); i >= 0 { // remove text dump\n-\t\t\tline = line[:i]\n-\t\t}\n-\t\tf := strings.Fields(line)\n-\t\tif len(f) > 1+16 {\n-\t\t\treturn nil, fmt.Errorf(\"parsing hex dump: too many fields on line %q\", line)\n-\t\t}\n-\t\tif len(f) == 0 || len(f) == 1 && f[0] == \"*\" { // all zeros block omitted\n-\t\t\tcontinue\n-\t\t}\n-\t\taddr64, err := strconv.ParseUint(f[0], 16, 0)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"parsing hex dump: invalid address %q\", f[0])\n-\t\t}\n-\t\taddr := int(addr64)\n-\t\tif len(out) < addr {\n-\t\t\tout = append(out, make([]byte, addr-len(out))...)\n-\t\t}\n-\t\tfor _, x := range f[1:] {\n-\t\t\tval, err := strconv.ParseUint(x, 16, 8)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"parsing hexdump: invalid hex byte %q\", x)\n-\t\t\t}\n-\t\t\tout = append(out, byte(val))\n-\t\t}\n-\t}\n-\treturn out, nil\n-}\n-\n-func hexdump(data []byte) string {\n-\ttext := hex.Dump(data) + fmt.Sprintf(\"%08x\\n\", len(data))\n-\ttext = regexp.MustCompile(`\\n([0-9a-f]+(\\s+00){16}.*\\n)+`).ReplaceAllString(text, \"\\n*\\n\")\n-\treturn text\n-}"},{"sha":"d5c291e255370ff36ed1bb8eb45fa6e09545ecc0","filename":"src/cmd/newlink/layout.go","status":"removed","additions":0,"deletions":180,"changes":180,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/layout.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/layout.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/layout.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,180 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Executable image layout - address assignment.\n-\n-package main\n-\n-import (\n-\t\"cmd/internal/goobj\"\n-)\n-\n-// A layoutSection describes a single section to add to the\n-// final executable. Go binaries only have a fixed set of possible\n-// sections, and the symbol kind determines the section.\n-type layoutSection struct {\n-\tSegment string\n-\tSection string\n-\tKind    goobj.SymKind\n-\tIndex   int\n-}\n-\n-// layout defines the layout of the generated Go executable.\n-// The order of entries here is the order in the executable.\n-// Entries with the same Segment name must be contiguous.\n-var layout = []layoutSection{\n-\t{Segment: \"text\", Section: \"text\", Kind: goobj.STEXT},\n-\t{Segment: \"rodata\", Section: \"rodata\", Kind: goobj.SRODATA},\n-\t{Segment: \"rodata\", Section: \"functab\", Kind: goobj.SPCLNTAB},\n-\t{Segment: \"rodata\", Section: \"typelink\", Kind: goobj.STYPELINK},\n-\t{Segment: \"data\", Section: \"noptrdata\", Kind: goobj.SNOPTRDATA},\n-\t{Segment: \"data\", Section: \"data\", Kind: goobj.SDATA},\n-\t{Segment: \"data\", Section: \"bss\", Kind: goobj.SBSS},\n-\t{Segment: \"data\", Section: \"noptrbss\", Kind: goobj.SNOPTRBSS},\n-\n-\t// Later:\n-\t//\t{\"rodata\", \"type\", goobj.STYPE},\n-\t//\t{\"rodata\", \"string\", goobj.SSTRING},\n-\t//\t{\"rodata\", \"gostring\", goobj.SGOSTRING},\n-\t//\t{\"rodata\", \"gofunc\", goobj.SGOFUNC},\n-}\n-\n-// layoutByKind maps from SymKind to an entry in layout.\n-var layoutByKind []*layoutSection\n-\n-func init() {\n-\t// Build index from symbol type to layout entry.\n-\tmax := 0\n-\tfor _, sect := range layout {\n-\t\tif max <= int(sect.Kind) {\n-\t\t\tmax = int(sect.Kind) + 1\n-\t\t}\n-\t}\n-\tlayoutByKind = make([]*layoutSection, max)\n-\tfor i := range layout {\n-\t\tsect := &layout[i]\n-\t\tlayoutByKind[sect.Kind] = sect\n-\t\tsect.Index = i\n-\t}\n-}\n-\n-// layout arranges symbols into sections and sections into segments,\n-// and then it assigns addresses to segments, sections, and symbols.\n-func (p *Prog) layout() {\n-\tsections := make([]*Section, len(layout))\n-\n-\t// Assign symbols to sections using index, creating sections as needed.\n-\t// Could keep sections separated by type during input instead.\n-\tfor _, sym := range p.SymOrder {\n-\t\tkind := sym.Kind\n-\t\tif kind < 0 || int(kind) >= len(layoutByKind) || layoutByKind[kind] == nil {\n-\t\t\tp.errorf(\"%s: unexpected symbol kind %v\", sym.SymID, kind)\n-\t\t\tcontinue\n-\t\t}\n-\t\tlsect := layoutByKind[kind]\n-\t\tsect := sections[lsect.Index]\n-\t\tif sect == nil {\n-\t\t\tsect = &Section{\n-\t\t\t\tName:  lsect.Section,\n-\t\t\t\tAlign: 1,\n-\t\t\t}\n-\t\t\tsections[lsect.Index] = sect\n-\t\t}\n-\t\tif sym.Data.Size > 0 || len(sym.Bytes) > 0 {\n-\t\t\tsect.InFile = true\n-\t\t}\n-\t\tsym.Section = sect\n-\t\tsect.Syms = append(sect.Syms, sym)\n-\n-\t\t// TODO(rsc): Incorporate alignment information.\n-\t\t// First that information needs to be added to the object files.\n-\t\t//\n-\t\t// if sect.Align < Addr(sym.Align) {\n-\t\t//\tsect.Align = Addr(sym.Align)\n-\t\t// }\n-\t}\n-\n-\t// Assign sections to segments, creating segments as needed.\n-\tvar seg *Segment\n-\tfor i, sect := range sections {\n-\t\tif sect == nil {\n-\t\t\tcontinue\n-\t\t}\n-\t\tsegName := layout[i].Segment\n-\n-\t\t// Special case: Mach-O does not support \"rodata\" segment,\n-\t\t// so store read-only data in text segment.\n-\t\tif p.GOOS == \"darwin\" && segName == \"rodata\" {\n-\t\t\tsegName = \"text\"\n-\t\t}\n-\n-\t\tif seg == nil || seg.Name != segName {\n-\t\t\tseg = &Segment{\n-\t\t\t\tName: segName,\n-\t\t\t}\n-\t\t\tp.Segments = append(p.Segments, seg)\n-\t\t}\n-\t\tsect.Segment = seg\n-\t\tseg.Sections = append(seg.Sections, sect)\n-\t}\n-\n-\t// Assign addresses.\n-\n-\t// TODO(rsc): This choice needs to be informed by both\n-\t// the formatter and the target architecture.\n-\t// And maybe eventually a command line flag (sigh).\n-\tconst segAlign = 4096\n-\n-\t// TODO(rsc): Use a larger amount on most systems, which will let the\n-\t// compiler eliminate more nil checks.\n-\tif p.UnmappedSize == 0 {\n-\t\tp.UnmappedSize = segAlign\n-\t}\n-\n-\t// TODO(rsc): addr := Addr(0) when generating a shared library or PIE.\n-\taddr := p.UnmappedSize\n-\n-\t// Account for initial file header.\n-\thdrVirt, hdrFile := p.formatter.headerSize(p)\n-\taddr += hdrVirt\n-\n-\t// Assign addresses to segments, sections, symbols.\n-\t// Assign sizes to segments, sections.\n-\tstartVirt := addr\n-\tstartFile := hdrFile\n-\tfor _, seg := range p.Segments {\n-\t\taddr = round(addr, segAlign)\n-\t\tseg.VirtAddr = addr\n-\t\tseg.FileOffset = startFile + seg.VirtAddr - startVirt\n-\t\tfor _, sect := range seg.Sections {\n-\t\t\taddr = round(addr, sect.Align)\n-\t\t\tsect.VirtAddr = addr\n-\t\t\tfor _, sym := range sect.Syms {\n-\t\t\t\t// TODO(rsc): Respect alignment once we have that information.\n-\t\t\t\tsym.Addr = addr\n-\t\t\t\taddr += Addr(sym.Size)\n-\t\t\t}\n-\t\t\tsect.Size = addr - sect.VirtAddr\n-\t\t\tif sect.InFile {\n-\t\t\t\tseg.FileSize = addr - seg.VirtAddr\n-\t\t\t}\n-\t\t}\n-\t\tseg.VirtSize = addr - seg.VirtAddr\n-\t}\n-\n-\t// Define symbols for section names.\n-\tvar progEnd Addr\n-\tfor i, sect := range sections {\n-\t\tname := layout[i].Section\n-\t\tvar start, end Addr\n-\t\tif sect != nil {\n-\t\t\tstart = sect.VirtAddr\n-\t\t\tend = sect.VirtAddr + sect.Size\n-\t\t}\n-\t\tp.defineConst(\"runtime.\"+name, start)\n-\t\tp.defineConst(\"runtime.e\"+name, end)\n-\t\tprogEnd = end\n-\t}\n-\tp.defineConst(\"runtime.end\", progEnd)\n-}"},{"sha":"e5513af35e6a2074f3e836b6ef8100030c31f9a8","filename":"src/cmd/newlink/layout_test.go","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/layout_test.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/layout_test.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/layout_test.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,45 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-func TestLayout(t *testing.T) {\n-\tp := Prog{GOOS: \"darwin\", GOARCH: \"amd64\", StartSym: \"text_start\"}\n-\tp.omitRuntime = true\n-\tp.Error = func(s string) { t.Error(s) }\n-\tvar buf bytes.Buffer\n-\tconst obj = \"testdata/layout.6\"\n-\tp.link(&buf, obj)\n-\tif p.NumError > 0 {\n-\t\treturn // already reported\n-\t}\n-\tif len(p.Dead) > 0 {\n-\t\tt.Errorf(\"%s: unexpected dead symbols %v\", obj, p.Dead)\n-\t\treturn\n-\t}\n-\n-\tfor _, sym := range p.SymOrder {\n-\t\tif p.isAuto(sym.SymID) {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif sym.Section == nil {\n-\t\t\tt.Errorf(\"%s: symbol %s is missing section\", obj, sym)\n-\t\t\tcontinue\n-\t\t}\n-\t\ti := strings.Index(sym.Name, \"_\")\n-\t\tif i < 0 {\n-\t\t\tt.Errorf(\"%s: unexpected symbol %s\", obj, sym)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif sym.Section.Name != sym.Name[:i] {\n-\t\t\tt.Errorf(\"%s: symbol %s in section %s, want %s\", obj, sym, sym.Section.Name, sym.Name[:i])\n-\t\t}\n-\t}\n-}"},{"sha":"b5ae15fc7108a008fd44096895ef3e7e053eef2c","filename":"src/cmd/newlink/link_test.go","status":"removed","additions":0,"deletions":35,"changes":35,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/link_test.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/link_test.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/link_test.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,35 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"cmd/internal/goobj\"\n-\t\"io/ioutil\"\n-\t\"testing\"\n-)\n-\n-func TestLinkHello(t *testing.T) {\n-\tp := &Prog{\n-\t\tGOOS:     \"darwin\",\n-\t\tGOARCH:   \"amd64\",\n-\t\tError:    func(s string) { t.Error(s) },\n-\t\tStartSym: \"_rt0_go\",\n-\t}\n-\tvar buf bytes.Buffer\n-\tp.link(&buf, \"testdata/hello.6\")\n-\tif p.NumError > 0 {\n-\t\treturn\n-\t}\n-\tif p.Syms[goobj.SymID{\"_rt0_go\", 0}] == nil || p.Syms[goobj.SymID{\"hello\", 1}] == nil {\n-\t\tt.Errorf(\"Syms = %v, want at least [_rt0_go hello<1>]\", p.Syms)\n-\t}\n-\n-\t// uncomment to leave file behind for execution:\n-\tif false {\n-\t\tioutil.WriteFile(\"a.out\", buf.Bytes(), 0777)\n-\t}\n-\tcheckGolden(t, buf.Bytes(), \"testdata/link.hello.darwin.amd64\")\n-}"},{"sha":"50602b82a10618e0e57670ac178462fcf36fc035","filename":"src/cmd/newlink/load.go","status":"removed","additions":0,"deletions":108,"changes":108,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/load.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/load.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/load.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,108 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Loading of code and data fragments from package files into final image.\n-\n-package main\n-\n-import (\n-\t\"cmd/internal/obj\"\n-\t\"os\"\n-)\n-\n-// load allocates segment images, populates them with data\n-// read from package files, and applies relocations to the data.\n-func (p *Prog) load() {\n-\t// TODO(rsc): mmap the output file and store the data directly.\n-\t// That will make writing the output file more efficient.\n-\tfor _, seg := range p.Segments {\n-\t\tseg.Data = make([]byte, seg.FileSize)\n-\t}\n-\tfor _, pkg := range p.Packages {\n-\t\tp.loadPackage(pkg)\n-\t}\n-}\n-\n-// loadPackage loads and relocates data for all the\n-// symbols needed in the given package.\n-func (p *Prog) loadPackage(pkg *Package) {\n-\tif pkg.File == \"\" {\n-\t\t// This \"package\" contains internally generated symbols only.\n-\t\t// All such symbols have a sym.Bytes field holding the actual data\n-\t\t// (if any), plus relocations.\n-\t\tfor _, sym := range pkg.Syms {\n-\t\t\tif sym.Bytes == nil {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tseg := sym.Section.Segment\n-\t\t\toff := sym.Addr - seg.VirtAddr\n-\t\t\tdata := seg.Data[off : off+Addr(sym.Size)]\n-\t\t\tcopy(data, sym.Bytes)\n-\t\t\tp.relocateSym(sym, data)\n-\t\t}\n-\t\treturn\n-\t}\n-\n-\t// Package stored in file.\n-\tf, err := os.Open(pkg.File)\n-\tif err != nil {\n-\t\tp.errorf(\"%v\", err)\n-\t\treturn\n-\t}\n-\tdefer f.Close()\n-\n-\t// TODO(rsc): Mmap file into memory.\n-\n-\tfor _, sym := range pkg.Syms {\n-\t\tif sym.Data.Size == 0 {\n-\t\t\tcontinue\n-\t\t}\n-\t\t// TODO(rsc): If not using mmap, at least coalesce nearby reads.\n-\t\tif sym.Section == nil {\n-\t\t\tp.errorf(\"internal error: missing section for %s\", sym.Name)\n-\t\t}\n-\t\tseg := sym.Section.Segment\n-\t\toff := sym.Addr - seg.VirtAddr\n-\t\tif off >= Addr(len(seg.Data)) || off+Addr(sym.Data.Size) > Addr(len(seg.Data)) {\n-\t\t\tp.errorf(\"internal error: allocated space for %s too small: %d bytes for %d+%d (%d)\", sym, len(seg.Data), off, sym.Data.Size, sym.Size)\n-\t\t}\n-\t\tdata := seg.Data[off : off+Addr(sym.Data.Size)]\n-\t\t_, err := f.ReadAt(data, sym.Data.Offset)\n-\t\tif err != nil {\n-\t\t\tp.errorf(\"reading %v: %v\", sym.SymID, err)\n-\t\t}\n-\t\tp.relocateSym(sym, data)\n-\t}\n-}\n-\n-// relocateSym applies relocations to sym's data.\n-func (p *Prog) relocateSym(sym *Sym, data []byte) {\n-\tfor i := range sym.Reloc {\n-\t\tr := &sym.Reloc[i]\n-\t\ttarg := p.Syms[r.Sym]\n-\t\tif targ == nil {\n-\t\t\tp.errorf(\"%v: reference to undefined symbol %v\", sym, r.Sym)\n-\t\t\tcontinue\n-\t\t}\n-\t\tval := targ.Addr + Addr(r.Add)\n-\t\tswitch r.Type {\n-\t\tdefault:\n-\t\t\tp.errorf(\"%v: unknown relocation type %d\", sym, r.Type)\n-\t\tcase obj.R_ADDR, obj.R_CALLIND:\n-\t\t\t// ok\n-\t\tcase obj.R_PCREL, obj.R_CALL:\n-\t\t\tval -= sym.Addr + Addr(r.Offset+r.Size)\n-\t\t}\n-\t\tfrag := data[r.Offset : r.Offset+r.Size]\n-\t\tswitch r.Size {\n-\t\tdefault:\n-\t\t\tp.errorf(\"%v: unknown relocation size %d\", sym, r.Size)\n-\t\tcase 4:\n-\t\t\t// TODO(rsc): Check for overflow?\n-\t\t\tp.byteorder.PutUint32(frag, uint32(val))\n-\t\tcase 8:\n-\t\t\tp.byteorder.PutUint64(frag, uint64(val))\n-\t\t}\n-\t}\n-}"},{"sha":"4e5524be9b8e0d54bfb99712b2025ed66ae3294b","filename":"src/cmd/newlink/macho.go","status":"removed","additions":0,"deletions":380,"changes":380,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/macho.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/macho.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/macho.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,380 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Mach-O (Darwin) object file writing.\n-\n-package main\n-\n-import (\n-\t\"debug/macho\"\n-\t\"encoding/binary\"\n-\t\"io\"\n-\t\"strings\"\n-)\n-\n-// machoFormat is the implementation of formatter.\n-type machoFormat struct{}\n-\n-// machoHeader and friends are data structures\n-// corresponding to the Mach-O file header\n-// to be written to disk.\n-\n-const (\n-\tmacho64Bit     = 1 << 24\n-\tmachoSubCPU386 = 3\n-)\n-\n-// machoArch describes a Mach-O target architecture.\n-type machoArch struct {\n-\tCPU    uint32\n-\tSubCPU uint32\n-}\n-\n-// machoHeader is the Mach-O file header.\n-type machoHeader struct {\n-\tmachoArch\n-\tFileType uint32\n-\tLoads    []*machoLoad\n-\tSegments []*machoSegment\n-\tp        *Prog // for reporting errors\n-}\n-\n-// machoLoad is a Mach-O load command.\n-type machoLoad struct {\n-\tType uint32\n-\tData []uint32\n-}\n-\n-// machoSegment is a Mach-O segment.\n-type machoSegment struct {\n-\tName       string\n-\tVirtAddr   Addr\n-\tVirtSize   Addr\n-\tFileOffset Addr\n-\tFileSize   Addr\n-\tProt1      uint32\n-\tProt2      uint32\n-\tFlags      uint32\n-\tSections   []*machoSection\n-}\n-\n-// machoSection is a Mach-O section, inside a segment.\n-type machoSection struct {\n-\tName    string\n-\tSegment string\n-\tAddr    Addr\n-\tSize    Addr\n-\tOffset  uint32\n-\tAlign   uint32\n-\tReloc   uint32\n-\tNreloc  uint32\n-\tFlags   uint32\n-\tRes1    uint32\n-\tRes2    uint32\n-}\n-\n-// layout positions the segments and sections in p\n-// to make room for the Mach-O file header.\n-// That is, it edits their VirtAddr fields to adjust for the presence\n-// of the Mach-O header at the beginning of the address space.\n-func (machoFormat) headerSize(p *Prog) (virt, file Addr) {\n-\tvar h machoHeader\n-\th.init(p)\n-\tsize := Addr(h.size())\n-\tsize = round(size, 4096)\n-\tp.HeaderSize = size\n-\treturn size, size\n-}\n-\n-// write writes p to w as a Mach-O executable.\n-// layout(p) must have already been called,\n-// and the number, sizes, and addresses of the segments\n-// and sections must not have been modified since the call.\n-func (machoFormat) write(w io.Writer, p *Prog) {\n-\tvar h machoHeader\n-\th.init(p)\n-\toff := Addr(0)\n-\tenc := h.encode()\n-\tw.Write(enc)\n-\toff += Addr(len(enc))\n-\tfor _, seg := range p.Segments {\n-\t\tif seg.FileOffset < off {\n-\t\t\th.p.errorf(\"mach-o error: invalid file offset\")\n-\t\t}\n-\t\tw.Write(make([]byte, int(seg.FileOffset-off)))\n-\t\tif seg.FileSize != Addr(len(seg.Data)) {\n-\t\t\th.p.errorf(\"mach-o error: invalid file size\")\n-\t\t}\n-\t\tw.Write(seg.Data)\n-\t\toff = seg.FileOffset + Addr(len(seg.Data))\n-\t}\n-}\n-\n-// Conversion of Prog to macho data structures.\n-\n-// machoArches maps from GOARCH to machoArch.\n-var machoArches = map[string]machoArch{\n-\t\"amd64\": {\n-\t\tCPU:    uint32(macho.CpuAmd64),\n-\t\tSubCPU: uint32(machoSubCPU386),\n-\t},\n-}\n-\n-// init initializes the header h to describe p.\n-func (h *machoHeader) init(p *Prog) {\n-\th.p = p\n-\th.Segments = nil\n-\th.Loads = nil\n-\tvar ok bool\n-\th.machoArch, ok = machoArches[p.GOARCH]\n-\tif !ok {\n-\t\tp.errorf(\"mach-o: unknown target GOARCH %q\", p.GOARCH)\n-\t\treturn\n-\t}\n-\th.FileType = uint32(macho.TypeExec)\n-\n-\tmseg := h.addSegment(p, \"__PAGEZERO\", nil)\n-\tmseg.VirtSize = p.UnmappedSize\n-\n-\tfor _, seg := range p.Segments {\n-\t\th.addSegment(p, \"__\"+strings.ToUpper(seg.Name), seg)\n-\t}\n-\n-\tvar data []uint32\n-\tswitch h.CPU {\n-\tdefault:\n-\t\tp.errorf(\"mach-o: unknown cpu %#x for GOARCH %q\", h.CPU, p.GOARCH)\n-\tcase uint32(macho.CpuAmd64):\n-\t\tdata = make([]uint32, 2+42)\n-\t\tdata[0] = 4                  // thread type\n-\t\tdata[1] = 42                 // word count\n-\t\tdata[2+32] = uint32(p.Entry) // RIP register, in two parts\n-\t\tdata[2+32+1] = uint32(p.Entry >> 32)\n-\t}\n-\n-\th.Loads = append(h.Loads, &machoLoad{\n-\t\tType: uint32(macho.LoadCmdUnixThread),\n-\t\tData: data,\n-\t})\n-}\n-\n-// addSegment adds to h a Mach-O segment like seg with the given name.\n-func (h *machoHeader) addSegment(p *Prog, name string, seg *Segment) *machoSegment {\n-\tmseg := &machoSegment{\n-\t\tName: name,\n-\t}\n-\th.Segments = append(h.Segments, mseg)\n-\tif seg == nil {\n-\t\treturn mseg\n-\t}\n-\n-\tmseg.VirtAddr = seg.VirtAddr\n-\tmseg.VirtSize = seg.VirtSize\n-\tmseg.FileOffset = round(seg.FileOffset, 4096)\n-\tmseg.FileSize = seg.FileSize\n-\n-\tif name == \"__TEXT\" {\n-\t\t// Initially RWX, then just RX\n-\t\tmseg.Prot1 = 7\n-\t\tmseg.Prot2 = 5\n-\n-\t\t// Text segment maps Mach-O header, needed by dynamic linker.\n-\t\tmseg.VirtAddr -= p.HeaderSize\n-\t\tmseg.VirtSize += p.HeaderSize\n-\t\tmseg.FileOffset -= p.HeaderSize\n-\t\tmseg.FileSize += p.HeaderSize\n-\t} else {\n-\t\t// RW\n-\t\tmseg.Prot1 = 3\n-\t\tmseg.Prot2 = 3\n-\t}\n-\n-\tfor _, sect := range seg.Sections {\n-\t\th.addSection(mseg, seg, sect)\n-\t}\n-\treturn mseg\n-}\n-\n-// addSection adds to mseg a Mach-O section like sect, inside seg, with the given name.\n-func (h *machoHeader) addSection(mseg *machoSegment, seg *Segment, sect *Section) {\n-\tmsect := &machoSection{\n-\t\tName:    \"__\" + sect.Name,\n-\t\tSegment: mseg.Name,\n-\t\t// Reloc: sect.RelocOffset,\n-\t\t// NumReloc: sect.RelocLen / 8,\n-\t\tAddr: sect.VirtAddr,\n-\t\tSize: sect.Size,\n-\t}\n-\tmseg.Sections = append(mseg.Sections, msect)\n-\n-\tfor 1<<msect.Align < sect.Align {\n-\t\tmsect.Align++\n-\t}\n-\n-\tif off := sect.VirtAddr - seg.VirtAddr; off < seg.FileSize {\n-\t\t// Data in file.\n-\t\tif sect.Size > seg.FileSize-off {\n-\t\t\th.p.errorf(\"mach-o error: section crosses file boundary\")\n-\t\t}\n-\t\tmsect.Offset = uint32(seg.FileOffset + off)\n-\t} else {\n-\t\t// Zero filled.\n-\t\tmsect.Flags |= 1\n-\t}\n-\n-\tif sect.Name == \"text\" {\n-\t\tmsect.Flags |= 0x400 // contains executable instructions\n-\t}\n-}\n-\n-// A machoWriter helps write Mach-O headers.\n-// It is basically a buffer with some helper routines for writing integers.\n-type machoWriter struct {\n-\tdst   []byte\n-\ttmp   [8]byte\n-\torder binary.ByteOrder\n-\tis64  bool\n-\tp     *Prog\n-}\n-\n-// if64 returns x if w is writing a 64-bit object file; otherwise it returns y.\n-func (w *machoWriter) if64(x, y interface{}) interface{} {\n-\tif w.is64 {\n-\t\treturn x\n-\t}\n-\treturn y\n-}\n-\n-// encode encodes each of the given arguments into the writer.\n-// It encodes uint32, []uint32, uint64, and []uint64 by writing each value\n-// in turn in the correct byte order for the output file.\n-// It encodes an Addr as a uint64 if writing a 64-bit output file, or else as a uint32.\n-// It encodes []byte and string by writing the raw bytes (no length prefix).\n-// It skips nil values in the args list.\n-func (w *machoWriter) encode(args ...interface{}) {\n-\tfor _, arg := range args {\n-\t\tswitch arg := arg.(type) {\n-\t\tdefault:\n-\t\t\tw.p.errorf(\"mach-o error: cannot encode %T\", arg)\n-\t\tcase nil:\n-\t\t\t// skip\n-\t\tcase []byte:\n-\t\t\tw.dst = append(w.dst, arg...)\n-\t\tcase string:\n-\t\t\tw.dst = append(w.dst, arg...)\n-\t\tcase uint32:\n-\t\t\tw.order.PutUint32(w.tmp[:], arg)\n-\t\t\tw.dst = append(w.dst, w.tmp[:4]...)\n-\t\tcase []uint32:\n-\t\t\tfor _, x := range arg {\n-\t\t\t\tw.order.PutUint32(w.tmp[:], x)\n-\t\t\t\tw.dst = append(w.dst, w.tmp[:4]...)\n-\t\t\t}\n-\t\tcase uint64:\n-\t\t\tw.order.PutUint64(w.tmp[:], arg)\n-\t\t\tw.dst = append(w.dst, w.tmp[:8]...)\n-\t\tcase Addr:\n-\t\t\tif w.is64 {\n-\t\t\t\tw.order.PutUint64(w.tmp[:], uint64(arg))\n-\t\t\t\tw.dst = append(w.dst, w.tmp[:8]...)\n-\t\t\t} else {\n-\t\t\t\tif Addr(uint32(arg)) != arg {\n-\t\t\t\t\tw.p.errorf(\"mach-o error: truncating address %#x to uint32\", arg)\n-\t\t\t\t}\n-\t\t\t\tw.order.PutUint32(w.tmp[:], uint32(arg))\n-\t\t\t\tw.dst = append(w.dst, w.tmp[:4]...)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// segmentSize returns the size of the encoding of seg in bytes.\n-func (w *machoWriter) segmentSize(seg *machoSegment) int {\n-\tif w.is64 {\n-\t\treturn 18*4 + 20*4*len(seg.Sections)\n-\t}\n-\treturn 14*4 + 22*4*len(seg.Sections)\n-}\n-\n-// zeroPad returns the string s truncated or padded with NULs to n bytes.\n-func zeroPad(s string, n int) string {\n-\tif len(s) >= n {\n-\t\treturn s[:n]\n-\t}\n-\treturn s + strings.Repeat(\"\\x00\", n-len(s))\n-}\n-\n-// size returns the encoded size of the header.\n-func (h *machoHeader) size() int {\n-\t// Could write separate code, but encoding is cheap; encode and throw it away.\n-\treturn len(h.encode())\n-}\n-\n-// encode returns the Mach-O encoding of the header.\n-func (h *machoHeader) encode() []byte {\n-\tw := &machoWriter{p: h.p}\n-\tw.is64 = h.CPU&macho64Bit != 0\n-\tw.order = w.p.byteorder\n-\n-\tloadSize := 0\n-\tfor _, seg := range h.Segments {\n-\t\tloadSize += w.segmentSize(seg)\n-\t}\n-\tfor _, l := range h.Loads {\n-\t\tloadSize += 4 * (2 + len(l.Data))\n-\t}\n-\n-\tw.encode(\n-\t\tw.if64(macho.Magic64, macho.Magic32),\n-\t\tuint32(h.CPU),\n-\t\tuint32(h.SubCPU),\n-\t\tuint32(h.FileType),\n-\t\tuint32(len(h.Loads)+len(h.Segments)),\n-\t\tuint32(loadSize),\n-\t\tuint32(1),\n-\t\tw.if64(uint32(0), nil),\n-\t)\n-\n-\tfor _, seg := range h.Segments {\n-\t\tw.encode(\n-\t\t\tw.if64(uint32(macho.LoadCmdSegment64), uint32(macho.LoadCmdSegment)),\n-\t\t\tuint32(w.segmentSize(seg)),\n-\t\t\tzeroPad(seg.Name, 16),\n-\t\t\tseg.VirtAddr,\n-\t\t\tseg.VirtSize,\n-\t\t\tseg.FileOffset,\n-\t\t\tseg.FileSize,\n-\t\t\tseg.Prot1,\n-\t\t\tseg.Prot2,\n-\t\t\tuint32(len(seg.Sections)),\n-\t\t\tseg.Flags,\n-\t\t)\n-\t\tfor _, sect := range seg.Sections {\n-\t\t\tw.encode(\n-\t\t\t\tzeroPad(sect.Name, 16),\n-\t\t\t\tzeroPad(seg.Name, 16),\n-\t\t\t\tsect.Addr,\n-\t\t\t\tsect.Size,\n-\t\t\t\tsect.Offset,\n-\t\t\t\tsect.Align,\n-\t\t\t\tsect.Reloc,\n-\t\t\t\tsect.Nreloc,\n-\t\t\t\tsect.Flags,\n-\t\t\t\tsect.Res1,\n-\t\t\t\tsect.Res2,\n-\t\t\t\tw.if64(uint32(0), nil),\n-\t\t\t)\n-\t\t}\n-\t}\n-\n-\tfor _, load := range h.Loads {\n-\t\tw.encode(\n-\t\t\tload.Type,\n-\t\t\tuint32(4*(2+len(load.Data))),\n-\t\t\tload.Data,\n-\t\t)\n-\t}\n-\n-\treturn w.dst\n-}"},{"sha":"37c4418b7728874b29668cf338a477fb99487f87","filename":"src/cmd/newlink/macho_test.go","status":"removed","additions":0,"deletions":407,"changes":407,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/macho_test.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/macho_test.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/macho_test.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,407 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"debug/macho\"\n-\t\"encoding/binary\"\n-\t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-// Test macho writing by checking that each generated prog can be written\n-// and then read back using debug/macho to get the same prog.\n-// Also check against golden testdata file.\n-var machoWriteTests = []struct {\n-\tname   string\n-\tgolden bool\n-\tprog   *Prog\n-}{\n-\t// amd64 exit 9\n-\t{\n-\t\tname:   \"exit9\",\n-\t\tgolden: true,\n-\t\tprog: &Prog{\n-\t\t\tGOARCH:       \"amd64\",\n-\t\t\tGOOS:         \"darwin\",\n-\t\t\tUnmappedSize: 0x1000,\n-\t\t\tEntry:        0x1000,\n-\t\t\tSegments: []*Segment{\n-\t\t\t\t{\n-\t\t\t\t\tName:       \"text\",\n-\t\t\t\t\tVirtAddr:   0x1000,\n-\t\t\t\t\tVirtSize:   13,\n-\t\t\t\t\tFileOffset: 0,\n-\t\t\t\t\tFileSize:   13,\n-\t\t\t\t\tData: []byte{\n-\t\t\t\t\t\t0xb8, 0x01, 0x00, 0x00, 0x02, // MOVL $0x2000001, AX\n-\t\t\t\t\t\t0xbf, 0x09, 0x00, 0x00, 0x00, // MOVL $9, DI\n-\t\t\t\t\t\t0x0f, 0x05, // SYSCALL\n-\t\t\t\t\t\t0xf4, // HLT\n-\t\t\t\t\t},\n-\t\t\t\t\tSections: []*Section{\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tName:     \"text\",\n-\t\t\t\t\t\t\tVirtAddr: 0x1000,\n-\t\t\t\t\t\t\tSize:     13,\n-\t\t\t\t\t\t\tAlign:    64,\n-\t\t\t\t\t\t},\n-\t\t\t\t\t},\n-\t\t\t\t},\n-\t\t\t},\n-\t\t},\n-\t},\n-\n-\t// amd64 write hello world & exit 9\n-\t{\n-\t\tname:   \"hello\",\n-\t\tgolden: true,\n-\t\tprog: &Prog{\n-\t\t\tGOARCH:       \"amd64\",\n-\t\t\tGOOS:         \"darwin\",\n-\t\t\tUnmappedSize: 0x1000,\n-\t\t\tEntry:        0x1000,\n-\t\t\tSegments: []*Segment{\n-\t\t\t\t{\n-\t\t\t\t\tName:       \"text\",\n-\t\t\t\t\tVirtAddr:   0x1000,\n-\t\t\t\t\tVirtSize:   35,\n-\t\t\t\t\tFileOffset: 0,\n-\t\t\t\t\tFileSize:   35,\n-\t\t\t\t\tData: []byte{\n-\t\t\t\t\t\t0xb8, 0x04, 0x00, 0x00, 0x02, // MOVL $0x2000001, AX\n-\t\t\t\t\t\t0xbf, 0x01, 0x00, 0x00, 0x00, // MOVL $1, DI\n-\t\t\t\t\t\t0xbe, 0x00, 0x30, 0x00, 0x00, // MOVL $0x3000, SI\n-\t\t\t\t\t\t0xba, 0x0c, 0x00, 0x00, 0x00, // MOVL $12, DX\n-\t\t\t\t\t\t0x0f, 0x05, // SYSCALL\n-\t\t\t\t\t\t0xb8, 0x01, 0x00, 0x00, 0x02, // MOVL $0x2000001, AX\n-\t\t\t\t\t\t0xbf, 0x09, 0x00, 0x00, 0x00, // MOVL $9, DI\n-\t\t\t\t\t\t0x0f, 0x05, // SYSCALL\n-\t\t\t\t\t\t0xf4, // HLT\n-\t\t\t\t\t},\n-\t\t\t\t\tSections: []*Section{\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tName:     \"text\",\n-\t\t\t\t\t\t\tVirtAddr: 0x1000,\n-\t\t\t\t\t\t\tSize:     35,\n-\t\t\t\t\t\t\tAlign:    64,\n-\t\t\t\t\t\t},\n-\t\t\t\t\t},\n-\t\t\t\t},\n-\t\t\t\t{\n-\t\t\t\t\tName:       \"data\",\n-\t\t\t\t\tVirtAddr:   0x2000,\n-\t\t\t\t\tVirtSize:   12,\n-\t\t\t\t\tFileOffset: 0x1000,\n-\t\t\t\t\tFileSize:   12,\n-\t\t\t\t\tData:       []byte(\"hello world\\n\"),\n-\t\t\t\t\tSections: []*Section{\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tName:     \"data\",\n-\t\t\t\t\t\t\tVirtAddr: 0x2000,\n-\t\t\t\t\t\t\tSize:     12,\n-\t\t\t\t\t\t\tAlign:    64,\n-\t\t\t\t\t\t},\n-\t\t\t\t\t},\n-\t\t\t\t},\n-\t\t\t},\n-\t\t},\n-\t},\n-\n-\t// amd64 write hello world from rodata & exit 0\n-\t{\n-\t\tname:   \"helloro\",\n-\t\tgolden: true,\n-\t\tprog: &Prog{\n-\t\t\tGOARCH:       \"amd64\",\n-\t\t\tGOOS:         \"darwin\",\n-\t\t\tUnmappedSize: 0x1000,\n-\t\t\tEntry:        0x1000,\n-\t\t\tSegments: []*Segment{\n-\t\t\t\t{\n-\t\t\t\t\tName:       \"text\",\n-\t\t\t\t\tVirtAddr:   0x1000,\n-\t\t\t\t\tVirtSize:   0x100c,\n-\t\t\t\t\tFileOffset: 0,\n-\t\t\t\t\tFileSize:   0x100c,\n-\t\t\t\t\tData: concat(\n-\t\t\t\t\t\t[]byte{\n-\t\t\t\t\t\t\t0xb8, 0x04, 0x00, 0x00, 0x02, // MOVL $0x2000001, AX\n-\t\t\t\t\t\t\t0xbf, 0x01, 0x00, 0x00, 0x00, // MOVL $1, DI\n-\t\t\t\t\t\t\t0xbe, 0x00, 0x30, 0x00, 0x00, // MOVL $0x3000, SI\n-\t\t\t\t\t\t\t0xba, 0x0c, 0x00, 0x00, 0x00, // MOVL $12, DX\n-\t\t\t\t\t\t\t0x0f, 0x05, // SYSCALL\n-\t\t\t\t\t\t\t0xb8, 0x01, 0x00, 0x00, 0x02, // MOVL $0x2000001, AX\n-\t\t\t\t\t\t\t0xbf, 0x00, 0x00, 0x00, 0x00, // MOVL $0, DI\n-\t\t\t\t\t\t\t0x0f, 0x05, // SYSCALL\n-\t\t\t\t\t\t\t0xf4, // HLT\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\tmake([]byte, 0x1000-35),\n-\t\t\t\t\t\t[]byte(\"hello world\\n\"),\n-\t\t\t\t\t),\n-\t\t\t\t\tSections: []*Section{\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tName:     \"text\",\n-\t\t\t\t\t\t\tVirtAddr: 0x1000,\n-\t\t\t\t\t\t\tSize:     35,\n-\t\t\t\t\t\t\tAlign:    64,\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tName:     \"rodata\",\n-\t\t\t\t\t\t\tVirtAddr: 0x2000,\n-\t\t\t\t\t\t\tSize:     12,\n-\t\t\t\t\t\t\tAlign:    64,\n-\t\t\t\t\t\t},\n-\t\t\t\t\t},\n-\t\t\t\t},\n-\t\t\t},\n-\t\t},\n-\t},\n-}\n-\n-func concat(xs ...[]byte) []byte {\n-\tvar out []byte\n-\tfor _, x := range xs {\n-\t\tout = append(out, x...)\n-\t}\n-\treturn out\n-}\n-\n-func TestMachoWrite(t *testing.T) {\n-\tfor _, tt := range machoWriteTests {\n-\t\tname := tt.prog.GOARCH + \".\" + tt.name\n-\t\tprog := cloneProg(tt.prog)\n-\t\tprog.init()\n-\t\tvar f machoFormat\n-\t\tvsize, fsize := f.headerSize(prog)\n-\t\tshiftProg(prog, vsize, fsize)\n-\t\tvar buf bytes.Buffer\n-\t\tf.write(&buf, prog)\n-\t\tif false { // enable to debug\n-\t\t\tioutil.WriteFile(\"a.out\", buf.Bytes(), 0777)\n-\t\t}\n-\t\tread, err := machoRead(machoArches[tt.prog.GOARCH], buf.Bytes())\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%s: reading mach-o output:\\n\\t%v\", name, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tdiffs := diffProg(read, prog)\n-\t\tif diffs != nil {\n-\t\t\tt.Errorf(\"%s: mismatched prog:\\n\\t%s\", name, strings.Join(diffs, \"\\n\\t\"))\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !tt.golden {\n-\t\t\tcontinue\n-\t\t}\n-\t\tcheckGolden(t, buf.Bytes(), \"testdata/macho.\"+name)\n-\t}\n-}\n-\n-// machoRead reads the mach-o file in data and returns a corresponding prog.\n-func machoRead(arch machoArch, data []byte) (*Prog, error) {\n-\tf, err := macho.NewFile(bytes.NewReader(data))\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tvar errors []string\n-\terrorf := func(format string, args ...interface{}) {\n-\t\terrors = append(errors, fmt.Sprintf(format, args...))\n-\t}\n-\n-\tmagic := uint32(0xFEEDFACE)\n-\tif arch.CPU&macho64Bit != 0 {\n-\t\tmagic |= 1\n-\t}\n-\tif f.Magic != magic {\n-\t\terrorf(\"header: Magic = %#x, want %#x\", f.Magic, magic)\n-\t}\n-\tif f.Cpu != macho.CpuAmd64 {\n-\t\terrorf(\"header: CPU = %#x, want %#x\", f.Cpu, macho.CpuAmd64)\n-\t}\n-\tif f.SubCpu != 3 {\n-\t\terrorf(\"header: SubCPU = %#x, want %#x\", f.SubCpu, 3)\n-\t}\n-\tif f.Type != 2 {\n-\t\terrorf(\"header: FileType = %d, want %d\", f.Type, 2)\n-\t}\n-\tif f.Flags != 1 {\n-\t\terrorf(\"header: Flags = %d, want %d\", f.Flags, 1)\n-\t}\n-\n-\tmsects := f.Sections\n-\tvar limit uint64\n-\tprog := new(Prog)\n-\tfor _, load := range f.Loads {\n-\t\tswitch load := load.(type) {\n-\t\tdefault:\n-\t\t\terrorf(\"unexpected macho load %T %x\", load, load.Raw())\n-\n-\t\tcase macho.LoadBytes:\n-\t\t\tif len(load) < 8 || len(load)%4 != 0 {\n-\t\t\t\terrorf(\"unexpected load length %d\", len(load))\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tcmd := f.ByteOrder.Uint32(load)\n-\t\t\tswitch macho.LoadCmd(cmd) {\n-\t\t\tdefault:\n-\t\t\t\terrorf(\"unexpected macho load cmd %s\", macho.LoadCmd(cmd))\n-\t\t\tcase macho.LoadCmdUnixThread:\n-\t\t\t\tdata := make([]uint32, len(load[8:])/4)\n-\t\t\t\tbinary.Read(bytes.NewReader(load[8:]), f.ByteOrder, data)\n-\t\t\t\tif len(data) != 44 {\n-\t\t\t\t\terrorf(\"macho thread len(data) = %d, want 42\", len(data))\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tif data[0] != 4 {\n-\t\t\t\t\terrorf(\"macho thread type = %d, want 4\", data[0])\n-\t\t\t\t}\n-\t\t\t\tif data[1] != uint32(len(data))-2 {\n-\t\t\t\t\terrorf(\"macho thread desc len = %d, want %d\", data[1], uint32(len(data))-2)\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tfor i, val := range data[2:] {\n-\t\t\t\t\tswitch i {\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tif val != 0 {\n-\t\t\t\t\t\t\terrorf(\"macho thread data[%d] = %#x, want 0\", i, val)\n-\t\t\t\t\t\t}\n-\t\t\t\t\tcase 32:\n-\t\t\t\t\t\tprog.Entry = Addr(val)\n-\t\t\t\t\tcase 33:\n-\t\t\t\t\t\tprog.Entry |= Addr(val) << 32\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\tcase *macho.Segment:\n-\t\t\tif load.Addr < limit {\n-\t\t\t\terrorf(\"segments out of order: %q at %#x after %#x\", load.Name, load.Addr, limit)\n-\t\t\t}\n-\t\t\tlimit = load.Addr + load.Memsz\n-\t\t\tif load.Name == \"__PAGEZERO\" || load.Addr == 0 && load.Filesz == 0 {\n-\t\t\t\tif load.Name != \"__PAGEZERO\" {\n-\t\t\t\t\terrorf(\"segment with Addr=0, Filesz=0 is named %q, want %q\", load.Name, \"__PAGEZERO\")\n-\t\t\t\t} else if load.Addr != 0 || load.Filesz != 0 {\n-\t\t\t\t\terrorf(\"segment %q has Addr=%#x, Filesz=%d, want Addr=%#x, Filesz=%d\", load.Name, load.Addr, load.Filesz, 0, 0)\n-\t\t\t\t}\n-\t\t\t\tprog.UnmappedSize = Addr(load.Memsz)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\tif !strings.HasPrefix(load.Name, \"__\") {\n-\t\t\t\terrorf(\"segment name %q does not begin with %q\", load.Name, \"__\")\n-\t\t\t}\n-\t\t\tif strings.ToUpper(load.Name) != load.Name {\n-\t\t\t\terrorf(\"segment name %q is not all upper case\", load.Name)\n-\t\t\t}\n-\n-\t\t\tseg := &Segment{\n-\t\t\t\tName:       strings.ToLower(strings.TrimPrefix(load.Name, \"__\")),\n-\t\t\t\tVirtAddr:   Addr(load.Addr),\n-\t\t\t\tVirtSize:   Addr(load.Memsz),\n-\t\t\t\tFileOffset: Addr(load.Offset),\n-\t\t\t\tFileSize:   Addr(load.Filesz),\n-\t\t\t}\n-\t\t\tprog.Segments = append(prog.Segments, seg)\n-\n-\t\t\tdata, err := load.Data()\n-\t\t\tif err != nil {\n-\t\t\t\terrorf(\"loading data from %q: %v\", load.Name, err)\n-\t\t\t}\n-\t\t\tseg.Data = data\n-\n-\t\t\tvar maxprot, prot uint32\n-\t\t\tif load.Name == \"__TEXT\" {\n-\t\t\t\tmaxprot, prot = 7, 5\n-\t\t\t} else {\n-\t\t\t\tmaxprot, prot = 3, 3\n-\t\t\t}\n-\t\t\tif load.Maxprot != maxprot || load.Prot != prot {\n-\t\t\t\terrorf(\"segment %q protection is %d, %d, want %d, %d\",\n-\t\t\t\t\tload.Name, load.Maxprot, load.Prot, maxprot, prot)\n-\t\t\t}\n-\n-\t\t\tfor len(msects) > 0 && msects[0].Addr < load.Addr+load.Memsz {\n-\t\t\t\tmsect := msects[0]\n-\t\t\t\tmsects = msects[1:]\n-\n-\t\t\t\tif msect.Offset > 0 && prog.HeaderSize == 0 {\n-\t\t\t\t\tprog.HeaderSize = Addr(msect.Offset)\n-\t\t\t\t\tif seg.FileOffset != 0 {\n-\t\t\t\t\t\terrorf(\"initial segment %q does not map header\", load.Name)\n-\t\t\t\t\t}\n-\t\t\t\t\tseg.VirtAddr += prog.HeaderSize\n-\t\t\t\t\tseg.VirtSize -= prog.HeaderSize\n-\t\t\t\t\tseg.FileOffset += prog.HeaderSize\n-\t\t\t\t\tseg.FileSize -= prog.HeaderSize\n-\t\t\t\t\tseg.Data = seg.Data[prog.HeaderSize:]\n-\t\t\t\t}\n-\n-\t\t\t\tif msect.Addr < load.Addr {\n-\t\t\t\t\terrorf(\"section %q at address %#x is missing segment\", msect.Name, msect.Addr)\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\n-\t\t\t\tif !strings.HasPrefix(msect.Name, \"__\") {\n-\t\t\t\t\terrorf(\"section name %q does not begin with %q\", msect.Name, \"__\")\n-\t\t\t\t}\n-\t\t\t\tif strings.ToLower(msect.Name) != msect.Name {\n-\t\t\t\t\terrorf(\"section name %q is not all lower case\", msect.Name)\n-\t\t\t\t}\n-\t\t\t\tif msect.Seg != load.Name {\n-\t\t\t\t\terrorf(\"section %q is lists segment name %q, want %q\",\n-\t\t\t\t\t\tmsect.Name, msect.Seg, load.Name)\n-\t\t\t\t}\n-\t\t\t\tif uint64(msect.Offset) != uint64(load.Offset)+msect.Addr-load.Addr {\n-\t\t\t\t\terrorf(\"section %q file offset is %#x, want %#x\",\n-\t\t\t\t\t\tmsect.Name, msect.Offset, load.Offset+msect.Addr-load.Addr)\n-\t\t\t\t}\n-\t\t\t\tif msect.Reloff != 0 || msect.Nreloc != 0 {\n-\t\t\t\t\terrorf(\"section %q has reloff %d,%d, want %d,%d\",\n-\t\t\t\t\t\tmsect.Name, msect.Reloff, msect.Nreloc, 0, 0)\n-\t\t\t\t}\n-\t\t\t\tflags := uint32(0)\n-\t\t\t\tif msect.Name == \"__text\" {\n-\t\t\t\t\tflags = 0x400\n-\t\t\t\t}\n-\t\t\t\tif msect.Offset == 0 {\n-\t\t\t\t\tflags = 1\n-\t\t\t\t}\n-\t\t\t\tif msect.Flags != flags {\n-\t\t\t\t\terrorf(\"section %q flags = %#x, want %#x\", msect.Name, msect.Flags, flags)\n-\t\t\t\t}\n-\t\t\t\tsect := &Section{\n-\t\t\t\t\tName:     strings.ToLower(strings.TrimPrefix(msect.Name, \"__\")),\n-\t\t\t\t\tVirtAddr: Addr(msect.Addr),\n-\t\t\t\t\tSize:     Addr(msect.Size),\n-\t\t\t\t\tAlign:    1 << msect.Align,\n-\t\t\t\t}\n-\t\t\t\tseg.Sections = append(seg.Sections, sect)\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tfor _, msect := range msects {\n-\t\terrorf(\"section %q has no segment\", msect.Name)\n-\t}\n-\n-\tlimit = 0\n-\tfor _, msect := range f.Sections {\n-\t\tif msect.Addr < limit {\n-\t\t\terrorf(\"sections out of order: %q at %#x after %#x\", msect.Name, msect.Addr, limit)\n-\t\t}\n-\t\tlimit = msect.Addr + msect.Size\n-\t}\n-\n-\terr = nil\n-\tif errors != nil {\n-\t\terr = fmt.Errorf(\"%s\", strings.Join(errors, \"\\n\\t\"))\n-\t}\n-\treturn prog, err\n-}"},{"sha":"b23f3f87b0d91af64a1e5af067ca303c63c354ca","filename":"src/cmd/newlink/main.go","status":"removed","additions":0,"deletions":9,"changes":9,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/main.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/main.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/main.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,9 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Placeholder to keep build building.\n-\n-package main\n-\n-func main() {}"},{"sha":"0a4cfc9c46f2d77eeb68d2e9d401058e4cd38e5a","filename":"src/cmd/newlink/pclntab.go","status":"removed","additions":0,"deletions":480,"changes":480,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/pclntab.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/pclntab.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/pclntab.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,480 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Generation of runtime function information (pclntab).\n-\n-package main\n-\n-import (\n-\t\"cmd/internal/goobj\"\n-\t\"cmd/internal/obj\"\n-\t\"encoding/binary\"\n-\t\"os\"\n-\t\"sort\"\n-)\n-\n-var zerofunc goobj.Func\n-\n-// pclntab collects the runtime function data for each function that will\n-// be listed in the binary and builds a single table describing all functions.\n-// This table is used at run time for stack traces and to look up PC-specific\n-// information during garbage collection. The symbol created is named\n-// \"pclntab\" for historical reasons; the scope of the table has grown to\n-// include more than just PC/line number correspondences.\n-// The table format is documented at https://golang.org/s/go12symtab.\n-func (p *Prog) pclntab() {\n-\t// Count number of functions going into the binary,\n-\t// so that we can size the initial index correctly.\n-\tnfunc := 0\n-\tfor _, sym := range p.SymOrder {\n-\t\tif sym.Kind != goobj.STEXT {\n-\t\t\tcontinue\n-\t\t}\n-\t\tnfunc++\n-\t}\n-\n-\t// Table header.\n-\tbuf := new(SymBuffer)\n-\tbuf.Init(p)\n-\tbuf.SetSize(8 + p.ptrsize)\n-\toff := 0\n-\toff = buf.Uint32(off, 0xfffffffb)\n-\toff = buf.Uint8(off, 0)\n-\toff = buf.Uint8(off, 0)\n-\toff = buf.Uint8(off, uint8(p.pcquantum))\n-\toff = buf.Uint8(off, uint8(p.ptrsize))\n-\toff = buf.Uint(off, uint64(nfunc), p.ptrsize)\n-\tindexOff := off\n-\toff += (nfunc*2 + 1) * p.ptrsize // function index, to be filled in\n-\toff += 4                         // file table start offset, to be filled in\n-\tbuf.SetSize(off)\n-\n-\t// One-file cache for reading PCData tables from package files.\n-\t// TODO(rsc): Better I/O strategy.\n-\tvar (\n-\t\tfile  *os.File\n-\t\tfname string\n-\t)\n-\n-\t// Files gives the file numbering for source file names recorded\n-\t// in the binary.\n-\tfiles := make(map[string]int)\n-\n-\t// Build the table, build the index, and build the file name numbering.\n-\t// The loop here must visit functions in the same order that they will\n-\t// be stored in the binary, or else binary search over the index will fail.\n-\t// The runtime checks that the index is sorted properly at program start time.\n-\tvar lastSym *Sym\n-\tfor _, sym := range p.SymOrder {\n-\t\tif sym.Kind != goobj.STEXT {\n-\t\t\tcontinue\n-\t\t}\n-\t\tlastSym = sym\n-\n-\t\t// Treat no recorded function information same as all zeros.\n-\t\tf := sym.Func\n-\t\tif f == nil {\n-\t\t\tf = &zerofunc\n-\t\t}\n-\n-\t\t// Open package file if needed, for reading PC data.\n-\t\tif fname != sym.Package.File {\n-\t\t\tif file != nil {\n-\t\t\t\tfile.Close()\n-\t\t\t}\n-\t\t\tvar err error\n-\t\t\tfile, err = os.Open(sym.Package.File)\n-\t\t\tif err != nil {\n-\t\t\t\tp.errorf(\"%v: %v\", sym, err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tfname = sym.Package.File\n-\t\t}\n-\n-\t\t// off is the offset of the table entry where we're going to write\n-\t\t// the encoded form of Func.\n-\t\t// indexOff is the current position in the table index;\n-\t\t// we add an entry in the index pointing at off.\n-\t\toff = (buf.Size() + p.ptrsize - 1) &^ (p.ptrsize - 1)\n-\t\tindexOff = buf.Addr(indexOff, sym.SymID, 0)\n-\t\tindexOff = buf.Uint(indexOff, uint64(off), p.ptrsize)\n-\n-\t\t// The Func encoding starts with a header giving offsets\n-\t\t// to data blobs, and then the data blobs themselves.\n-\t\t// end gives the current write position for the data blobs.\n-\t\tend := off + p.ptrsize + 3*4 + 5*4 + len(f.PCData)*4 + len(f.FuncData)*p.ptrsize\n-\t\tif len(f.FuncData) > 0 {\n-\t\t\tend += -end & (p.ptrsize - 1)\n-\t\t}\n-\t\tbuf.SetSize(end)\n-\n-\t\t// entry uintptr\n-\t\t// name int32\n-\t\t// args int32\n-\t\t// frame int32\n-\t\t//\n-\t\t// The frame recorded in the object file is\n-\t\t// the frame size used in an assembly listing, which does\n-\t\t// not include the caller PC on the stack.\n-\t\t// The frame size we want to list here is the delta from\n-\t\t// this function's SP to its caller's SP, which does include\n-\t\t// the caller PC. Add p.ptrsize to f.Frame to adjust.\n-\t\t// TODO(rsc): Record the same frame size in the object file.\n-\t\toff = buf.Addr(off, sym.SymID, 0)\n-\t\toff = buf.Uint32(off, uint32(addString(buf, sym.Name)))\n-\t\toff = buf.Uint32(off, uint32(f.Args))\n-\t\toff = buf.Uint32(off, uint32(f.Frame+p.ptrsize))\n-\n-\t\t// pcdata\n-\t\toff = buf.Uint32(off, uint32(addPCTable(p, buf, file, f.PCSP)))\n-\t\toff = buf.Uint32(off, uint32(addPCFileTable(p, buf, file, f.PCFile, sym, files)))\n-\t\toff = buf.Uint32(off, uint32(addPCTable(p, buf, file, f.PCLine)))\n-\t\toff = buf.Uint32(off, uint32(len(f.PCData)))\n-\t\toff = buf.Uint32(off, uint32(len(f.FuncData)))\n-\t\tfor _, pcdata := range f.PCData {\n-\t\t\toff = buf.Uint32(off, uint32(addPCTable(p, buf, file, pcdata)))\n-\t\t}\n-\n-\t\t// funcdata\n-\t\tif len(f.FuncData) > 0 {\n-\t\t\toff += -off & (p.ptrsize - 1) // must be pointer-aligned\n-\t\t\tfor _, funcdata := range f.FuncData {\n-\t\t\t\tif funcdata.Sym.Name == \"\" {\n-\t\t\t\t\toff = buf.Uint(off, uint64(funcdata.Offset), p.ptrsize)\n-\t\t\t\t} else {\n-\t\t\t\t\toff = buf.Addr(off, funcdata.Sym, funcdata.Offset)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif off != end {\n-\t\t\tp.errorf(\"internal error: invalid math in pclntab: off=%#x end=%#x\", off, end)\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tif file != nil {\n-\t\tfile.Close()\n-\t}\n-\n-\t// Final entry of index is end PC of last function.\n-\tindexOff = buf.Addr(indexOff, lastSym.SymID, int64(lastSym.Size))\n-\n-\t// Start file table.\n-\t// Function index is immediately followed by offset to file table.\n-\toff = (buf.Size() + p.ptrsize - 1) &^ (p.ptrsize - 1)\n-\tbuf.Uint32(indexOff, uint32(off))\n-\n-\t// File table is an array of uint32s.\n-\t// The first entry gives 1+n, the size of the array.\n-\t// The following n entries hold offsets to string data.\n-\t// File number n uses the string pointed at by entry n.\n-\t// File number 0 is invalid.\n-\tbuf.SetSize(off + (1+len(files))*4)\n-\tbuf.Uint32(off, uint32(1+len(files)))\n-\tvar filestr []string\n-\tfor file := range files {\n-\t\tfilestr = append(filestr, file)\n-\t}\n-\tsort.Strings(filestr)\n-\tfor _, file := range filestr {\n-\t\tid := files[file]\n-\t\tbuf.Uint32(off+4*id, uint32(addString(buf, file)))\n-\t}\n-\n-\tpclntab := &Sym{\n-\t\tSym: &goobj.Sym{\n-\t\t\tSymID: goobj.SymID{Name: \"runtime.pclntab\"},\n-\t\t\tKind:  goobj.SPCLNTAB,\n-\t\t\tSize:  buf.Size(),\n-\t\t\tReloc: buf.Reloc(),\n-\t\t},\n-\t\tBytes: buf.Bytes(),\n-\t}\n-\tp.addSym(pclntab)\n-}\n-\n-// addString appends the string s to the buffer b.\n-// It returns the offset of the beginning of the string in the buffer.\n-func addString(b *SymBuffer, s string) int {\n-\toff := b.Size()\n-\tb.SetSize(off + len(s) + 1)\n-\tcopy(b.data[off:], s)\n-\treturn off\n-}\n-\n-// addPCTable appends the PC-data table stored in the file f at the location loc\n-// to the symbol buffer b. It returns the offset of the beginning of the table\n-// in the buffer.\n-func addPCTable(p *Prog, b *SymBuffer, f *os.File, loc goobj.Data) int {\n-\tif loc.Size == 0 {\n-\t\treturn 0\n-\t}\n-\toff := b.Size()\n-\tb.SetSize(off + int(loc.Size))\n-\t_, err := f.ReadAt(b.data[off:off+int(loc.Size)], loc.Offset)\n-\tif err != nil {\n-\t\tp.errorf(\"%v\", err)\n-\t}\n-\treturn off\n-}\n-\n-// addPCFileTable is like addPCTable, but it renumbers the file names referred to by the table\n-// to use the global numbering maintained in the files map. It adds new files to the\n-// map as necessary.\n-func addPCFileTable(p *Prog, b *SymBuffer, f *os.File, loc goobj.Data, sym *Sym, files map[string]int) int {\n-\tif loc.Size == 0 {\n-\t\treturn 0\n-\t}\n-\toff := b.Size()\n-\n-\tsrc := make([]byte, loc.Size)\n-\t_, err := f.ReadAt(src, loc.Offset)\n-\tif err != nil {\n-\t\tp.errorf(\"%v\", err)\n-\t\treturn 0\n-\t}\n-\n-\tfilenum := make([]int, len(sym.Func.File))\n-\tfor i, name := range sym.Func.File {\n-\t\tnum := files[name]\n-\t\tif num == 0 {\n-\t\t\tnum = len(files) + 1\n-\t\t\tfiles[name] = num\n-\t\t}\n-\t\tfilenum[i] = num\n-\t}\n-\n-\tvar dst []byte\n-\tnewval := int32(-1)\n-\tvar it PCIter\n-\tfor it.Init(p, src); !it.Done; it.Next() {\n-\t\t// value delta\n-\t\toldval := it.Value\n-\t\tval := oldval\n-\t\tif oldval != -1 {\n-\t\t\tif oldval < 0 || int(oldval) >= len(filenum) {\n-\t\t\t\tp.errorf(\"%s: corrupt pc-file table\", sym)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tval = int32(filenum[oldval])\n-\t\t}\n-\t\tdv := val - newval\n-\t\tnewval = val\n-\t\tuv := uint32(dv<<1) ^ uint32(dv>>31)\n-\t\tdst = appendVarint(dst, uv)\n-\n-\t\t// pc delta\n-\t\tdst = appendVarint(dst, it.NextPC-it.PC)\n-\t}\n-\tif it.Corrupt {\n-\t\tp.errorf(\"%s: corrupt pc-file table\", sym)\n-\t}\n-\n-\t// terminating value delta\n-\tdst = appendVarint(dst, 0)\n-\n-\tb.SetSize(off + len(dst))\n-\tcopy(b.data[off:], dst)\n-\treturn off\n-}\n-\n-// A SymBuffer is a buffer for preparing the data image of a\n-// linker-generated symbol.\n-type SymBuffer struct {\n-\tdata    []byte\n-\treloc   []goobj.Reloc\n-\torder   binary.ByteOrder\n-\tptrsize int\n-}\n-\n-// Init initializes the buffer for writing.\n-func (b *SymBuffer) Init(p *Prog) {\n-\tb.data = nil\n-\tb.reloc = nil\n-\tb.order = p.byteorder\n-\tb.ptrsize = p.ptrsize\n-}\n-\n-// Bytes returns the buffer data.\n-func (b *SymBuffer) Bytes() []byte {\n-\treturn b.data\n-}\n-\n-// SetSize sets the buffer's data size to n bytes.\n-func (b *SymBuffer) SetSize(n int) {\n-\tfor cap(b.data) < n {\n-\t\tb.data = append(b.data[:cap(b.data)], 0)\n-\t}\n-\tb.data = b.data[:n]\n-}\n-\n-// Size returns the buffer's data size.\n-func (b *SymBuffer) Size() int {\n-\treturn len(b.data)\n-}\n-\n-// Reloc returns the buffered relocations.\n-func (b *SymBuffer) Reloc() []goobj.Reloc {\n-\treturn b.reloc\n-}\n-\n-// Uint8 sets the uint8 at offset off to v.\n-// It returns the offset just beyond v.\n-func (b *SymBuffer) Uint8(off int, v uint8) int {\n-\tb.data[off] = v\n-\treturn off + 1\n-}\n-\n-// Uint16 sets the uint16 at offset off to v.\n-// It returns the offset just beyond v.\n-func (b *SymBuffer) Uint16(off int, v uint16) int {\n-\tb.order.PutUint16(b.data[off:], v)\n-\treturn off + 2\n-}\n-\n-// Uint32 sets the uint32 at offset off to v.\n-// It returns the offset just beyond v.\n-func (b *SymBuffer) Uint32(off int, v uint32) int {\n-\tb.order.PutUint32(b.data[off:], v)\n-\treturn off + 4\n-}\n-\n-// Uint64 sets the uint64 at offset off to v.\n-// It returns the offset just beyond v.\n-func (b *SymBuffer) Uint64(off int, v uint64) int {\n-\tb.order.PutUint64(b.data[off:], v)\n-\treturn off + 8\n-}\n-\n-// Uint sets the size-byte unsigned integer at offset off to v.\n-// It returns the offset just beyond v.\n-func (b *SymBuffer) Uint(off int, v uint64, size int) int {\n-\tswitch size {\n-\tcase 1:\n-\t\treturn b.Uint8(off, uint8(v))\n-\tcase 2:\n-\t\treturn b.Uint16(off, uint16(v))\n-\tcase 4:\n-\t\treturn b.Uint32(off, uint32(v))\n-\tcase 8:\n-\t\treturn b.Uint64(off, v)\n-\t}\n-\tpanic(\"invalid use of SymBuffer.SetUint\")\n-}\n-\n-// Addr sets the pointer-sized address at offset off to refer\n-// to symoff bytes past the start of sym. It returns the offset\n-// just beyond the address.\n-func (b *SymBuffer) Addr(off int, sym goobj.SymID, symoff int64) int {\n-\tb.reloc = append(b.reloc, goobj.Reloc{\n-\t\tOffset: off,\n-\t\tSize:   b.ptrsize,\n-\t\tSym:    sym,\n-\t\tAdd:    int(symoff),\n-\t\tType:   obj.R_ADDR,\n-\t})\n-\treturn off + b.ptrsize\n-}\n-\n-// A PCIter implements iteration over PC-data tables.\n-//\n-//\tvar it PCIter\n-//\tfor it.Init(p, data); !it.Done; it.Next() {\n-//\t\tit.Value holds from it.PC up to (but not including) it.NextPC\n-//\t}\n-//\tif it.Corrupt {\n-//\t\tdata was malformed\n-//\t}\n-//\n-type PCIter struct {\n-\tPC        uint32\n-\tNextPC    uint32\n-\tValue     int32\n-\tDone      bool\n-\tCorrupt   bool\n-\tp         []byte\n-\tstart     bool\n-\tpcquantum uint32\n-}\n-\n-// Init initializes the iteration.\n-// On return, if it.Done is true, the iteration is over.\n-// Otherwise it.Value applies in the pc range [it.PC, it.NextPC).\n-func (it *PCIter) Init(p *Prog, buf []byte) {\n-\tit.p = buf\n-\tit.PC = 0\n-\tit.NextPC = 0\n-\tit.Value = -1\n-\tit.start = true\n-\tit.pcquantum = uint32(p.pcquantum)\n-\tit.Done = false\n-\tit.Next()\n-}\n-\n-// Next steps forward one entry in the table.\n-// On return, if it.Done is true, the iteration is over.\n-// Otherwise it.Value applies in the pc range [it.PC, it.NextPC).\n-func (it *PCIter) Next() {\n-\tit.PC = it.NextPC\n-\tif it.Done {\n-\t\treturn\n-\t}\n-\tif len(it.p) == 0 {\n-\t\tit.Done = true\n-\t\treturn\n-\t}\n-\n-\t// value delta\n-\tuv, p, ok := decodeVarint(it.p)\n-\tif !ok {\n-\t\tit.Done = true\n-\t\tit.Corrupt = true\n-\t\treturn\n-\t}\n-\tit.p = p\n-\tif uv == 0 && !it.start {\n-\t\tit.Done = true\n-\t\treturn\n-\t}\n-\tit.start = false\n-\tsv := int32(uv>>1) ^ int32(uv<<31)>>31\n-\tit.Value += sv\n-\n-\t// pc delta\n-\tuv, it.p, ok = decodeVarint(it.p)\n-\tif !ok {\n-\t\tit.Done = true\n-\t\tit.Corrupt = true\n-\t\treturn\n-\t}\n-\tit.NextPC = it.PC + uv*it.pcquantum\n-}\n-\n-// decodeVarint decodes an unsigned varint from p,\n-// reporting the value, the remainder of the data, and\n-// whether the decoding was successful.\n-func decodeVarint(p []byte) (v uint32, rest []byte, ok bool) {\n-\tfor shift := uint(0); ; shift += 7 {\n-\t\tif len(p) == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tc := uint32(p[0])\n-\t\tp = p[1:]\n-\t\tv |= (c & 0x7F) << shift\n-\t\tif c&0x80 == 0 {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\treturn v, p, true\n-}\n-\n-// appendVarint appends an unsigned varint encoding of v to p\n-// and returns the resulting slice.\n-func appendVarint(p []byte, v uint32) []byte {\n-\tfor ; v >= 0x80; v >>= 7 {\n-\t\tp = append(p, byte(v)|0x80)\n-\t}\n-\tp = append(p, byte(v))\n-\treturn p\n-}"},{"sha":"ea808067427e0b98e65b97d354d5768c8e170d77","filename":"src/cmd/newlink/pclntab_test.go","status":"removed","additions":0,"deletions":340,"changes":340,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/pclntab_test.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/pclntab_test.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/pclntab_test.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,340 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"cmd/internal/goobj\"\n-\t\"fmt\"\n-\t\"math/rand\"\n-\t\"sort\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-// Test of pcln table encoding.\n-// testdata/genpcln.go generates an assembly file with\n-// pseudorandom values for the data that pclntab stores.\n-// This test recomputes the same pseudorandom stream\n-// and checks that the final linked binary uses those values\n-// as well.\n-func TestPclntab(t *testing.T) {\n-\tp := &Prog{\n-\t\tGOOS:        \"darwin\",\n-\t\tGOARCH:      \"amd64\",\n-\t\tError:       func(s string) { t.Error(s) },\n-\t\tStartSym:    \"start\",\n-\t\tomitRuntime: true,\n-\t}\n-\tvar buf bytes.Buffer\n-\tp.link(&buf, \"testdata/pclntab.6\")\n-\tif p.NumError > 0 {\n-\t\treturn\n-\t}\n-\n-\t// The algorithm for computing values here must match\n-\t// the one in testdata/genpcln.go.\n-\tfor f := 0; f < 3; f++ {\n-\t\tfile := \"input\"\n-\t\tline := 1\n-\t\trnd := rand.New(rand.NewSource(int64(f)))\n-\t\targs := rnd.Intn(100) * 8\n-\t\tframe := 32 + rnd.Intn(32)/8*8\n-\t\tsize := 200 + rnd.Intn(100)*8\n-\n-\t\tname := fmt.Sprintf(\"func%d\", f)\n-\t\tr, off, fargs, fframe, ok := findFunc(t, p, name)\n-\t\tif !ok {\n-\t\t\tcontinue // error already printed\n-\t\t}\n-\t\tif fargs != args {\n-\t\t\tt.Errorf(\"%s: args=%d, want %d\", name, fargs, args)\n-\t\t}\n-\t\tif fframe != frame+8 {\n-\t\t\tt.Errorf(\"%s: frame=%d, want %d\", name, fframe, frame+8)\n-\t\t}\n-\n-\t\t// Check FUNCDATA 1.\n-\t\tfdata, ok := loadFuncdata(t, r, name, off, 1)\n-\t\tif ok {\n-\t\t\tfsym := p.Syms[goobj.SymID{Name: fmt.Sprintf(\"funcdata%d\", f)}]\n-\t\t\tif fsym == nil {\n-\t\t\t\tt.Errorf(\"funcdata%d is missing in binary\", f)\n-\t\t\t} else if fdata != fsym.Addr {\n-\t\t\t\tt.Errorf(\"%s: funcdata 1 = %#x, want %#x\", name, fdata, fsym.Addr)\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Walk code checking pcdata values.\n-\t\tspadj := 0\n-\t\tpcdata1 := -1\n-\t\tpcdata2 := -1\n-\n-\t\tcheckPCSP(t, r, name, off, 0, 0)\n-\t\tcheckPCData(t, r, name, off, 0, 0, -1)\n-\t\tcheckPCData(t, r, name, off, 0, 1, -1)\n-\t\tcheckPCData(t, r, name, off, 0, 2, -1)\n-\n-\t\tfirstpc := 4\n-\t\tfor i := 0; i < size; i++ {\n-\t\t\tpc := firstpc + i // skip SP adjustment to allocate frame\n-\t\t\tif i >= 0x100 && t.Failed() {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\t// Possible SP adjustment.\n-\t\t\tcheckPCSP(t, r, name, off, pc, frame+spadj)\n-\t\t\tif rnd.Intn(100) == 0 {\n-\t\t\t\tcheckPCFileLine(t, r, name, off, pc, file, line)\n-\t\t\t\tcheckPCData(t, r, name, off, pc, 1, pcdata1)\n-\t\t\t\tcheckPCData(t, r, name, off, pc, 2, pcdata2)\n-\t\t\t\ti += 1\n-\t\t\t\tpc = firstpc + i\n-\t\t\t\tcheckPCFileLine(t, r, name, off, pc-1, file, line)\n-\t\t\t\tcheckPCData(t, r, name, off, pc-1, 1, pcdata1)\n-\t\t\t\tcheckPCData(t, r, name, off, pc-1, 2, pcdata2)\n-\t\t\t\tcheckPCSP(t, r, name, off, pc-1, frame+spadj)\n-\n-\t\t\t\tif spadj <= -32 || spadj < 32 && rnd.Intn(2) == 0 {\n-\t\t\t\t\tspadj += 8\n-\t\t\t\t} else {\n-\t\t\t\t\tspadj -= 8\n-\t\t\t\t}\n-\t\t\t\tcheckPCSP(t, r, name, off, pc, frame+spadj)\n-\t\t\t}\n-\n-\t\t\t// Possible PCFile change.\n-\t\t\tif rnd.Intn(100) == 0 {\n-\t\t\t\tfile = fmt.Sprintf(\"file%d.s\", rnd.Intn(10))\n-\t\t\t\tline = rnd.Intn(100) + 1\n-\t\t\t}\n-\n-\t\t\t// Possible PCLine change.\n-\t\t\tif rnd.Intn(10) == 0 {\n-\t\t\t\tline = rnd.Intn(1000) + 1\n-\t\t\t}\n-\n-\t\t\t// Possible PCData $1 change.\n-\t\t\tif rnd.Intn(100) == 0 {\n-\t\t\t\tpcdata1 = rnd.Intn(1000)\n-\t\t\t}\n-\n-\t\t\t// Possible PCData $2 change.\n-\t\t\tif rnd.Intn(100) == 0 {\n-\t\t\t\tpcdata2 = rnd.Intn(1000)\n-\t\t\t}\n-\n-\t\t\tif i == 0 {\n-\t\t\t\tcheckPCFileLine(t, r, name, off, 0, file, line)\n-\t\t\t\tcheckPCFileLine(t, r, name, off, pc-1, file, line)\n-\t\t\t}\n-\t\t\tcheckPCFileLine(t, r, name, off, pc, file, line)\n-\t\t\tcheckPCData(t, r, name, off, pc, 1, pcdata1)\n-\t\t\tcheckPCData(t, r, name, off, pc, 2, pcdata2)\n-\t\t}\n-\t}\n-}\n-\n-// findFunc finds the function information in the pclntab of p\n-// for the function with the given name.\n-// It returns a symbol reader for pclntab, the offset of the function information\n-// within that symbol, and the args and frame values read out of the information.\n-func findFunc(t *testing.T, p *Prog, name string) (r *SymReader, off, args, frame int, ok bool) {\n-\ttabsym := p.Syms[goobj.SymID{Name: \"runtime.pclntab\"}]\n-\tif tabsym == nil {\n-\t\tt.Errorf(\"pclntab is missing in binary\")\n-\t\treturn\n-\t}\n-\n-\tr = new(SymReader)\n-\tr.Init(p, tabsym)\n-\n-\t// pclntab must with 8-byte header\n-\tif r.Uint32(0) != 0xfffffffb || r.Uint8(4) != 0 || r.Uint8(5) != 0 || r.Uint8(6) != uint8(p.pcquantum) || r.Uint8(7) != uint8(p.ptrsize) {\n-\t\tt.Errorf(\"pclntab has incorrect header %.8x\", r.data[:8])\n-\t\treturn\n-\t}\n-\n-\tsym := p.Syms[goobj.SymID{Name: name}]\n-\tif sym == nil {\n-\t\tt.Errorf(\"%s is missing in the binary\", name)\n-\t\treturn\n-\t}\n-\n-\t// index is nfunc addr0 off0 addr1 off1 ... addr_nfunc (sentinel)\n-\tnfunc := int(r.Addr(8))\n-\ti := sort.Search(nfunc, func(i int) bool {\n-\t\treturn r.Addr(8+p.ptrsize*(1+2*i)) >= sym.Addr\n-\t})\n-\tif entry := r.Addr(8 + p.ptrsize*(1+2*i)); entry != sym.Addr {\n-\t\tindexTab := make([]Addr, 2*nfunc+1)\n-\t\tfor j := range indexTab {\n-\t\t\tindexTab[j] = r.Addr(8 + p.ptrsize*(1+j))\n-\t\t}\n-\t\tt.Errorf(\"pclntab is missing entry for %s (%#x): %#x\", name, sym.Addr, indexTab)\n-\t\treturn\n-\t}\n-\n-\toff = int(r.Addr(8 + p.ptrsize*(1+2*i+1)))\n-\n-\t// func description at off is\n-\t//\tentry addr\n-\t//\tnameoff uint32\n-\t//\targs uint32\n-\t//\tframe uint32\n-\t//\tpcspoff uint32\n-\t//\tpcfileoff uint32\n-\t//\tpclineoff uint32\n-\t//\tnpcdata uint32\n-\t//\tnfuncdata uint32\n-\t//\tpcdata npcdata*uint32\n-\t//\tfuncdata nfuncdata*addr\n-\t//\n-\tif entry := r.Addr(off); entry != sym.Addr {\n-\t\tt.Errorf(\"pclntab inconsistent: entry for %s addr=%#x has entry=%#x\", name, sym.Addr, entry)\n-\t\treturn\n-\t}\n-\tnameoff := int(r.Uint32(off + p.ptrsize))\n-\targs = int(r.Uint32(off + p.ptrsize + 1*4))\n-\tframe = int(r.Uint32(off + p.ptrsize + 2*4))\n-\n-\tfname := r.String(nameoff)\n-\tif fname != name {\n-\t\tt.Errorf(\"pclntab inconsistent: entry for %s addr=%#x has name %q\", name, sym.Addr, fname)\n-\t}\n-\n-\tok = true // off, args, frame are usable\n-\treturn\n-}\n-\n-// loadFuncdata returns the funcdata #fnum value\n-// loaded from the function information for name.\n-func loadFuncdata(t *testing.T, r *SymReader, name string, off int, fnum int) (Addr, bool) {\n-\tnpcdata := int(r.Uint32(off + r.p.ptrsize + 6*4))\n-\tnfuncdata := int(r.Uint32(off + r.p.ptrsize + 7*4))\n-\tif fnum >= nfuncdata {\n-\t\tt.Errorf(\"pclntab(%s): no funcdata %d (only < %d)\", name, fnum, nfuncdata)\n-\t\treturn 0, false\n-\t}\n-\tfdataoff := off + r.p.ptrsize + (8+npcdata)*4 + fnum*r.p.ptrsize\n-\tfdataoff += fdataoff & 4\n-\treturn r.Addr(fdataoff), true\n-}\n-\n-// checkPCSP checks that the PCSP table in the function information at off\n-// lists spadj as the sp delta for pc.\n-func checkPCSP(t *testing.T, r *SymReader, name string, off, pc, spadj int) {\n-\tpcoff := r.Uint32(off + r.p.ptrsize + 3*4)\n-\tpcval, ok := readPCData(t, r, name, \"PCSP\", pcoff, pc)\n-\tif !ok {\n-\t\treturn\n-\t}\n-\tif pcval != spadj {\n-\t\tt.Errorf(\"pclntab(%s): at pc=+%#x, pcsp=%d, want %d\", name, pc, pcval, spadj)\n-\t}\n-}\n-\n-// checkPCSP checks that the PCFile and PCLine tables in the function information at off\n-// list file, line as the file name and line number for pc.\n-func checkPCFileLine(t *testing.T, r *SymReader, name string, off, pc int, file string, line int) {\n-\tpcfileoff := r.Uint32(off + r.p.ptrsize + 4*4)\n-\tpclineoff := r.Uint32(off + r.p.ptrsize + 5*4)\n-\tpcfilenum, ok1 := readPCData(t, r, name, \"PCFile\", pcfileoff, pc)\n-\tpcline, ok2 := readPCData(t, r, name, \"PCLine\", pclineoff, pc)\n-\tif !ok1 || !ok2 {\n-\t\treturn\n-\t}\n-\tnfunc := int(r.Addr(8))\n-\tfiletaboff := r.Uint32(8 + r.p.ptrsize*2*(nfunc+1))\n-\tnfile := int(r.Uint32(int(filetaboff)))\n-\tif pcfilenum <= 0 || pcfilenum >= nfile {\n-\t\tt.Errorf(\"pclntab(%s): at pc=+%#x, filenum=%d (invalid; nfile=%d)\", name, pc, pcfilenum, nfile)\n-\t}\n-\tpcfile := r.String(int(r.Uint32(int(filetaboff) + pcfilenum*4)))\n-\tif !strings.HasSuffix(pcfile, file) {\n-\t\tt.Errorf(\"pclntab(%s): at pc=+%#x, file=%q, want %q\", name, pc, pcfile, file)\n-\t}\n-\tif pcline != line {\n-\t\tt.Errorf(\"pclntab(%s): at pc=+%#x, line=%d, want %d\", name, pc, pcline, line)\n-\t}\n-}\n-\n-// checkPCData checks that the PCData#pnum table in the function information at off\n-// list val as the value for pc.\n-func checkPCData(t *testing.T, r *SymReader, name string, off, pc, pnum, val int) {\n-\tpcoff := r.Uint32(off + r.p.ptrsize + (8+pnum)*4)\n-\tpcval, ok := readPCData(t, r, name, fmt.Sprintf(\"PCData#%d\", pnum), pcoff, pc)\n-\tif !ok {\n-\t\treturn\n-\t}\n-\tif pcval != val {\n-\t\tt.Errorf(\"pclntab(%s): at pc=+%#x, pcdata#%d=%d, want %d\", name, pc, pnum, pcval, val)\n-\t}\n-}\n-\n-// readPCData reads the PCData table offset off\n-// to obtain and return the value associated with pc.\n-func readPCData(t *testing.T, r *SymReader, name, pcdataname string, pcoff uint32, pc int) (int, bool) {\n-\t// \"If pcsp, pcfile, pcln, or any of the pcdata offsets is zero,\n-\t// that table is considered missing, and all PCs take value -1.\"\n-\tif pcoff == 0 {\n-\t\treturn -1, true\n-\t}\n-\n-\tvar it PCIter\n-\tfor it.Init(r.p, r.data[pcoff:]); !it.Done; it.Next() {\n-\t\tif it.PC <= uint32(pc) && uint32(pc) < it.NextPC {\n-\t\t\treturn int(it.Value), true\n-\t\t}\n-\t}\n-\tif it.Corrupt {\n-\t\tt.Errorf(\"pclntab(%s): %s: corrupt pcdata table\", name, pcdataname)\n-\t}\n-\treturn 0, false\n-}\n-\n-// A SymReader provides typed access to the data for a symbol.\n-type SymReader struct {\n-\tp    *Prog\n-\tdata []byte\n-}\n-\n-func (r *SymReader) Init(p *Prog, sym *Sym) {\n-\tseg := sym.Section.Segment\n-\toff := sym.Addr - seg.VirtAddr\n-\tdata := seg.Data[off : off+Addr(sym.Size)]\n-\tr.p = p\n-\tr.data = data\n-}\n-\n-func (r *SymReader) Uint8(off int) uint8 {\n-\treturn r.data[off]\n-}\n-\n-func (r *SymReader) Uint16(off int) uint16 {\n-\treturn r.p.byteorder.Uint16(r.data[off:])\n-}\n-\n-func (r *SymReader) Uint32(off int) uint32 {\n-\treturn r.p.byteorder.Uint32(r.data[off:])\n-}\n-\n-func (r *SymReader) Uint64(off int) uint64 {\n-\treturn r.p.byteorder.Uint64(r.data[off:])\n-}\n-\n-func (r *SymReader) Addr(off int) Addr {\n-\tif r.p.ptrsize == 4 {\n-\t\treturn Addr(r.Uint32(off))\n-\t}\n-\treturn Addr(r.Uint64(off))\n-}\n-\n-func (r *SymReader) String(off int) string {\n-\tend := off\n-\tfor r.data[end] != '\\x00' {\n-\t\tend++\n-\t}\n-\treturn string(r.data[off:end])\n-}"},{"sha":"77fb1ece5b1685c09358973870dadf7001830621","filename":"src/cmd/newlink/prog.go","status":"removed","additions":0,"deletions":220,"changes":220,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/prog.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/prog.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/prog.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,220 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"cmd/internal/goobj\"\n-\t\"encoding/binary\"\n-\t\"fmt\"\n-\t\"go/build\"\n-\t\"io\"\n-\t\"os\"\n-\t\"runtime\"\n-)\n-\n-// A Prog holds state for constructing an executable (program) image.\n-//\n-// The usual sequence of operations on a Prog is:\n-//\n-//\tp.init()\n-//\tp.scan(file)\n-//\tp.dead()\n-//\tp.runtime()\n-//\tp.layout()\n-//\tp.load()\n-//\tp.debug()\n-//\tp.write(w)\n-//\n-// p.init is in this file. The rest of the methods are in files\n-// named for the method. The convenience method p.link runs\n-// this sequence.\n-//\n-type Prog struct {\n-\t// Context\n-\tGOOS     string       // target operating system\n-\tGOARCH   string       // target architecture\n-\tFormat   string       // desired file format (\"elf\", \"macho\", ...)\n-\tError    func(string) // called to report an error (if set)\n-\tNumError int          // number of errors printed\n-\tStartSym string\n-\n-\t// Derived context\n-\tarch\n-\tformatter   formatter\n-\tstartSym    goobj.SymID\n-\tpkgdir      string\n-\tomitRuntime bool // do not load runtime package\n-\n-\t// Input\n-\tPackages   map[string]*Package  // loaded packages, by import path\n-\tSyms       map[goobj.SymID]*Sym // defined symbols, by symbol ID\n-\tMissing    map[goobj.SymID]bool // missing symbols\n-\tDead       map[goobj.SymID]bool // symbols removed as dead\n-\tSymOrder   []*Sym               // order syms were scanned\n-\tMaxVersion int                  // max SymID.Version, for generating fresh symbol IDs\n-\n-\t// Output\n-\tUnmappedSize Addr       // size of unmapped region at address 0\n-\tHeaderSize   Addr       // size of object file header\n-\tEntry        Addr       // virtual address where execution begins\n-\tSegments     []*Segment // loaded memory segments\n-}\n-\n-// An arch describes architecture-dependent settings.\n-type arch struct {\n-\tbyteorder binary.ByteOrder\n-\tptrsize   int\n-\tpcquantum int\n-}\n-\n-// A formatter takes care of the details of generating a particular\n-// kind of executable file.\n-type formatter interface {\n-\t// headerSize returns the footprint of the header for p\n-\t// in both virtual address space and file bytes.\n-\t// The footprint does not include any bytes stored at the\n-\t// end of the file.\n-\theaderSize(p *Prog) (virt, file Addr)\n-\n-\t// write writes the executable file for p to w.\n-\twrite(w io.Writer, p *Prog)\n-}\n-\n-// An Addr represents a virtual memory address, a file address, or a size.\n-// It must be a uint64, not a uintptr, so that a 32-bit linker can still generate a 64-bit binary.\n-// It must be unsigned in order to link programs placed at very large start addresses.\n-// Math involving Addrs must be checked carefully not to require negative numbers.\n-type Addr uint64\n-\n-// A Package is a Go package loaded from a file.\n-type Package struct {\n-\t*goobj.Package        // table of contents\n-\tFile           string // file name for reopening\n-\tSyms           []*Sym // symbols defined by this package\n-}\n-\n-// A Sym is a symbol defined in a loaded package.\n-type Sym struct {\n-\t*goobj.Sym          // symbol metadata from package file\n-\tPackage    *Package // package defining symbol\n-\tSection    *Section // section where symbol is placed in output program\n-\tAddr       Addr     // virtual address of symbol in output program\n-\tBytes      []byte   // symbol data, for internally defined symbols\n-}\n-\n-// A Segment is a loaded memory segment.\n-// A Prog is expected to have segments named \"text\" and optionally \"data\",\n-// in that order, before any other segments.\n-type Segment struct {\n-\tName       string     // name of segment: \"text\", \"data\", ...\n-\tVirtAddr   Addr       // virtual memory address of segment base\n-\tVirtSize   Addr       // size of segment in memory\n-\tFileOffset Addr       // file offset of segment base\n-\tFileSize   Addr       // size of segment in file; can be less than VirtSize\n-\tSections   []*Section // sections inside segment\n-\tData       []byte     // raw data of segment image\n-}\n-\n-// A Section is part of a loaded memory segment.\n-type Section struct {\n-\tName     string   // name of section: \"text\", \"rodata\", \"noptrbss\", and so on\n-\tVirtAddr Addr     // virtual memory address of section base\n-\tSize     Addr     // size of section in memory\n-\tAlign    Addr     // required alignment\n-\tInFile   bool     // section has image data in file (like data, unlike bss)\n-\tSyms     []*Sym   // symbols stored in section\n-\tSegment  *Segment // segment containing section\n-}\n-\n-func (p *Prog) errorf(format string, args ...interface{}) {\n-\tif p.Error != nil {\n-\t\tp.Error(fmt.Sprintf(format, args...))\n-\t} else {\n-\t\tfmt.Fprintf(os.Stderr, format+\"\\n\", args...)\n-\t}\n-\tp.NumError++\n-}\n-\n-// link is the one-stop convenience method for running a link.\n-// It writes to w the object file generated from using mainFile as the main package.\n-func (p *Prog) link(w io.Writer, mainFile string) {\n-\tp.init()\n-\tp.scan(mainFile)\n-\tif p.NumError > 0 {\n-\t\treturn\n-\t}\n-\tp.dead()\n-\tp.runtime()\n-\tp.autoData()\n-\tp.layout()\n-\tp.autoConst()\n-\tif p.NumError > 0 {\n-\t\treturn\n-\t}\n-\tp.load()\n-\tif p.NumError > 0 {\n-\t\treturn\n-\t}\n-\tp.debug()\n-\tif p.NumError > 0 {\n-\t\treturn\n-\t}\n-\tp.write(w)\n-}\n-\n-// init initializes p for use by the other methods.\n-func (p *Prog) init() {\n-\t// Set default context if not overridden.\n-\tif p.GOOS == \"\" {\n-\t\tp.GOOS = build.Default.GOOS\n-\t}\n-\tif p.GOARCH == \"\" {\n-\t\tp.GOARCH = build.Default.GOARCH\n-\t}\n-\tif p.Format == \"\" {\n-\t\tp.Format = goosFormat[p.GOOS]\n-\t\tif p.Format == \"\" {\n-\t\t\tp.errorf(\"no default file format for GOOS %q\", p.GOOS)\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tif p.StartSym == \"\" {\n-\t\tp.StartSym = fmt.Sprintf(\"_rt0_%s_%s\", p.GOARCH, p.GOOS)\n-\t}\n-\n-\t// Derive internal context.\n-\tp.formatter = formatters[p.Format]\n-\tif p.formatter == nil {\n-\t\tp.errorf(\"unknown output file format %q\", p.Format)\n-\t\treturn\n-\t}\n-\tp.startSym = goobj.SymID{Name: p.StartSym}\n-\tarch, ok := arches[p.GOARCH]\n-\tif !ok {\n-\t\tp.errorf(\"unknown GOOS %q\", p.GOOS)\n-\t\treturn\n-\t}\n-\tp.arch = arch\n-\n-\tp.pkgdir = fmt.Sprintf(\"%s/pkg/%s_%s\", runtime.GOROOT(), p.GOOS, p.GOARCH)\n-}\n-\n-// goosFormat records the default format for each known GOOS value.\n-var goosFormat = map[string]string{\n-\t\"darwin\": \"darwin\",\n-}\n-\n-// formatters records the format implementation for each known format value.\n-var formatters = map[string]formatter{\n-\t\"darwin\": machoFormat{},\n-}\n-\n-var arches = map[string]arch{\n-\t\"amd64\": {\n-\t\tbyteorder: binary.LittleEndian,\n-\t\tptrsize:   8,\n-\t\tpcquantum: 1,\n-\t},\n-}"},{"sha":"0853506957d9393b18d0409f8f04f00bbfeb5a5c","filename":"src/cmd/newlink/prog_test.go","status":"removed","additions":0,"deletions":163,"changes":163,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/prog_test.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/prog_test.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/prog_test.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,163 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"testing\"\n-)\n-\n-// shiftProg adjusts the addresses in p.\n-// It adds vdelta to all virtual addresses and fdelta to all file offsets.\n-func shiftProg(p *Prog, vdelta Addr, fdelta Addr) {\n-\tp.Entry += vdelta\n-\tfor _, seg := range p.Segments {\n-\t\tseg.FileOffset += fdelta\n-\t\tseg.VirtAddr += vdelta\n-\t\tfor _, sect := range seg.Sections {\n-\t\t\tsect.VirtAddr += vdelta\n-\t\t\tfor _, sym := range sect.Syms {\n-\t\t\t\tsym.Addr += vdelta\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// diffProg returns a list of differences between p and q,\n-// assuming p is being checked and q is the correct answer.\n-func diffProg(p, q *Prog) []string {\n-\tvar errors []string\n-\tif p.UnmappedSize != q.UnmappedSize {\n-\t\terrors = append(errors, fmt.Sprintf(\"p.UnmappedSize = %#x, want %#x\", p.UnmappedSize, q.UnmappedSize))\n-\t}\n-\tif p.HeaderSize != q.HeaderSize {\n-\t\terrors = append(errors, fmt.Sprintf(\"p.HeaderSize = %#x, want %#x\", p.HeaderSize, q.HeaderSize))\n-\t}\n-\tif p.Entry != q.Entry {\n-\t\terrors = append(errors, fmt.Sprintf(\"p.Entry = %#x, want %#x\", p.Entry, q.Entry))\n-\t}\n-\tfor i := 0; i < len(p.Segments) || i < len(q.Segments); i++ {\n-\t\tif i >= len(p.Segments) {\n-\t\t\terrors = append(errors, fmt.Sprintf(\"p missing segment %q\", q.Segments[i].Name))\n-\t\t\tcontinue\n-\t\t}\n-\t\tif i >= len(q.Segments) {\n-\t\t\terrors = append(errors, fmt.Sprintf(\"p has extra segment %q\", p.Segments[i].Name))\n-\t\t\tcontinue\n-\t\t}\n-\t\tpseg := p.Segments[i]\n-\t\tqseg := q.Segments[i]\n-\t\tif pseg.Name != qseg.Name {\n-\t\t\terrors = append(errors, fmt.Sprintf(\"segment %d Name = %q, want %q\", i, pseg.Name, qseg.Name))\n-\t\t\tcontinue // probably out of sync\n-\t\t}\n-\t\tif pseg.VirtAddr != qseg.VirtAddr {\n-\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q VirtAddr = %#x, want %#x\", pseg.Name, pseg.VirtAddr, qseg.VirtAddr))\n-\t\t}\n-\t\tif pseg.VirtSize != qseg.VirtSize {\n-\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q VirtSize = %#x, want %#x\", pseg.Name, pseg.VirtSize, qseg.VirtSize))\n-\t\t}\n-\t\tif pseg.FileOffset != qseg.FileOffset {\n-\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q FileOffset = %#x, want %#x\", pseg.Name, pseg.FileOffset, qseg.FileOffset))\n-\t\t}\n-\t\tif pseg.FileSize != qseg.FileSize {\n-\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q FileSize = %#x, want %#x\", pseg.Name, pseg.FileSize, qseg.FileSize))\n-\t\t}\n-\t\tif len(pseg.Data) != len(qseg.Data) {\n-\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q len(Data) = %d, want %d\", pseg.Name, len(pseg.Data), len(qseg.Data)))\n-\t\t} else if !bytes.Equal(pseg.Data, qseg.Data) {\n-\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q Data mismatch:\\n\\thave %x\\n\\twant %x\", pseg.Name, pseg.Data, qseg.Data))\n-\t\t}\n-\n-\t\tfor j := 0; j < len(pseg.Sections) || j < len(qseg.Sections); j++ {\n-\t\t\tif j >= len(pseg.Sections) {\n-\t\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q missing section %q\", pseg.Name, qseg.Sections[i].Name))\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif j >= len(qseg.Sections) {\n-\t\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q has extra section %q\", pseg.Name, pseg.Sections[i].Name))\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tpsect := pseg.Sections[j]\n-\t\t\tqsect := qseg.Sections[j]\n-\t\t\tif psect.Name != qsect.Name {\n-\t\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q, section %d Name = %q, want %q\", pseg.Name, j, psect.Name, qsect.Name))\n-\t\t\t\tcontinue // probably out of sync\n-\t\t\t}\n-\n-\t\t\tif psect.VirtAddr != qsect.VirtAddr {\n-\t\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q section %q VirtAddr = %#x, want %#x\", pseg.Name, psect.Name, psect.VirtAddr, qsect.VirtAddr))\n-\t\t\t}\n-\t\t\tif psect.Size != qsect.Size {\n-\t\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q section %q Size = %#x, want %#x\", pseg.Name, psect.Name, psect.Size, qsect.Size))\n-\t\t\t}\n-\t\t\tif psect.Align != qsect.Align {\n-\t\t\t\terrors = append(errors, fmt.Sprintf(\"segment %q section %q Align = %#x, want %#x\", pseg.Name, psect.Name, psect.Align, qsect.Align))\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn errors\n-}\n-\n-// cloneProg returns a deep copy of p.\n-func cloneProg(p *Prog) *Prog {\n-\tq := new(Prog)\n-\t*q = *p\n-\tq.Segments = make([]*Segment, len(p.Segments))\n-\tfor i, seg := range p.Segments {\n-\t\tq.Segments[i] = cloneSegment(seg)\n-\t}\n-\treturn q\n-}\n-\n-// cloneSegment returns a deep copy of seg.\n-func cloneSegment(seg *Segment) *Segment {\n-\tt := new(Segment)\n-\t*t = *seg\n-\tt.Sections = make([]*Section, len(seg.Sections))\n-\tfor i, sect := range seg.Sections {\n-\t\tt.Sections[i] = cloneSection(sect)\n-\t}\n-\tt.Data = make([]byte, len(seg.Data))\n-\tcopy(t.Data, seg.Data)\n-\treturn t\n-}\n-\n-// cloneSection returns a deep copy of section.\n-func cloneSection(sect *Section) *Section {\n-\t// At the moment, there's nothing we need to make a deep copy of.\n-\tt := new(Section)\n-\t*t = *sect\n-\treturn t\n-}\n-\n-const saveMismatch = true\n-\n-// checkGolden checks that data matches the named file.\n-// If not, it reports the error to the test.\n-func checkGolden(t *testing.T, data []byte, name string) {\n-\tgolden := mustParseHexdumpFile(t, name)\n-\tif !bytes.Equal(data, golden) {\n-\t\tif saveMismatch {\n-\t\t\tioutil.WriteFile(name+\".raw\", data, 0666)\n-\t\t\tioutil.WriteFile(name+\".hex\", []byte(hexdump(data)), 0666)\n-\t\t}\n-\t\t// TODO(rsc): A better diff would be nice, as needed.\n-\t\ti := 0\n-\t\tfor i < len(data) && i < len(golden) && data[i] == golden[i] {\n-\t\t\ti++\n-\t\t}\n-\t\tif i >= len(data) {\n-\t\t\tt.Errorf(\"%s: output file shorter than expected: have %d bytes, want %d\", name, len(data), len(golden))\n-\t\t} else if i >= len(golden) {\n-\t\t\tt.Errorf(\"%s: output file larger than expected: have %d bytes, want %d\", name, len(data), len(golden))\n-\t\t} else {\n-\t\t\tt.Errorf(\"%s: output file differs at byte %d: have %#02x, want %#02x\", name, i, data[i], golden[i])\n-\t\t}\n-\t}\n-}"},{"sha":"acda2d24d6c6cc0c5ecbc8dc0099ce2b0057b315","filename":"src/cmd/newlink/runtime.go","status":"removed","additions":0,"deletions":28,"changes":28,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/runtime.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/runtime.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/runtime.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,28 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Generation of runtime-accessible data structures.\n-// See also debug.go.\n-\n-package main\n-\n-import \"cmd/internal/goobj\"\n-\n-func (p *Prog) runtime() {\n-\tp.pclntab()\n-\n-\t// TODO: Implement garbage collection data.\n-\tp.addSym(&Sym{\n-\t\tSym: &goobj.Sym{\n-\t\t\tSymID: goobj.SymID{Name: \"runtime.gcdata\"},\n-\t\t\tKind:  goobj.SRODATA,\n-\t\t},\n-\t})\n-\tp.addSym(&Sym{\n-\t\tSym: &goobj.Sym{\n-\t\t\tSymID: goobj.SymID{Name: \"runtime.gcbss\"},\n-\t\t\tKind:  goobj.SRODATA,\n-\t\t},\n-\t})\n-}"},{"sha":"7feb0d89002abf0b25c522fb79bf35032079f19d","filename":"src/cmd/newlink/scan.go","status":"removed","additions":0,"deletions":187,"changes":187,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/scan.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/scan.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/scan.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,187 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Initial scan of packages making up a program.\n-\n-// TODO(rsc): Rename goobj.SymID.Version to StaticID to avoid confusion with the ELF meaning of version.\n-// TODO(rsc): Fix file format so that SBSS/SNOPTRBSS with data is listed as SDATA/SNOPTRDATA.\n-// TODO(rsc): Parallelize scan to overlap file i/o where possible.\n-\n-package main\n-\n-import (\n-\t\"cmd/internal/goobj\"\n-\t\"os\"\n-\t\"sort\"\n-\t\"strings\"\n-)\n-\n-// scan scans all packages making up the program, starting with package main defined in mainfile.\n-func (p *Prog) scan(mainfile string) {\n-\tp.initScan()\n-\tp.scanFile(\"main\", mainfile)\n-\tif len(p.Missing) > 0 && !p.omitRuntime {\n-\t\tp.scanImport(\"runtime\")\n-\t}\n-\n-\tvar missing []string\n-\tfor sym := range p.Missing {\n-\t\tif !p.isAuto(sym) {\n-\t\t\tmissing = append(missing, sym.String())\n-\t\t}\n-\t}\n-\n-\tif missing != nil {\n-\t\tsort.Strings(missing)\n-\t\tfor _, sym := range missing {\n-\t\t\tp.errorf(\"undefined: %s\", sym)\n-\t\t}\n-\t}\n-\n-\t// TODO(rsc): Walk import graph to diagnose cycles.\n-}\n-\n-// initScan initializes the Prog fields needed by scan.\n-func (p *Prog) initScan() {\n-\tp.Packages = make(map[string]*Package)\n-\tp.Syms = make(map[goobj.SymID]*Sym)\n-\tp.Missing = make(map[goobj.SymID]bool)\n-\tp.Missing[p.startSym] = true\n-}\n-\n-// scanFile reads file to learn about the package with the given import path.\n-func (p *Prog) scanFile(pkgpath string, file string) {\n-\tpkg := &Package{\n-\t\tFile: file,\n-\t}\n-\tp.Packages[pkgpath] = pkg\n-\n-\tf, err := os.Open(file)\n-\tif err != nil {\n-\t\tp.errorf(\"%v\", err)\n-\t\treturn\n-\t}\n-\tgp, err := goobj.Parse(f, pkgpath)\n-\tf.Close()\n-\tif err != nil {\n-\t\tp.errorf(\"reading %s: %v\", file, err)\n-\t\treturn\n-\t}\n-\n-\t// TODO(rsc): Change cmd/internal/goobj to record package name as gp.Name.\n-\t// TODO(rsc): If pkgpath == \"main\", check that gp.Name == \"main\".\n-\n-\tpkg.Package = gp\n-\n-\tfor _, gs := range gp.Syms {\n-\t\t// TODO(rsc): Fix file format instead of this workaround.\n-\t\tif gs.Data.Size > 0 {\n-\t\t\tswitch gs.Kind {\n-\t\t\tcase goobj.SBSS:\n-\t\t\t\tgs.Kind = goobj.SDATA\n-\t\t\tcase goobj.SNOPTRBSS:\n-\t\t\t\tgs.Kind = goobj.SNOPTRDATA\n-\t\t\t}\n-\t\t}\n-\n-\t\tif gs.Version != 0 {\n-\t\t\tgs.Version += p.MaxVersion\n-\t\t}\n-\t\tfor i := range gs.Reloc {\n-\t\t\tr := &gs.Reloc[i]\n-\t\t\tif r.Sym.Version != 0 {\n-\t\t\t\tr.Sym.Version += p.MaxVersion\n-\t\t\t}\n-\t\t\tif p.Syms[r.Sym] == nil {\n-\t\t\t\tp.Missing[r.Sym] = true\n-\t\t\t}\n-\t\t}\n-\t\tif gs.Func != nil {\n-\t\t\tfor i := range gs.Func.FuncData {\n-\t\t\t\tfdata := &gs.Func.FuncData[i]\n-\t\t\t\tif fdata.Sym.Name != \"\" {\n-\t\t\t\t\tif fdata.Sym.Version != 0 {\n-\t\t\t\t\t\tfdata.Sym.Version += p.MaxVersion\n-\t\t\t\t\t}\n-\t\t\t\t\tif p.Syms[fdata.Sym] == nil {\n-\t\t\t\t\t\tp.Missing[fdata.Sym] = true\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tif old := p.Syms[gs.SymID]; old != nil {\n-\t\t\t// Duplicate definition of symbol. Is it okay?\n-\t\t\t// TODO(rsc): Write test for this code.\n-\t\t\tswitch {\n-\t\t\t// If both symbols are BSS (no data), take max of sizes\n-\t\t\t// but otherwise ignore second symbol.\n-\t\t\tcase old.Data.Size == 0 && gs.Data.Size == 0:\n-\t\t\t\tif old.Size < gs.Size {\n-\t\t\t\t\told.Size = gs.Size\n-\t\t\t\t}\n-\t\t\t\tcontinue\n-\n-\t\t\t// If one is in BSS and one is not, use the one that is not.\n-\t\t\tcase old.Data.Size > 0 && gs.Data.Size == 0:\n-\t\t\t\tcontinue\n-\t\t\tcase gs.Data.Size > 0 && old.Data.Size == 0:\n-\t\t\t\tbreak // install gs as new symbol below\n-\n-\t\t\t// If either is marked as DupOK, we can keep either one.\n-\t\t\t// Keep the one that we saw first.\n-\t\t\tcase old.DupOK || gs.DupOK:\n-\t\t\t\tcontinue\n-\n-\t\t\t// Otherwise, there's an actual conflict:\n-\t\t\tdefault:\n-\t\t\t\tp.errorf(\"symbol %s defined in both %s and %s %v %v\", gs.SymID, old.Package.File, file, old.Data, gs.Data)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t}\n-\t\ts := &Sym{\n-\t\t\tSym:     gs,\n-\t\t\tPackage: pkg,\n-\t\t}\n-\t\tp.addSym(s)\n-\t\tdelete(p.Missing, gs.SymID)\n-\n-\t\tif s.Data.Size > int64(s.Size) {\n-\t\t\tp.errorf(\"%s: initialized data larger than symbol (%d > %d)\", s, s.Data.Size, s.Size)\n-\t\t}\n-\t}\n-\tp.MaxVersion += pkg.MaxVersion\n-\n-\tfor i, pkgpath := range pkg.Imports {\n-\t\t// TODO(rsc): Fix file format to drop .a from recorded import path.\n-\t\tpkgpath = strings.TrimSuffix(pkgpath, \".a\")\n-\t\tpkg.Imports[i] = pkgpath\n-\n-\t\tp.scanImport(pkgpath)\n-\t}\n-}\n-\n-func (p *Prog) addSym(s *Sym) {\n-\tpkg := s.Package\n-\tif pkg == nil {\n-\t\tpkg = p.Packages[\"\"]\n-\t\tif pkg == nil {\n-\t\t\tpkg = &Package{}\n-\t\t\tp.Packages[\"\"] = pkg\n-\t\t}\n-\t\ts.Package = pkg\n-\t}\n-\tpkg.Syms = append(pkg.Syms, s)\n-\tp.Syms[s.SymID] = s\n-\tp.SymOrder = append(p.SymOrder, s)\n-}\n-\n-// scanImport finds the object file for the given import path and then scans it.\n-func (p *Prog) scanImport(pkgpath string) {\n-\tif p.Packages[pkgpath] != nil {\n-\t\treturn // already loaded\n-\t}\n-\n-\t// TODO(rsc): Implement correct search to find file.\n-\tp.scanFile(pkgpath, p.pkgdir+\"/\"+pkgpath+\".a\")\n-}"},{"sha":"d5df474248d6e5bd07d38d62ebe081b96b628e77","filename":"src/cmd/newlink/testdata/Makefile","status":"removed","additions":0,"deletions":15,"changes":15,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/Makefile","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/Makefile","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/Makefile?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,15 +0,0 @@\n-ALL=\\\n-\tautosection.6\\\n-\tautoweak.6\\\n-\tdead.6\\\n-\thello.6\\\n-\tlayout.6\\\n-\tpclntab.6\\\n-\n-all: $(ALL)\n-\n-%.6: %.s\n-\tGOARCH=amd64 GOOS=darwin go tool asm -o $*.6 -I $(shell go env GOROOT)/pkg/include -trimpath=$(shell pwd) $*.s\n-\n-pclntab.s: genpcln.go\n-\tgo run genpcln.go >pclntab.s"},{"sha":"702cab6d5a89bde069c1d8fdae50eb60bf63213e","filename":"src/cmd/newlink/testdata/autosection.6","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/autosection.6","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/autosection.6","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/autosection.6?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0"},{"sha":"e0cb21723ee8cf66048a31247f89a2ce46cc8a16","filename":"src/cmd/newlink/testdata/autosection.s","status":"removed","additions":0,"deletions":60,"changes":60,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/autosection.s","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/autosection.s","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/autosection.s?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,60 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Test of section-named symbols.\n-\n-#include \"textflag.h\"\n-\n-TEXT start(SB),7,$0\n-\tMOVQ $autotab(SB),AX\n-\tMOVQ $autoptr(SB),AX\n-\tRET\n-\n-GLOBL zero(SB), $8\n-\n-GLOBL zeronoptr(SB), NOPTR, $16\n-\n-// text\n-DATA autotab+0x00(SB)/8, $runtime·text(SB)\n-DATA autotab+0x08(SB)/8, $start(SB)\n-DATA autotab+0x10(SB)/8, $runtime·etext(SB)\n-DATA autotab+0x18(SB)/8, $start+16(SB)\n-\n-// data\n-DATA autotab+0x20(SB)/8, $runtime·data(SB)\n-DATA autotab+0x28(SB)/8, $autotab(SB)\n-DATA autotab+0x30(SB)/8, $runtime·edata(SB)\n-DATA autotab+0x38(SB)/8, $nonzero+4(SB)\n-\n-// bss\n-DATA autotab+0x40(SB)/8, $runtime·bss(SB)\n-DATA autotab+0x48(SB)/8, $zero(SB)\n-DATA autotab+0x50(SB)/8, $runtime·ebss(SB)\n-DATA autotab+0x58(SB)/8, $zero+8(SB)\n-\n-// noptrdata\n-DATA autotab+0x60(SB)/8, $runtime·noptrdata(SB)\n-DATA autotab+0x68(SB)/8, $nonzeronoptr(SB)\n-DATA autotab+0x70(SB)/8, $runtime·enoptrdata(SB)\n-DATA autotab+0x78(SB)/8, $nonzeronoptr+8(SB)\n-\n-// noptrbss\n-DATA autotab+0x80(SB)/8, $runtime·noptrbss(SB)\n-DATA autotab+0x88(SB)/8, $zeronoptr(SB)\n-DATA autotab+0x90(SB)/8, $runtime·enoptrbss(SB)\n-DATA autotab+0x98(SB)/8, $zeronoptr+16(SB)\n-\n-// end\n-DATA autotab+0xa0(SB)/8, $runtime·end(SB)\n-DATA autotab+0xa8(SB)/8, $zeronoptr+16(SB)\n-\n-GLOBL autotab(SB), $0xb0\n-\n-DATA nonzero(SB)/4, $1\n-GLOBL nonzero(SB), $4\n-\n-DATA nonzeronoptr(SB)/8, $2\n-GLOBL nonzeronoptr(SB), NOPTR, $8\n-\n-GLOBL autoptr(SB), $0"},{"sha":"5c68cdb61e057fe81e6a62d83abcc409c6ee43fd","filename":"src/cmd/newlink/testdata/autoweak.6","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/autoweak.6","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/autoweak.6","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/autoweak.6?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0"},{"sha":"2d11330db258ca1f53d54239359dbf88fe4f80a9","filename":"src/cmd/newlink/testdata/autoweak.s","status":"removed","additions":0,"deletions":30,"changes":30,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/autoweak.s","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/autoweak.s","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/autoweak.s?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,30 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Test of go.weak symbols.\n-\n-TEXT start(SB),7,$0\n-\tMOVQ $autotab(SB),AX\n-\tMOVQ $autoptr(SB),AX\n-\tRET\n-\n-// go.weak.sym should resolve to sym, because sym is in the binary.\n-DATA autotab+0(SB)/8, $go·weak·sym(SB)\n-DATA autotab+8(SB)/8, $sym(SB)\n-\n-// go.weak.missingsym should resolve to 0, because missingsym is not in the binary.\n-DATA autotab+16(SB)/8, $go·weak·missingsym(SB)\n-DATA autotab+24(SB)/8, $0\n-\n-// go.weak.deadsym should resolve to 0, because deadsym is discarded during dead code removal\n-DATA autotab+32(SB)/8, $go·weak·deadsym(SB)\n-DATA autotab+40(SB)/8, $0\n-\n-GLOBL autotab(SB), $48\n-\n-GLOBL sym(SB), $1\n-\n-GLOBL deadsym(SB), $1\n-\n-GLOBL autoptr(SB), $0"},{"sha":"6f14aa27cf98b95a1804c6d10c70c3ef71d39196","filename":"src/cmd/newlink/testdata/dead.6","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/dead.6","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/dead.6","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/dead.6?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0"},{"sha":"86f31360faebefdae2cb83d5b5babf342e7ead24","filename":"src/cmd/newlink/testdata/dead.s","status":"removed","additions":0,"deletions":48,"changes":48,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/dead.s","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/dead.s","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/dead.s?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,48 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Test of dead code removal.\n-// Symbols with names beginning with dead_ should be discarded.\n-// Others should be kept.\n-\n-TEXT start(SB),7,$0\t// start symbol\n-\tMOVQ $data1<>(SB), AX\n-\tCALL text1(SB)\n-\tMOVQ $text2(SB), BX\n-\tRET\n-\n-TEXT text1(SB),7,$0\n-\tFUNCDATA $1, funcdata+4(SB)\n-\tRET\n-\n-TEXT text2(SB),7,$0\n-\tMOVQ $runtime·edata(SB),BX\n-\tRET\n-\n-DATA data1<>+0(SB)/8, $data2(SB)\n-DATA data1<>+8(SB)/8, $data3(SB)\n-GLOBL data1<>(SB), $16\n-GLOBL data2(SB), $1\n-GLOBL data3(SB), $1\n-GLOBL funcdata(SB), $8\n-\n-TEXT dead_start(SB),7,$0\n-\tMOVQ $dead_data1(SB), AX\n-\tCALL dead_text1(SB)\n-\tMOVQ $dead_text2(SB), BX\n-\tRET\n-\n-TEXT dead_text1(SB),7,$0\n-\tFUNCDATA $1, dead_funcdata+4(SB)\n-\tRET\n-\n-TEXT dead_text2(SB),7,$0\n-\tRET\n-\n-DATA dead_data1+0(SB)/8, $dead_data2(SB)\n-DATA dead_data1+8(SB)/8, $dead_data3(SB)\n-GLOBL dead_data1(SB), $16\n-GLOBL dead_data2(SB), $1\n-GLOBL dead_data3(SB), $1\n-GLOBL dead_funcdata(SB), $8"},{"sha":"c10eaeae9139b237bf9840ca2d5a59754006f166","filename":"src/cmd/newlink/testdata/genpcln.go","status":"removed","additions":0,"deletions":112,"changes":112,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/genpcln.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/genpcln.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/genpcln.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,112 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This program generates a .s file using a pseudorandom\n-// value stream for the runtime function data.\n-// The pclntab test checks that the linked copy\n-// still has the same pseudorandom value stream.\n-\n-package main\n-\n-import (\n-\t\"fmt\"\n-\t\"math/rand\"\n-)\n-\n-func main() {\n-\tfmt.Printf(\"// generated by genpcln.go; do not edit\\n\\n\")\n-\tfor f := 0; f < 3; f++ {\n-\t\tr := rand.New(rand.NewSource(int64(f)))\n-\t\tfile := \"input\"\n-\t\tline := 1\n-\t\targs := r.Intn(100) * 8\n-\t\tframe := 32 + r.Intn(32)/8*8\n-\t\tfmt.Printf(\"#line %d %q\\n\", line, file)\n-\t\tfmt.Printf(\"TEXT func%d(SB),7,$%d-%d\\n\", f, frame, args)\n-\t\tfmt.Printf(\"\\tFUNCDATA $1, funcdata%d(SB)\\n\", f)\n-\t\tfmt.Printf(\"#line %d %q\\n\", line, file)\n-\t\tsize := 200 + r.Intn(100)*8\n-\t\tspadj := 0\n-\t\tflushed := 0\n-\t\tfirstpc := 4\n-\t\tflush := func(i int) {\n-\t\t\tfor i-flushed >= 10 {\n-\t\t\t\tfmt.Printf(\"#line %d %q\\n\", line, file)\n-\t\t\t\tfmt.Printf(\"/*%#04x*/\\tMOVQ $0x123456789, AX\\n\", firstpc+flushed)\n-\t\t\t\tflushed += 10\n-\t\t\t}\n-\t\t\tfor i-flushed >= 5 {\n-\t\t\t\tfmt.Printf(\"#line %d %q\\n\", line, file)\n-\t\t\t\tfmt.Printf(\"/*%#04x*/\\tMOVL $0x1234567, AX\\n\", firstpc+flushed)\n-\t\t\t\tflushed += 5\n-\t\t\t}\n-\t\t\tfor i-flushed > 0 {\n-\t\t\t\tfmt.Printf(\"#line %d %q\\n\", line, file)\n-\t\t\t\tfmt.Printf(\"/*%#04x*/\\tBYTE $0\\n\", firstpc+flushed)\n-\t\t\t\tflushed++\n-\t\t\t}\n-\t\t}\n-\t\tfor i := 0; i < size; i++ {\n-\t\t\t// Possible SP adjustment.\n-\t\t\tif r.Intn(100) == 0 {\n-\t\t\t\tflush(i)\n-\t\t\t\tfmt.Printf(\"#line %d %q\\n\", line, file)\n-\t\t\t\tif spadj <= -32 || spadj < 32 && r.Intn(2) == 0 {\n-\t\t\t\t\tspadj += 8\n-\t\t\t\t\tfmt.Printf(\"/*%#04x*/\\tPUSHQ AX\\n\", firstpc+i)\n-\t\t\t\t} else {\n-\t\t\t\t\tspadj -= 8\n-\t\t\t\t\tfmt.Printf(\"/*%#04x*/\\tPOPQ AX\\n\", firstpc+i)\n-\t\t\t\t}\n-\t\t\t\ti += 1\n-\t\t\t\tflushed = i\n-\t\t\t}\n-\n-\t\t\t// Possible PCFile change.\n-\t\t\tif r.Intn(100) == 0 {\n-\t\t\t\tflush(i)\n-\t\t\t\tfile = fmt.Sprintf(\"file%d.s\", r.Intn(10))\n-\t\t\t\tline = r.Intn(100) + 1\n-\t\t\t}\n-\n-\t\t\t// Possible PCLine change.\n-\t\t\tif r.Intn(10) == 0 {\n-\t\t\t\tflush(i)\n-\t\t\t\tline = r.Intn(1000) + 1\n-\t\t\t}\n-\n-\t\t\t// Possible PCData $1 change.\n-\t\t\tif r.Intn(100) == 0 {\n-\t\t\t\tflush(i)\n-\t\t\t\tfmt.Printf(\"/*%6s*/\\tPCDATA $1, $%d\\n\", \"\", r.Intn(1000))\n-\t\t\t}\n-\n-\t\t\t// Possible PCData $2 change.\n-\t\t\tif r.Intn(100) == 0 {\n-\t\t\t\tflush(i)\n-\t\t\t\tfmt.Printf(\"/*%6s*/\\tPCDATA $2, $%d\\n\", \"\", r.Intn(1000))\n-\t\t\t}\n-\t\t}\n-\t\tflush(size)\n-\t\tfor spadj < 0 {\n-\t\t\tfmt.Printf(\"\\tPUSHQ AX\\n\")\n-\t\t\tspadj += 8\n-\t\t}\n-\t\tfor spadj > 0 {\n-\t\t\tfmt.Printf(\"\\tPOPQ AX\\n\")\n-\t\t\tspadj -= 8\n-\t\t}\n-\t\tfmt.Printf(\"\\tRET\\n\")\n-\n-\t\tfmt.Printf(\"\\n\")\n-\t\tfmt.Printf(\"GLOBL funcdata%d(SB), $16\\n\", f)\n-\t}\n-\n-\tfmt.Printf(\"\\nTEXT start(SB),7,$0\\n\")\n-\tfor f := 0; f < 3; f++ {\n-\t\tfmt.Printf(\"\\tCALL func%d(SB)\\n\", f)\n-\t}\n-\tfmt.Printf(\"\\tMOVQ $runtime·pclntab(SB), AX\\n\")\n-\tfmt.Printf(\"\\n\\tRET\\n\")\n-}"},{"sha":"825a2a66ffa77c61e778e82c648b496c436ecf3d","filename":"src/cmd/newlink/testdata/hello.6","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/hello.6","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/hello.6","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/hello.6?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0"},{"sha":"32ed675033302b17a75b38d3a9e851b3abd28740","filename":"src/cmd/newlink/testdata/hello.s","status":"removed","additions":0,"deletions":15,"changes":15,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/hello.s","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/hello.s","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/hello.s?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,15 +0,0 @@\n-TEXT _rt0_go(SB),7,$0\n-\tMOVL $1, DI\n-\tMOVL $hello<>(SB), SI\n-\tMOVL $12, DX\n-\tMOVL $0x2000004, AX\n-\tSYSCALL\n-\tMOVL $0, DI\n-\tMOVL $0x2000001, AX\n-\tSYSCALL\n-\tRET\n-\n-DATA hello<>+0(SB)/4, $\"hell\"\n-DATA hello<>+4(SB)/4, $\"o wo\"\n-DATA hello<>+8(SB)/4, $\"rld\\n\"\n-GLOBL hello<>(SB), $12"},{"sha":"7e2a22b163ef10e40ce9e97b5828bc6ff3df9341","filename":"src/cmd/newlink/testdata/layout.6","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/layout.6","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/layout.6","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/layout.6?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0"},{"sha":"c3e55ef49a9f1493f598182f2b426c6ec9584633","filename":"src/cmd/newlink/testdata/layout.s","status":"removed","additions":0,"deletions":29,"changes":29,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/layout.s","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/layout.s","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/layout.s?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,29 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Test of section assignment in layout.go.\n-// Each symbol should end up in the section named by the symbol name prefix (up to the underscore).\n-\n-#include \"textflag.h\"\n-\n-TEXT text_start(SB),7,$0\n-\tMOVQ $rodata_sym(SB), AX\n-\tMOVQ $noptrdata_sym(SB), AX\n-\tMOVQ $data_sym(SB), AX\n-\tMOVQ $bss_sym(SB), AX\n-\tMOVQ $noptrbss_sym(SB), AX\n-\tRET\n-\n-DATA rodata_sym(SB)/4, $1\n-GLOBL rodata_sym(SB), RODATA, $4\n-\n-DATA noptrdata_sym(SB)/4, $1\n-GLOBL noptrdata_sym(SB), NOPTR, $4\n-\n-DATA data_sym(SB)/4, $1\n-GLOBL data_sym(SB), $4\n-\n-GLOBL bss_sym(SB), $4\n-\n-GLOBL noptrbss_sym(SB), NOPTR, $4"},{"sha":"4c62eb19b46afc01011e4c6e592af1083a9d6db7","filename":"src/cmd/newlink/testdata/link.hello.darwin.amd64","status":"removed","additions":0,"deletions":55,"changes":55,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/link.hello.darwin.amd64","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/link.hello.darwin.amd64","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/link.hello.darwin.amd64?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,55 +0,0 @@\n-00000000  cf fa ed fe 07 00 00 01  03 00 00 00 02 00 00 00  |................|\n-00000010  04 00 00 00 d0 02 00 00  01 00 00 00 00 00 00 00  |................|\n-00000020  19 00 00 00 48 00 00 00  5f 5f 50 41 47 45 5a 45  |....H...__PAGEZE|\n-00000030  52 4f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |RO..............|\n-00000040  00 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-*\n-00000060  00 00 00 00 00 00 00 00  19 00 00 00 38 01 00 00  |............8...|\n-00000070  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-00000080  00 10 00 00 00 00 00 00  c0 10 00 00 00 00 00 00  |................|\n-00000090  00 00 00 00 00 00 00 00  c0 10 00 00 00 00 00 00  |................|\n-000000a0  07 00 00 00 05 00 00 00  03 00 00 00 00 00 00 00  |................|\n-000000b0  5f 5f 74 65 78 74 00 00  00 00 00 00 00 00 00 00  |__text..........|\n-000000c0  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-000000d0  00 20 00 00 00 00 00 00  30 00 00 00 00 00 00 00  |. ......0.......|\n-000000e0  00 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-000000f0  00 04 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000100  5f 5f 72 6f 64 61 74 61  00 00 00 00 00 00 00 00  |__rodata........|\n-00000110  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-00000120  30 20 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |0 ..............|\n-00000130  30 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |0...............|\n-*\n-00000150  5f 5f 66 75 6e 63 74 61  62 00 00 00 00 00 00 00  |__functab.......|\n-00000160  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-00000170  30 20 00 00 00 00 00 00  90 00 00 00 00 00 00 00  |0 ..............|\n-00000180  30 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |0...............|\n-*\n-000001a0  19 00 00 00 98 00 00 00  5f 5f 44 41 54 41 00 00  |........__DATA..|\n-000001b0  00 00 00 00 00 00 00 00  00 30 00 00 00 00 00 00  |.........0......|\n-000001c0  0c 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|\n-000001d0  0c 00 00 00 00 00 00 00  03 00 00 00 03 00 00 00  |................|\n-000001e0  01 00 00 00 00 00 00 00  5f 5f 64 61 74 61 00 00  |........__data..|\n-000001f0  00 00 00 00 00 00 00 00  5f 5f 44 41 54 41 00 00  |........__DATA..|\n-00000200  00 00 00 00 00 00 00 00  00 30 00 00 00 00 00 00  |.........0......|\n-00000210  0c 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|\n-*\n-00000230  00 00 00 00 00 00 00 00  05 00 00 00 b8 00 00 00  |................|\n-00000240  04 00 00 00 2a 00 00 00  00 00 00 00 00 00 00 00  |....*...........|\n-*\n-000002c0  00 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|\n-*\n-00001000  bf 01 00 00 00 8d 35 f5  0f 00 00 ba 0c 00 00 00  |......5.........|\n-00001010  b8 04 00 00 02 0f 05 31  ff b8 01 00 00 02 0f 05  |.......1........|\n-00001020  c3 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00001030  fb ff ff ff 00 00 01 08  01 00 00 00 00 00 00 00  |................|\n-00001040  00 20 00 00 00 00 00 00  30 00 00 00 00 00 00 00  |. ......0.......|\n-00001050  30 20 00 00 00 00 00 00  80 00 00 00 00 00 00 00  |0 ..............|\n-00001060  00 20 00 00 00 00 00 00  58 00 00 00 00 00 00 80  |. ......X.......|\n-00001070  08 00 00 00 60 00 00 00  63 00 00 00 66 00 00 00  |....`...c...f...|\n-00001080  00 00 00 00 00 00 00 00  5f 72 74 30 5f 67 6f 00  |........_rt0_go.|\n-00001090  02 30 00 04 30 00 06 05  02 06 02 05 02 05 02 02  |.0..0...........|\n-000010a0  02 02 02 05 02 02 02 10  00 00 00 00 00 00 00 00  |................|\n-000010b0  02 00 00 00 88 00 00 00  68 65 6c 6c 6f 2e 73 00  |........hello.s.|\n-*\n-00002000  68 65 6c 6c 6f 20 77 6f  72 6c 64 0a              |hello world.|\n-0000200c"},{"sha":"1adc814c33936afe1973a27747e9a59fb6203eb7","filename":"src/cmd/newlink/testdata/macho.amd64.exit9","status":"removed","additions":0,"deletions":24,"changes":24,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/macho.amd64.exit9","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/macho.amd64.exit9","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/macho.amd64.exit9?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,24 +0,0 @@\n-00000000  cf fa ed fe 07 00 00 01  03 00 00 00 02 00 00 00  |................|\n-00000010  03 00 00 00 98 01 00 00  01 00 00 00 00 00 00 00  |................|\n-00000020  19 00 00 00 48 00 00 00  5f 5f 50 41 47 45 5a 45  |....H...__PAGEZE|\n-00000030  52 4f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |RO..............|\n-00000040  00 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000060  00 00 00 00 00 00 00 00  19 00 00 00 98 00 00 00  |................|\n-00000070  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-00000080  00 10 00 00 00 00 00 00  0d 10 00 00 00 00 00 00  |................|\n-00000090  00 00 00 00 00 00 00 00  0d 10 00 00 00 00 00 00  |................|\n-000000a0  07 00 00 00 05 00 00 00  01 00 00 00 00 00 00 00  |................|\n-000000b0  5f 5f 74 65 78 74 00 00  00 00 00 00 00 00 00 00  |__text..........|\n-000000c0  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-000000d0  00 20 00 00 00 00 00 00  0d 00 00 00 00 00 00 00  |. ..............|\n-000000e0  00 10 00 00 06 00 00 00  00 00 00 00 00 00 00 00  |................|\n-000000f0  00 04 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000100  05 00 00 00 b8 00 00 00  04 00 00 00 2a 00 00 00  |............*...|\n-00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-*\n-00000190  00 20 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |. ..............|\n-000001a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-*\n-00001000  b8 01 00 00 02 bf 09 00  00 00 0f 05 f4           |.............|\n-0000100d"},{"sha":"45e70d0ac538d927c7b94f32b980847f07bb53bf","filename":"src/cmd/newlink/testdata/macho.amd64.hello","status":"removed","additions":0,"deletions":39,"changes":39,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/macho.amd64.hello","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/macho.amd64.hello","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/macho.amd64.hello?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,39 +0,0 @@\n-00000000  cf fa ed fe 07 00 00 01  03 00 00 00 02 00 00 00  |................|\n-00000010  04 00 00 00 30 02 00 00  01 00 00 00 00 00 00 00  |....0...........|\n-00000020  19 00 00 00 48 00 00 00  5f 5f 50 41 47 45 5a 45  |....H...__PAGEZE|\n-00000030  52 4f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |RO..............|\n-00000040  00 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000060  00 00 00 00 00 00 00 00  19 00 00 00 98 00 00 00  |................|\n-00000070  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-00000080  00 10 00 00 00 00 00 00  23 10 00 00 00 00 00 00  |........#.......|\n-00000090  00 00 00 00 00 00 00 00  23 10 00 00 00 00 00 00  |........#.......|\n-000000a0  07 00 00 00 05 00 00 00  01 00 00 00 00 00 00 00  |................|\n-000000b0  5f 5f 74 65 78 74 00 00  00 00 00 00 00 00 00 00  |__text..........|\n-000000c0  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-000000d0  00 20 00 00 00 00 00 00  23 00 00 00 00 00 00 00  |. ......#.......|\n-000000e0  00 10 00 00 06 00 00 00  00 00 00 00 00 00 00 00  |................|\n-000000f0  00 04 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000100  19 00 00 00 98 00 00 00  5f 5f 44 41 54 41 00 00  |........__DATA..|\n-00000110  00 00 00 00 00 00 00 00  00 30 00 00 00 00 00 00  |.........0......|\n-00000120  0c 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|\n-00000130  0c 00 00 00 00 00 00 00  03 00 00 00 03 00 00 00  |................|\n-00000140  01 00 00 00 00 00 00 00  5f 5f 64 61 74 61 00 00  |........__data..|\n-00000150  00 00 00 00 00 00 00 00  5f 5f 44 41 54 41 00 00  |........__DATA..|\n-00000160  00 00 00 00 00 00 00 00  00 30 00 00 00 00 00 00  |.........0......|\n-00000170  0c 00 00 00 00 00 00 00  00 20 00 00 06 00 00 00  |......... ......|\n-00000180  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000190  00 00 00 00 00 00 00 00  05 00 00 00 b8 00 00 00  |................|\n-000001a0  04 00 00 00 2a 00 00 00  00 00 00 00 00 00 00 00  |....*...........|\n-000001b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-*\n-00000220  00 00 00 00 00 00 00 00  00 20 00 00 00 00 00 00  |......... ......|\n-00000230  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-*\n-00001000  b8 04 00 00 02 bf 01 00  00 00 be 00 30 00 00 ba  |............0...|\n-00001010  0c 00 00 00 0f 05 b8 01  00 00 02 bf 09 00 00 00  |................|\n-00001020  0f 05 f4 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-*\n-00002000  68 65 6c 6c 6f 20 77 6f  72 6c 64 0a              |hello world.|\n-0000200c"},{"sha":"4b70fbd0fa3c6270f1f2ff1d2fd46621d8c67292","filename":"src/cmd/newlink/testdata/macho.amd64.helloro","status":"removed","additions":0,"deletions":34,"changes":34,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/macho.amd64.helloro","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/macho.amd64.helloro","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/macho.amd64.helloro?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,34 +0,0 @@\n-00000000  cf fa ed fe 07 00 00 01  03 00 00 00 02 00 00 00  |................|\n-00000010  03 00 00 00 e8 01 00 00  01 00 00 00 00 00 00 00  |................|\n-00000020  19 00 00 00 48 00 00 00  5f 5f 50 41 47 45 5a 45  |....H...__PAGEZE|\n-00000030  52 4f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |RO..............|\n-00000040  00 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000060  00 00 00 00 00 00 00 00  19 00 00 00 e8 00 00 00  |................|\n-00000070  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-00000080  00 10 00 00 00 00 00 00  0c 20 00 00 00 00 00 00  |......... ......|\n-00000090  00 00 00 00 00 00 00 00  0c 20 00 00 00 00 00 00  |......... ......|\n-000000a0  07 00 00 00 05 00 00 00  02 00 00 00 00 00 00 00  |................|\n-000000b0  5f 5f 74 65 78 74 00 00  00 00 00 00 00 00 00 00  |__text..........|\n-000000c0  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-000000d0  00 20 00 00 00 00 00 00  23 00 00 00 00 00 00 00  |. ......#.......|\n-000000e0  00 10 00 00 06 00 00 00  00 00 00 00 00 00 00 00  |................|\n-000000f0  00 04 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000100  5f 5f 72 6f 64 61 74 61  00 00 00 00 00 00 00 00  |__rodata........|\n-00000110  5f 5f 54 45 58 54 00 00  00 00 00 00 00 00 00 00  |__TEXT..........|\n-00000120  00 30 00 00 00 00 00 00  0c 00 00 00 00 00 00 00  |.0..............|\n-00000130  00 20 00 00 06 00 00 00  00 00 00 00 00 00 00 00  |. ..............|\n-00000140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000150  05 00 00 00 b8 00 00 00  04 00 00 00 2a 00 00 00  |............*...|\n-00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-*\n-000001e0  00 20 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |. ..............|\n-000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-*\n-00001000  b8 04 00 00 02 bf 01 00  00 00 be 00 30 00 00 ba  |............0...|\n-00001010  0c 00 00 00 0f 05 b8 01  00 00 02 bf 00 00 00 00  |................|\n-00001020  0f 05 f4 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-*\n-00002000  68 65 6c 6c 6f 20 77 6f  72 6c 64 0a              |hello world.|\n-0000200c"},{"sha":"d029bb78e6c9bb62e02458d24a7f42e8e8229c3e","filename":"src/cmd/newlink/testdata/pclntab.6","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/pclntab.6","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/pclntab.6","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/pclntab.6?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0"},{"sha":"12dac70b0cdeaa528599789b4fb4e0dac348283f","filename":"src/cmd/newlink/testdata/pclntab.s","status":"removed","additions":0,"deletions":1751,"changes":1751,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/pclntab.s","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/testdata/pclntab.s","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/testdata/pclntab.s?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0"},{"sha":"b8a6b2cb30d7111f403440ec9905b8f3d50f98b7","filename":"src/cmd/newlink/util.go","status":"removed","additions":0,"deletions":11,"changes":11,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/util.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/util.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/util.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,11 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-// round returns size rounded up to the next multiple of align;\n-// align must be a power of two.\n-func round(size, align Addr) Addr {\n-\treturn (size + align - 1) &^ (align - 1)\n-}"},{"sha":"7e11b2fe714d49567ed54d764288f0cb0e707e83","filename":"src/cmd/newlink/write.go","status":"removed","additions":0,"deletions":14,"changes":14,"blob_url":"https://github.com/golang/go/blob/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/write.go","raw_url":"https://github.com/golang/go/raw/6c6aabe0bca7209d646c840d6274b1ffd199bba0/src/cmd/newlink/write.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/newlink/write.go?ref=6c6aabe0bca7209d646c840d6274b1ffd199bba0","patch":"@@ -1,14 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Writing of executable and (for hostlink mode) object files.\n-\n-package main\n-\n-import \"io\"\n-\n-func (p *Prog) write(w io.Writer) {\n-\tp.Entry = p.Syms[p.startSym].Addr\n-\tp.formatter.write(w, p)\n-}"}]}