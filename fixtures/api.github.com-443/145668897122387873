GET /repos/golang/go/commits/a8ba40823c08508ca5f7562501a26bc2e85c88eb?access_token=token
host: api.github.com
accept: application/vnd.github.v3+json

HTTP/1.1 200 OK
server: GitHub.com
date: Sun, 28 Feb 2016 20:42:20 GMT
content-type: application/json; charset=utf-8
content-length: 10856
connection: close
status: 200 OK
x-ratelimit-limit: 5000
x-ratelimit-remaining: 4725
x-ratelimit-reset: 1456694697
cache-control: private, max-age=60, s-maxage=60
vary: Accept, Authorization, Cookie, X-GitHub-OTP, Accept-Encoding
etag: "86e35c1d8e245f7b95502f8eee62fa3b"
last-modified: Wed, 18 Nov 2009 02:21:47 GMT
x-oauth-scopes: public_repo
x-accepted-oauth-scopes: 
x-github-media-type: github.v3; format=json
access-control-allow-credentials: true
access-control-expose-headers: ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval
access-control-allow-origin: *
content-security-policy: default-src 'none'
strict-transport-security: max-age=31536000; includeSubdomains; preload
x-content-type-options: nosniff
x-frame-options: deny
x-xss-protection: 1; mode=block
x-served-by: 593010132f82159af0ded24b4932e109
x-github-request-id: 4E320659:4B2B:4CE0CA5:56D35BAB

{"sha":"a8ba40823c08508ca5f7562501a26bc2e85c88eb","commit":{"author":{"name":"Adam Langley","email":"agl@golang.org","date":"2009-11-18T02:21:47Z"},"committer":{"name":"Adam Langley","email":"agl@golang.org","date":"2009-11-18T02:21:47Z"},"message":"crypto/rsa: add PKCS#1 v1.5 signature support.\n\nR=rsc\nCC=golang-dev\nhttps://golang.org/cl/156051","tree":{"sha":"ce9a06150cbc5e86622fce7a280d4c87af08c69f","url":"https://api.github.com/repos/golang/go/git/trees/ce9a06150cbc5e86622fce7a280d4c87af08c69f"},"url":"https://api.github.com/repos/golang/go/git/commits/a8ba40823c08508ca5f7562501a26bc2e85c88eb","comment_count":0},"url":"https://api.github.com/repos/golang/go/commits/a8ba40823c08508ca5f7562501a26bc2e85c88eb","html_url":"https://github.com/golang/go/commit/a8ba40823c08508ca5f7562501a26bc2e85c88eb","comments_url":"https://api.github.com/repos/golang/go/commits/a8ba40823c08508ca5f7562501a26bc2e85c88eb/comments","author":{"login":"agl","id":21203,"avatar_url":"https://avatars.githubusercontent.com/u/21203?v=3","gravatar_id":"","url":"https://api.github.com/users/agl","html_url":"https://github.com/agl","followers_url":"https://api.github.com/users/agl/followers","following_url":"https://api.github.com/users/agl/following{/other_user}","gists_url":"https://api.github.com/users/agl/gists{/gist_id}","starred_url":"https://api.github.com/users/agl/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/agl/subscriptions","organizations_url":"https://api.github.com/users/agl/orgs","repos_url":"https://api.github.com/users/agl/repos","events_url":"https://api.github.com/users/agl/events{/privacy}","received_events_url":"https://api.github.com/users/agl/received_events","type":"User","site_admin":false},"committer":{"login":"agl","id":21203,"avatar_url":"https://avatars.githubusercontent.com/u/21203?v=3","gravatar_id":"","url":"https://api.github.com/users/agl","html_url":"https://github.com/agl","followers_url":"https://api.github.com/users/agl/followers","following_url":"https://api.github.com/users/agl/following{/other_user}","gists_url":"https://api.github.com/users/agl/gists{/gist_id}","starred_url":"https://api.github.com/users/agl/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/agl/subscriptions","organizations_url":"https://api.github.com/users/agl/orgs","repos_url":"https://api.github.com/users/agl/repos","events_url":"https://api.github.com/users/agl/events{/privacy}","received_events_url":"https://api.github.com/users/agl/received_events","type":"User","site_admin":false},"parents":[{"sha":"80b7f6a8d4b9e3ee650f95fbd070d32b73ac6376","url":"https://api.github.com/repos/golang/go/commits/80b7f6a8d4b9e3ee650f95fbd070d32b73ac6376","html_url":"https://github.com/golang/go/commit/80b7f6a8d4b9e3ee650f95fbd070d32b73ac6376"}],"stats":{"total":179,"additions":179,"deletions":0},"files":[{"sha":"f60d2b3970e750f601512481d51c1694a7ac817f","filename":"src/pkg/crypto/rsa/pkcs1v15.go","status":"modified","additions":128,"deletions":0,"changes":128,"blob_url":"https://github.com/golang/go/blob/a8ba40823c08508ca5f7562501a26bc2e85c88eb/src/pkg/crypto/rsa/pkcs1v15.go","raw_url":"https://github.com/golang/go/raw/a8ba40823c08508ca5f7562501a26bc2e85c88eb/src/pkg/crypto/rsa/pkcs1v15.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/pkg/crypto/rsa/pkcs1v15.go?ref=a8ba40823c08508ca5f7562501a26bc2e85c88eb","patch":"@@ -136,3 +136,131 @@ func nonZeroRandomBytes(s []byte, rand io.Reader) (err os.Error) {\n \n \treturn;\n }\n+\n+// Due to the design of PKCS#1 v1.5, we need to know the exact hash function in\n+// use. A generic hash.Hash will not do.\n+type PKCS1v15Hash int\n+\n+const (\n+\tHashMD5\tPKCS1v15Hash\t= iota;\n+\tHashSHA1;\n+\tHashSHA256;\n+\tHashSHA384;\n+\tHashSHA512;\n+)\n+\n+// These are ASN1 DER structures:\n+//   DigestInfo ::= SEQUENCE {\n+//     digestAlgorithm AlgorithmIdentifier,\n+//     digest OCTET STRING\n+//   }\n+// For performance, we don't use the generic ASN1 encoding. Rather, we\n+// precompute a prefix of the digest value that makes a valid ASN1 DER string\n+// with the correct contents.\n+var hashPrefixes = [][]byte{\n+\t// HashMD5\n+\t[]byte{0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10},\n+\t// HashSHA1\n+\t[]byte{0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14},\n+\t// HashSHA256\n+\t[]byte{0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20},\n+\t// HashSHA384\n+\t[]byte{0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30},\n+\t// HashSHA512\n+\t[]byte{0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40},\n+}\n+\n+// SignPKCS1v15 calcuates the signature of hashed using RSASSA-PSS-SIGN from RSA PKCS#1 v1.5.\n+// Note that hashed must be the result of hashing the input message using the\n+// given hash function.\n+func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash PKCS1v15Hash, hashed []byte) (s []byte, err os.Error) {\n+\thashLen, prefix, err := pkcs1v15HashInfo(hash, len(hashed));\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\ttLen := len(prefix) + hashLen;\n+\tk := (priv.N.Len() + 7) / 8;\n+\tif k < tLen+11 {\n+\t\treturn nil, MessageTooLongError{}\n+\t}\n+\n+\t// EM = 0x00 || 0x01 || PS || 0x00 || T\n+\tem := make([]byte, k);\n+\tem[1] = 1;\n+\tfor i := 2; i < k-tLen-1; i++ {\n+\t\tem[i] = 0xff\n+\t}\n+\tbytes.Copy(em[k-tLen:k-hashLen], prefix);\n+\tbytes.Copy(em[k-hashLen:k], hashed);\n+\n+\tm := new(big.Int).SetBytes(em);\n+\tc, err := decrypt(rand, priv, m);\n+\tif err == nil {\n+\t\ts = c.Bytes()\n+\t}\n+\treturn;\n+}\n+\n+// VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\n+// hashed is the result of hashing the input message using the given hash\n+// function and sig is the signature. A valid signature is indicated by\n+// returning a nil error.\n+func VerifyPKCS1v15(pub *PublicKey, hash PKCS1v15Hash, hashed []byte, sig []byte) (err os.Error) {\n+\thashLen, prefix, err := pkcs1v15HashInfo(hash, len(hashed));\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\ttLen := len(prefix) + hashLen;\n+\tk := (pub.N.Len() + 7) / 8;\n+\tif k < tLen+11 {\n+\t\terr = VerificationError{};\n+\t\treturn;\n+\t}\n+\n+\tc := new(big.Int).SetBytes(sig);\n+\tm := encrypt(new(big.Int), pub, c);\n+\tem := leftPad(m.Bytes(), k);\n+\t// EM = 0x00 || 0x01 || PS || 0x00 || T\n+\n+\tok := subtle.ConstantTimeByteEq(em[0], 0);\n+\tok &= subtle.ConstantTimeByteEq(em[1], 1);\n+\tok &= subtle.ConstantTimeCompare(em[k-hashLen:k], hashed);\n+\tok &= subtle.ConstantTimeCompare(em[k-tLen:k-hashLen], prefix);\n+\tok &= subtle.ConstantTimeByteEq(em[k-tLen-1], 0);\n+\n+\tfor i := 2; i < k-tLen-1; i++ {\n+\t\tok &= subtle.ConstantTimeByteEq(em[i], 0xff)\n+\t}\n+\n+\tif ok != 1 {\n+\t\treturn VerificationError{}\n+\t}\n+\n+\treturn nil;\n+}\n+\n+func pkcs1v15HashInfo(hash PKCS1v15Hash, inLen int) (hashLen int, prefix []byte, err os.Error) {\n+\tswitch hash {\n+\tcase HashMD5:\n+\t\thashLen = 16\n+\tcase HashSHA1:\n+\t\thashLen = 20\n+\tcase HashSHA256:\n+\t\thashLen = 32\n+\tcase HashSHA384:\n+\t\thashLen = 48\n+\tcase HashSHA512:\n+\t\thashLen = 64\n+\tdefault:\n+\t\treturn 0, nil, os.ErrorString(\"unknown hash function\")\n+\t}\n+\n+\tif inLen != hashLen {\n+\t\treturn 0, nil, os.ErrorString(\"input must be hashed message\")\n+\t}\n+\n+\tprefix = hashPrefixes[int(hash)];\n+\treturn;\n+}"},{"sha":"4d62deac1465e3285feeb59ccdfae6263d41d858","filename":"src/pkg/crypto/rsa/pkcs1v15_test.go","status":"modified","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/golang/go/blob/a8ba40823c08508ca5f7562501a26bc2e85c88eb/src/pkg/crypto/rsa/pkcs1v15_test.go","raw_url":"https://github.com/golang/go/raw/a8ba40823c08508ca5f7562501a26bc2e85c88eb/src/pkg/crypto/rsa/pkcs1v15_test.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/pkg/crypto/rsa/pkcs1v15_test.go?ref=a8ba40823c08508ca5f7562501a26bc2e85c88eb","patch":"@@ -7,7 +7,9 @@ package rsa\n import (\n \t\"big\";\n \t\"bytes\";\n+\t\"crypto/sha1\";\n \t\"encoding/base64\";\n+\t\"encoding/hex\";\n \t\"os\";\n \t\"io\";\n \t\"strings\";\n@@ -154,6 +156,49 @@ func TestNonZeroRandomBytes(t *testing.T) {\n \t}\n }\n \n+type signPKCS1v15Test struct {\n+\tin, out string;\n+}\n+\n+// These vectors have been tested with\n+//   `openssl rsautl -verify -inkey pk -in signature | hexdump -C`\n+var signPKCS1v15Tests = []signPKCS1v15Test{\n+\tsignPKCS1v15Test{\"Test.\\n\", \"a4f3fa6ea93bcdd0c57be020c1193ecbfd6f200a3d95c409769b029578fa0e336ad9a347600e40d3ae823b8c7e6bad88cc07c1d54c3a1523cbbb6d58efc362ae\"},\n+}\n+\n+func TestSignPKCS1v15(t *testing.T) {\n+\tfor i, test := range signPKCS1v15Tests {\n+\t\th := sha1.New();\n+\t\th.Write(strings.Bytes(test.in));\n+\t\tdigest := h.Sum();\n+\n+\t\ts, err := SignPKCS1v15(nil, rsaPrivateKey, HashSHA1, digest);\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d %s\", i, err)\n+\t\t}\n+\n+\t\texpected, _ := hex.DecodeString(test.out);\n+\t\tif bytes.Compare(s, expected) != 0 {\n+\t\t\tt.Errorf(\"#%d got: %x want: %x\", i, s, expected)\n+\t\t}\n+\t}\n+}\n+\n+func TestVerifyPKCS1v15(t *testing.T) {\n+\tfor i, test := range signPKCS1v15Tests {\n+\t\th := sha1.New();\n+\t\th.Write(strings.Bytes(test.in));\n+\t\tdigest := h.Sum();\n+\n+\t\tsig, _ := hex.DecodeString(test.out);\n+\n+\t\terr := VerifyPKCS1v15(&rsaPrivateKey.PublicKey, HashSHA1, digest, sig);\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d %s\", i, err)\n+\t\t}\n+\t}\n+}\n+\n func bigFromString(s string) *big.Int {\n \tret := new(big.Int);\n \tret.SetString(s, 10);"},{"sha":"e73aaf1e6f08d666bdc3b39f1f83cac80ec4ce38","filename":"src/pkg/crypto/rsa/rsa.go","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/golang/go/blob/a8ba40823c08508ca5f7562501a26bc2e85c88eb/src/pkg/crypto/rsa/rsa.go","raw_url":"https://github.com/golang/go/raw/a8ba40823c08508ca5f7562501a26bc2e85c88eb/src/pkg/crypto/rsa/rsa.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/pkg/crypto/rsa/rsa.go?ref=a8ba40823c08508ca5f7562501a26bc2e85c88eb","patch":"@@ -288,6 +288,12 @@ type DecryptionError struct{}\n \n func (DecryptionError) String() string\t{ return \"RSA decryption error\" }\n \n+// A VerificationError represents a failure to verify a signature.\n+// It is deliberately vague to avoid adaptive attacks.\n+type VerificationError struct{}\n+\n+func (VerificationError) String() string\t{ return \"RSA verification error\" }\n+\n // modInverse returns ia, the inverse of a in the multiplicative group of prime\n // order n. It requires that a be a member of the group (i.e. less than n).\n func modInverse(a, n *big.Int) (ia *big.Int, ok bool) {"}]}