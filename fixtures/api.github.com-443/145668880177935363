GET /repos/golang/go/commits/309e16554aab1686c5bb744cababfbaa2d83db4d?access_token=token
host: api.github.com
accept: application/vnd.github.v3+json

HTTP/1.1 200 OK
server: GitHub.com
date: Sun, 28 Feb 2016 20:39:30 GMT
content-type: application/json; charset=utf-8
content-length: 27867
connection: close
status: 200 OK
x-ratelimit-limit: 5000
x-ratelimit-remaining: 4780
x-ratelimit-reset: 1456694697
cache-control: private, max-age=60, s-maxage=60
vary: Accept, Authorization, Cookie, X-GitHub-OTP, Accept-Encoding
etag: "4687c7d1345975af4142c87e7c715d05"
last-modified: Fri, 18 Oct 2013 04:53:33 GMT
x-oauth-scopes: public_repo
x-accepted-oauth-scopes: 
x-github-media-type: github.v3; format=json
access-control-allow-credentials: true
access-control-expose-headers: ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval
access-control-allow-origin: *
content-security-policy: default-src 'none'
strict-transport-security: max-age=31536000; includeSubdomains; preload
x-content-type-options: nosniff
x-frame-options: deny
x-xss-protection: 1; mode=block
x-served-by: b0ef53392caa42315c6206737946d931
x-github-request-id: 4E320659:3F84:D110C5:56D35B02

{"sha":"309e16554aab1686c5bb744cababfbaa2d83db4d","commit":{"author":{"name":"Andrew Gerrand","email":"adg@golang.org","date":"2013-10-18T04:53:33Z"},"committer":{"name":"Andrew Gerrand","email":"adg@golang.org","date":"2013-10-18T04:53:33Z"},"message":"go1.2rc2","tree":{"sha":"a3532eb1009338729fe5bf5e4476b35a6c20e3a5","url":"https://api.github.com/repos/golang/go/git/trees/a3532eb1009338729fe5bf5e4476b35a6c20e3a5"},"url":"https://api.github.com/repos/golang/go/git/commits/309e16554aab1686c5bb744cababfbaa2d83db4d","comment_count":0},"url":"https://api.github.com/repos/golang/go/commits/309e16554aab1686c5bb744cababfbaa2d83db4d","html_url":"https://github.com/golang/go/commit/309e16554aab1686c5bb744cababfbaa2d83db4d","comments_url":"https://api.github.com/repos/golang/go/commits/309e16554aab1686c5bb744cababfbaa2d83db4d/comments","author":{"login":"adg","id":8446613,"avatar_url":"https://avatars.githubusercontent.com/u/8446613?v=3","gravatar_id":"","url":"https://api.github.com/users/adg","html_url":"https://github.com/adg","followers_url":"https://api.github.com/users/adg/followers","following_url":"https://api.github.com/users/adg/following{/other_user}","gists_url":"https://api.github.com/users/adg/gists{/gist_id}","starred_url":"https://api.github.com/users/adg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/adg/subscriptions","organizations_url":"https://api.github.com/users/adg/orgs","repos_url":"https://api.github.com/users/adg/repos","events_url":"https://api.github.com/users/adg/events{/privacy}","received_events_url":"https://api.github.com/users/adg/received_events","type":"User","site_admin":false},"committer":{"login":"adg","id":8446613,"avatar_url":"https://avatars.githubusercontent.com/u/8446613?v=3","gravatar_id":"","url":"https://api.github.com/users/adg","html_url":"https://github.com/adg","followers_url":"https://api.github.com/users/adg/followers","following_url":"https://api.github.com/users/adg/following{/other_user}","gists_url":"https://api.github.com/users/adg/gists{/gist_id}","starred_url":"https://api.github.com/users/adg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/adg/subscriptions","organizations_url":"https://api.github.com/users/adg/orgs","repos_url":"https://api.github.com/users/adg/repos","events_url":"https://api.github.com/users/adg/events{/privacy}","received_events_url":"https://api.github.com/users/adg/received_events","type":"User","site_admin":false},"parents":[{"sha":"04e95a1a56c35f63e3ac51c9d9973297a57c2b10","url":"https://api.github.com/repos/golang/go/commits/04e95a1a56c35f63e3ac51c9d9973297a57c2b10","html_url":"https://github.com/golang/go/commit/04e95a1a56c35f63e3ac51c9d9973297a57c2b10"}],"stats":{"total":965,"additions":1,"deletions":964},"files":[{"sha":"5bea254304117f4029a094d56e02a40ebb048ba0","filename":"VERSION","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/golang/go/blob/309e16554aab1686c5bb744cababfbaa2d83db4d/VERSION","raw_url":"https://github.com/golang/go/raw/309e16554aab1686c5bb744cababfbaa2d83db4d/VERSION","contents_url":"https://api.github.com/repos/golang/go/contents/VERSION?ref=309e16554aab1686c5bb744cababfbaa2d83db4d","patch":"@@ -0,0 +1 @@\n+go1.2rc2\n\\ No newline at end of file"},{"sha":"3f528d751750246ccfa3df22e482501702149c38","filename":"src/cmd/prof/Makefile","status":"removed","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/golang/go/blob/04e95a1a56c35f63e3ac51c9d9973297a57c2b10/src/cmd/prof/Makefile","raw_url":"https://github.com/golang/go/raw/04e95a1a56c35f63e3ac51c9d9973297a57c2b10/src/cmd/prof/Makefile","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/prof/Makefile?ref=04e95a1a56c35f63e3ac51c9d9973297a57c2b10","patch":"@@ -1,5 +0,0 @@\n-# Copyright 2012 The Go Authors. All rights reserved.\n-# Use of this source code is governed by a BSD-style\n-# license that can be found in the LICENSE file.\n-\n-include ../../Make.dist"},{"sha":"2640167d3f656d924fb16be6a386bc3736cbc9ab","filename":"src/cmd/prof/doc.go","status":"removed","additions":0,"deletions":49,"changes":49,"blob_url":"https://github.com/golang/go/blob/04e95a1a56c35f63e3ac51c9d9973297a57c2b10/src/cmd/prof/doc.go","raw_url":"https://github.com/golang/go/raw/04e95a1a56c35f63e3ac51c9d9973297a57c2b10/src/cmd/prof/doc.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/prof/doc.go?ref=04e95a1a56c35f63e3ac51c9d9973297a57c2b10","patch":"@@ -1,49 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-\n-Prof is a rudimentary real-time profiler.\n-\n-Given a command to run or the process id (pid) of a command already\n-running, it samples the program's state at regular intervals and reports\n-on its behavior.  With no options, it prints a histogram of the locations\n-in the code that were sampled during execution.\n-\n-Since it is a real-time profiler, unlike a traditional profiler it samples\n-the program's state even when it is not running, such as when it is\n-asleep or waiting for I/O.  Each thread contributes equally to the\n-statistics.\n-\n-Usage:\n-\tgo tool prof -p pid [-t total_secs] [-d delta_msec] [6.out args ...]\n-\n-The output modes (default -h) are:\n-\n-\t-P file.prof:\n-\t\tWrite the profile information to file.prof, in the format used by pprof.\n-\t\tAt the moment, this only works on Linux amd64 binaries and requires that the\n-\t\tbinary be written using 6l -e to produce ELF debug info.\n-\t\tSee http://code.google.com/p/google-perftools for details.\n-\t-h: histograms\n-\t\tHow many times a sample occurred at each location.\n-\t-f: dynamic functions\n-\t\tAt each sample period, print the name of the executing function.\n-\t-l: dynamic file and line numbers\n-\t\tAt each sample period, print the file and line number of the executing instruction.\n-\t-r: dynamic registers\n-\t\tAt each sample period, print the register contents.\n-\t-s: dynamic function stack traces\n-\t\tAt each sample period, print the symbolic stack trace.\n-\n-Flag -t sets the maximum real time to sample, in seconds, and -d\n-sets the sampling interval in milliseconds.  The default is to sample\n-every 100ms until the program completes.\n-\n-It is installed as go tool prof and is architecture-independent.\n-\n-*/\n-package main"},{"sha":"6c591ba180b78c2e488e472b4dd7b212c5038e82","filename":"src/cmd/prof/main.c","status":"removed","additions":0,"deletions":910,"changes":910,"blob_url":"https://github.com/golang/go/blob/04e95a1a56c35f63e3ac51c9d9973297a57c2b10/src/cmd/prof/main.c","raw_url":"https://github.com/golang/go/raw/04e95a1a56c35f63e3ac51c9d9973297a57c2b10/src/cmd/prof/main.c","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/prof/main.c?ref=04e95a1a56c35f63e3ac51c9d9973297a57c2b10","patch":"@@ -1,910 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !plan9\n-\n-#include <u.h>\n-#include <time.h>\n-#include <libc.h>\n-#include <bio.h>\n-#include <ctype.h>\n-\n-#define Ureg Ureg_amd64\n-\t#include <ureg_amd64.h>\n-#undef Ureg\n-#define Ureg Ureg_x86\n-\t#include <ureg_x86.h>\n-#undef Ureg\n-#include <mach.h>\n-\n-char* file = \"6.out\";\n-static Fhdr fhdr;\n-int have_syms;\n-int fd;\n-struct Ureg_amd64 ureg_amd64;\n-struct Ureg_x86 ureg_x86;\n-int total_sec = 0;\n-int delta_msec = 100;\n-int nsample;\n-int nsamplethread;\n-\n-// pprof data, stored as sequences of N followed by N PC values.\n-// See http://code.google.com/p/google-perftools .\n-uvlong\t*ppdata;\t// traces\n-Biobuf*\tpproffd;\t// file descriptor to write trace info\n-long\tppstart;\t// start position of current trace\n-long\tnppdata;\t// length of data\n-long\tppalloc;\t// size of allocated data\n-char\tppmapdata[10*1024];\t// the map information for the output file\n-\n-// output formats\n-int pprof;\t// print pprof output to named file\n-int functions;\t// print functions\n-int histograms;\t// print histograms\n-int linenums;\t// print file and line numbers rather than function names\n-int registers;\t// print registers\n-int stacks;\t\t// print stack traces\n-\n-int pid;\t\t// main process pid\n-\n-int nthread;\t// number of threads\n-int thread[32];\t// thread pids\n-Map *map[32];\t// thread maps\n-\n-void\n-Usage(void)\n-{\n-\tfprint(2, \"Usage: prof -p pid [-t total_secs] [-d delta_msec]\\n\");\n-\tfprint(2, \"       prof [-t total_secs] [-d delta_msec] 6.out args ...\\n\");\n-\tfprint(2, \"\\tformats (default -h):\\n\");\n-\tfprint(2, \"\\t\\t-P file.prof: write [c]pprof output to file.prof\\n\");\n-\tfprint(2, \"\\t\\t-h: histograms\\n\");\n-\tfprint(2, \"\\t\\t-f: dynamic functions\\n\");\n-\tfprint(2, \"\\t\\t-l: dynamic file and line numbers\\n\");\n-\tfprint(2, \"\\t\\t-r: dynamic registers\\n\");\n-\tfprint(2, \"\\t\\t-s: dynamic function stack traces\\n\");\n-\tfprint(2, \"\\t\\t-hs: include stack info in histograms\\n\");\n-\texit(2);\n-}\n-\n-typedef struct PC PC;\n-struct PC {\n-\tuvlong pc;\n-\tuvlong callerpc;\n-\tunsigned int count;\n-\tPC* next;\n-};\n-\n-enum {\n-\tNcounters = 256\n-};\n-\n-PC *counters[Ncounters];\n-\n-// Set up by setarch() to make most of the code architecture-independent.\n-typedef struct Arch Arch;\n-struct Arch {\n-\tchar*\tname;\n-\tvoid\t(*regprint)(void);\n-\tint\t(*getregs)(Map*);\n-\tint\t(*getPC)(Map*);\n-\tint\t(*getSP)(Map*);\n-\tuvlong\t(*uregPC)(void);\n-\tuvlong\t(*uregSP)(void);\n-\tvoid\t(*ppword)(uvlong w);\n-};\n-\n-void\n-amd64_regprint(void)\n-{\n-\tfprint(2, \"ax\\t0x%llux\\n\", ureg_amd64.ax);\n-\tfprint(2, \"bx\\t0x%llux\\n\", ureg_amd64.bx);\n-\tfprint(2, \"cx\\t0x%llux\\n\", ureg_amd64.cx);\n-\tfprint(2, \"dx\\t0x%llux\\n\", ureg_amd64.dx);\n-\tfprint(2, \"si\\t0x%llux\\n\", ureg_amd64.si);\n-\tfprint(2, \"di\\t0x%llux\\n\", ureg_amd64.di);\n-\tfprint(2, \"bp\\t0x%llux\\n\", ureg_amd64.bp);\n-\tfprint(2, \"r8\\t0x%llux\\n\", ureg_amd64.r8);\n-\tfprint(2, \"r9\\t0x%llux\\n\", ureg_amd64.r9);\n-\tfprint(2, \"r10\\t0x%llux\\n\", ureg_amd64.r10);\n-\tfprint(2, \"r11\\t0x%llux\\n\", ureg_amd64.r11);\n-\tfprint(2, \"r12\\t0x%llux\\n\", ureg_amd64.r12);\n-\tfprint(2, \"r13\\t0x%llux\\n\", ureg_amd64.r13);\n-\tfprint(2, \"r14\\t0x%llux\\n\", ureg_amd64.r14);\n-\tfprint(2, \"r15\\t0x%llux\\n\", ureg_amd64.r15);\n-\tfprint(2, \"ds\\t0x%llux\\n\", ureg_amd64.ds);\n-\tfprint(2, \"es\\t0x%llux\\n\", ureg_amd64.es);\n-\tfprint(2, \"fs\\t0x%llux\\n\", ureg_amd64.fs);\n-\tfprint(2, \"gs\\t0x%llux\\n\", ureg_amd64.gs);\n-\tfprint(2, \"type\\t0x%llux\\n\", ureg_amd64.type);\n-\tfprint(2, \"error\\t0x%llux\\n\", ureg_amd64.error);\n-\tfprint(2, \"pc\\t0x%llux\\n\", ureg_amd64.ip);\n-\tfprint(2, \"cs\\t0x%llux\\n\", ureg_amd64.cs);\n-\tfprint(2, \"flags\\t0x%llux\\n\", ureg_amd64.flags);\n-\tfprint(2, \"sp\\t0x%llux\\n\", ureg_amd64.sp);\n-\tfprint(2, \"ss\\t0x%llux\\n\", ureg_amd64.ss);\n-}\n-\n-int\n-amd64_getregs(Map *map)\n-{\n-\tint i;\n-\tunion {\n-\t\tuvlong regs[1];\n-\t\tstruct Ureg_amd64 ureg;\n-\t} u;\n-\n-\tfor(i = 0; i < sizeof ureg_amd64; i+=8) {\n-\t\tif(get8(map, (uvlong)i, &u.regs[i/8]) < 0)\n-\t\t\treturn -1;\n-\t}\n-\tureg_amd64 = u.ureg;\n-\treturn 0;\n-}\n-\n-int\n-amd64_getPC(Map *map)\n-{\n-\tuvlong x;\n-\tint r;\n-\n-\tr = get8(map, offsetof(struct Ureg_amd64, ip), &x);\n-\tureg_amd64.ip = x;\n-\treturn r;\n-}\n-\n-int\n-amd64_getSP(Map *map)\n-{\n-\tuvlong x;\n-\tint r;\n-\n-\tr = get8(map, offsetof(struct Ureg_amd64, sp), &x);\n-\tureg_amd64.sp = x;\n-\treturn r;\n-}\n-\n-uvlong\n-amd64_uregPC(void)\n-{\n-\treturn ureg_amd64.ip;\n-}\n-\n-uvlong\n-amd64_uregSP(void)\n-{\n-\treturn ureg_amd64.sp;\n-}\n-\n-void\n-amd64_ppword(uvlong w)\n-{\n-\tuchar buf[8];\n-\n-\tbuf[0] = w;\n-\tbuf[1] = w >> 8;\n-\tbuf[2] = w >> 16;\n-\tbuf[3] = w >> 24;\n-\tbuf[4] = w >> 32;\n-\tbuf[5] = w >> 40;\n-\tbuf[6] = w >> 48;\n-\tbuf[7] = w >> 56;\n-\tBwrite(pproffd, buf, 8);\n-}\n-\n-void\n-x86_regprint(void)\n-{\n-\tfprint(2, \"ax\\t0x%ux\\n\", ureg_x86.ax);\n-\tfprint(2, \"bx\\t0x%ux\\n\", ureg_x86.bx);\n-\tfprint(2, \"cx\\t0x%ux\\n\", ureg_x86.cx);\n-\tfprint(2, \"dx\\t0x%ux\\n\", ureg_x86.dx);\n-\tfprint(2, \"si\\t0x%ux\\n\", ureg_x86.si);\n-\tfprint(2, \"di\\t0x%ux\\n\", ureg_x86.di);\n-\tfprint(2, \"bp\\t0x%ux\\n\", ureg_x86.bp);\n-\tfprint(2, \"ds\\t0x%ux\\n\", ureg_x86.ds);\n-\tfprint(2, \"es\\t0x%ux\\n\", ureg_x86.es);\n-\tfprint(2, \"fs\\t0x%ux\\n\", ureg_x86.fs);\n-\tfprint(2, \"gs\\t0x%ux\\n\", ureg_x86.gs);\n-\tfprint(2, \"cs\\t0x%ux\\n\", ureg_x86.cs);\n-\tfprint(2, \"flags\\t0x%ux\\n\", ureg_x86.flags);\n-\tfprint(2, \"pc\\t0x%ux\\n\", ureg_x86.pc);\n-\tfprint(2, \"sp\\t0x%ux\\n\", ureg_x86.sp);\n-\tfprint(2, \"ss\\t0x%ux\\n\", ureg_x86.ss);\n-}\n-\n-int\n-x86_getregs(Map *map)\n-{\n-\tint i;\n-\n-\tfor(i = 0; i < sizeof ureg_x86; i+=4) {\n-\t\tif(get4(map, (uvlong)i, &((uint32*)&ureg_x86)[i/4]) < 0)\n-\t\t\treturn -1;\n-\t}\n-\treturn 0;\n-}\n-\n-int\n-x86_getPC(Map* map)\n-{\n-\treturn get4(map, offsetof(struct Ureg_x86, pc), &ureg_x86.pc);\n-}\n-\n-int\n-x86_getSP(Map* map)\n-{\n-\treturn get4(map, offsetof(struct Ureg_x86, sp), &ureg_x86.sp);\n-}\n-\n-uvlong\n-x86_uregPC(void)\n-{\n-\treturn (uvlong)ureg_x86.pc;\n-}\n-\n-uvlong\n-x86_uregSP(void)\n-{\n-\treturn (uvlong)ureg_x86.sp;\n-}\n-\n-void\n-x86_ppword(uvlong w)\n-{\n-\tuchar buf[4];\n-\n-\tbuf[0] = w;\n-\tbuf[1] = w >> 8;\n-\tbuf[2] = w >> 16;\n-\tbuf[3] = w >> 24;\n-\tBwrite(pproffd, buf, 4);\n-}\n-\n-Arch archtab[] = {\n-\t{\n-\t\t\"amd64\",\n-\t\tamd64_regprint,\n-\t\tamd64_getregs,\n-\t\tamd64_getPC,\n-\t\tamd64_getSP,\n-\t\tamd64_uregPC,\n-\t\tamd64_uregSP,\n-\t\tamd64_ppword,\n-\t},\n-\t{\n-\t\t\"386\",\n-\t\tx86_regprint,\n-\t\tx86_getregs,\n-\t\tx86_getPC,\n-\t\tx86_getSP,\n-\t\tx86_uregPC,\n-\t\tx86_uregSP,\n-\t\tx86_ppword,\n-\t},\n-\t{\n-\t\tnil\n-\t}\n-};\n-\n-Arch *arch;\n-\n-int\n-setarch(void)\n-{\n-\tint i;\n-\n-\tif(mach != nil) {\n-\t\tfor(i = 0; archtab[i].name != nil; i++) {\n-\t\t\tif (strcmp(mach->name, archtab[i].name) == 0) {\n-\t\t\t\tarch = &archtab[i];\n-\t\t\t\treturn 0;\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn -1;\n-}\n-\n-int\n-getthreads(void)\n-{\n-\tint i, j, curn, found;\n-\tMap *curmap[nelem(map)];\n-\tint curthread[nelem(map)];\n-\tstatic int complained = 0;\n-\n-\tcurn = procthreadpids(pid, curthread, nelem(curthread));\n-\tif(curn <= 0)\n-\t\treturn curn;\n-\n-\tif(curn > nelem(map)) {\n-\t\tif(complained == 0) {\n-\t\t\tfprint(2, \"prof: too many threads; limiting to %d\\n\", nthread, nelem(map));\n-\t\t\tcomplained = 1;\n-\t\t}\n-\t\tcurn = nelem(map);\n-\t}\n-\tif(curn == nthread && memcmp(thread, curthread, curn*sizeof(*thread)) == 0)\n-\t\treturn curn;\t// no changes\n-\n-\t// Number of threads has changed (might be the init case).\n-\t// A bit expensive but rare enough not to bother being clever.\n-\tfor(i = 0; i < curn; i++) {\n-\t\tfound = 0;\n-\t\tfor(j = 0; j < nthread; j++) {\n-\t\t\tif(curthread[i] == thread[j]) {\n-\t\t\t\tfound = 1;\n-\t\t\t\tcurmap[i] = map[j];\n-\t\t\t\tmap[j] = nil;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\tif(found)\n-\t\t\tcontinue;\n-\n-\t\t// map new thread\n-\t\tcurmap[i] = attachproc(curthread[i], &fhdr);\n-\t\tif(curmap[i] == nil) {\n-\t\t\tfprint(2, \"prof: can't attach to %d: %r\\n\", curthread[i]);\n-\t\t\treturn -1;\n-\t\t}\n-\t}\n-\n-\tfor(j = 0; j < nthread; j++)\n-\t\tif(map[j] != nil)\n-\t\t\tdetachproc(map[j]);\n-\n-\tnthread = curn;\n-\tmemmove(thread, curthread, nthread*sizeof thread[0]);\n-\tmemmove(map, curmap, sizeof map);\n-\treturn nthread;\n-}\n-\n-int\n-sample(Map *map)\n-{\n-\tstatic int n;\n-\n-\tn++;\n-\tif(registers) {\n-\t\tif(arch->getregs(map) < 0)\n-\t\t\tgoto bad;\n-\t} else {\n-\t\t// we need only two registers\n-\t\tif(arch->getPC(map) < 0)\n-\t\t\tgoto bad;\n-\t\tif(arch->getSP(map) < 0)\n-\t\t\tgoto bad;\n-\t}\n-\treturn 1;\n-bad:\n-\tif(n == 1)\n-\t\tfprint(2, \"prof: can't read registers: %r\\n\");\n-\treturn 0;\n-}\n-\n-void\n-addtohistogram(uvlong pc, uvlong callerpc, uvlong sp)\n-{\n-\tint h;\n-\tPC *x;\n-\t\n-\tUSED(sp);\n-\n-\th = (pc + callerpc*101) % Ncounters;\n-\tfor(x = counters[h]; x != NULL; x = x->next) {\n-\t\tif(x->pc == pc && x->callerpc == callerpc) {\n-\t\t\tx->count++;\n-\t\t\treturn;\n-\t\t}\n-\t}\n-\tx = malloc(sizeof(PC));\n-\tif(x == nil)\n-\t\tsysfatal(\"out of memory\");\n-\tx->pc = pc;\n-\tx->callerpc = callerpc;\n-\tx->count = 1;\n-\tx->next = counters[h];\n-\tcounters[h] = x;\n-}\n-\n-void\n-addppword(uvlong pc)\n-{\n-\tif(pc == 0) {\n-\t\treturn;\n-\t}\n-\tif(nppdata == ppalloc) {\n-\t\tppalloc = (1000+nppdata)*2;\n-\t\tppdata = realloc(ppdata, ppalloc * sizeof ppdata[0]);\n-\t\tif(ppdata == nil) {\n-\t\t\tfprint(2, \"prof: realloc failed: %r\\n\");\n-\t\t\texit(2);\n-\t\t}\n-\t}\n-\tppdata[nppdata++] = pc;\n-}\n-\n-void\n-startpptrace(void)\n-{\n-\tppstart = nppdata;\n-\taddppword(~0);\n-}\n-\n-void\n-endpptrace(void)\n-{\n-\tppdata[ppstart] = nppdata-ppstart-1;\n-}\n-\n-uvlong nextpc;\n-\n-void\n-xptrace(Map *map, uvlong pc, uvlong sp, Symbol *sym)\n-{\n-\tUSED(map);\n-\n-\tchar buf[1024];\n-\tif(sym == nil){\n-\t\tfprint(2, \"syms\\n\");\n-\t\treturn;\n-\t}\n-\tif(histograms)\n-\t\taddtohistogram(nextpc, pc, sp);\n-\tif(!histograms || stacks > 1 || pprof) {\n-\t\tif(nextpc == 0)\n-\t\t\tnextpc = sym->value;\n-\t\tif(stacks){\n-\t\t\tfprint(2, \"%s(\", sym->name);\n-\t\t\tfprint(2, \")\");\n-\t\t\tif(nextpc != sym->value)\n-\t\t\t\tfprint(2, \"+%#llux \", nextpc - sym->value);\n-\t\t\tif(have_syms && linenums && fileline(buf, sizeof buf, pc)) {\n-\t\t\t\tfprint(2, \" %s\", buf);\n-\t\t\t}\n-\t\t\tfprint(2, \"\\n\");\n-\t\t}\n-\t\tif (pprof) {\n-\t\t\taddppword(nextpc);\n-\t\t}\n-\t}\n-\tnextpc = pc;\n-}\n-\n-void\n-stacktracepcsp(Map *map, uvlong pc, uvlong sp)\n-{\n-\tnextpc = pc;\n-\tif(pprof){\n-\t\tstartpptrace();\n-\t}\n-\tif(machdata->ctrace==nil)\n-\t\tfprint(2, \"no machdata->ctrace\\n\");\n-\telse if(machdata->ctrace(map, pc, sp, 0, xptrace) <= 0)\n-\t\tfprint(2, \"no stack frame: pc=%#p sp=%#p\\n\", pc, sp);\n-\telse {\n-\t\taddtohistogram(nextpc, 0, sp);\n-\t\tif(stacks)\n-\t\t\tfprint(2, \"\\n\");\n-\t}\n-\tif(pprof){\n-\t\tendpptrace();\n-\t}\n-}\n-\n-void\n-printpc(Map *map, uvlong pc, uvlong sp)\n-{\n-\tchar buf[1024];\n-\tif(registers)\n-\t\tarch->regprint();\n-\tif(have_syms > 0 && linenums &&  fileline(buf, sizeof buf, pc))\n-\t\tfprint(2, \"%s\\n\", buf);\n-\tif(have_syms > 0 && functions) {\n-\t\tsymoff(buf, sizeof(buf), pc, CANY);\n-\t\tfprint(2, \"%s\\n\", buf);\n-\t}\n-\tif(stacks || pprof){\n-\t\tstacktracepcsp(map, pc, sp);\n-\t}\n-\telse if(histograms){\n-\t\taddtohistogram(pc, 0, sp);\n-\t}\n-}\n-\n-void\n-ppmaps(void)\n-{\n-\tint fd, n;\n-\tchar tmp[100];\n-\tSeg *seg;\n-\n-\t// If it's Linux, the info is in /proc/$pid/maps\n-\tsnprint(tmp, sizeof tmp, \"/proc/%d/maps\", pid);\n-\tfd = open(tmp, 0);\n-\tif(fd >= 0) {\n-\t\tn = read(fd, ppmapdata, sizeof ppmapdata - 1);\n-\t\tclose(fd);\n-\t\tif(n < 0) {\n-\t\t\tfprint(2, \"prof: can't read %s: %r\\n\", tmp);\n-\t\t\texit(2);\n-\t\t}\n-\t\tppmapdata[n] = 0;\n-\t\treturn;\n-\t}\n-\n-\t// It's probably a mac. Synthesize an entry for the text file.\n-\t// The register segment may come first but it has a zero offset, so grab the first non-zero offset segment.\n-\tfor(n = 0; n < 3; n++){\n-\t\tseg = &map[0]->seg[n];\n-\t\tif(seg->b == 0) {\n-\t\t\tcontinue;\n-\t\t}\n-\t\tsnprint(ppmapdata, sizeof ppmapdata,\n-\t\t\t\"%.16x-%.16x r-xp %d 00:00 34968549                           %s\\n\",\n-\t\t\tseg->b, seg->e, seg->f, \"/home/r/6.out\"\n-\t\t);\n-\t\treturn;\n-\t}\n-\tfprint(2, \"prof: no text segment in maps for %s\\n\", file);\n-\texit(2);\n-}\n-\n-void\n-samples(void)\n-{\n-\tint i, pid, msec;\n-\tstruct timespec req;\n-\tint getmaps;\n-\n-\treq.tv_sec = delta_msec/1000;\n-\treq.tv_nsec = 1000000*(delta_msec % 1000);\n-\tgetmaps = 0;\n-\tif(pprof)\n-\t\tgetmaps= 1;\n-\tfor(msec = 0; total_sec <= 0 || msec < 1000*total_sec; msec += delta_msec) {\n-\t\tnsample++;\n-\t\tnsamplethread += nthread;\n-\t\tfor(i = 0; i < nthread; i++) {\n-\t\t\tpid = thread[i];\n-\t\t\tif(ctlproc(pid, \"stop\") < 0)\n-\t\t\t\treturn;\n-\t\t\tif(!sample(map[i])) {\n-\t\t\t\tctlproc(pid, \"start\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tprintpc(map[i], arch->uregPC(), arch->uregSP());\n-\t\t\tctlproc(pid, \"start\");\n-\t\t}\n-\t\tnanosleep(&req, NULL);\n-\t\tgetthreads();\n-\t\tif(nthread == 0)\n-\t\t\tbreak;\n-\t\tif(getmaps) {\n-\t\t\tgetmaps = 0;\n-\t\t\tppmaps();\n-\t\t}\n-\t}\n-}\n-\n-typedef struct Func Func;\n-struct Func\n-{\n-\tFunc *next;\n-\tSymbol s;\n-\tuint onstack;\n-\tuint leaf;\n-};\n-\n-Func *func[257];\n-int nfunc;\n-\n-Func*\n-findfunc(uvlong pc)\n-{\n-\tFunc *f;\n-\tuint h;\n-\tSymbol s;\n-\n-\tif(pc == 0)\n-\t\treturn nil;\n-\n-\tif(!findsym(pc, CTEXT, &s))\n-\t\treturn nil;\n-\n-\th = s.value % nelem(func);\n-\tfor(f = func[h]; f != NULL; f = f->next)\n-\t\tif(f->s.value == s.value)\n-\t\t\treturn f;\n-\n-\tf = malloc(sizeof *f);\n-\tif(f == nil)\n-\t\tsysfatal(\"out of memory\");\n-\tmemset(f, 0, sizeof *f);\n-\tf->s = s;\n-\tf->next = func[h];\n-\tfunc[h] = f;\n-\tnfunc++;\n-\treturn f;\n-}\n-\n-int\n-compareleaf(const void *va, const void *vb)\n-{\n-\tFunc *a, *b;\n-\n-\ta = *(Func**)va;\n-\tb = *(Func**)vb;\n-\tif(a->leaf != b->leaf)\n-\t\treturn b->leaf - a->leaf;\n-\tif(a->onstack != b->onstack)\n-\t\treturn b->onstack - a->onstack;\n-\treturn strcmp(a->s.name, b->s.name);\n-}\n-\n-void\n-dumphistogram(void)\n-{\n-\tint i, h, n;\n-\tPC *x;\n-\tFunc *f, **ff;\n-\n-\tif(!histograms)\n-\t\treturn;\n-\n-\t// assign counts to functions.\n-\tfor(h = 0; h < Ncounters; h++) {\n-\t\tfor(x = counters[h]; x != NULL; x = x->next) {\n-\t\t\tf = findfunc(x->pc);\n-\t\t\tif(f) {\n-\t\t\t\tf->onstack += x->count;\n-\t\t\t\tf->leaf += x->count;\n-\t\t\t}\n-\t\t\tf = findfunc(x->callerpc);\n-\t\t\tif(f)\n-\t\t\t\tf->leaf -= x->count;\n-\t\t}\n-\t}\n-\n-\t// build array\n-\tff = malloc(nfunc*sizeof ff[0]);\n-\tif(ff == nil)\n-\t\tsysfatal(\"out of memory\");\n-\tn = 0;\n-\tfor(h = 0; h < nelem(func); h++)\n-\t\tfor(f = func[h]; f != NULL; f = f->next)\n-\t\t\tff[n++] = f;\n-\n-\t// sort by leaf counts\n-\tqsort(ff, nfunc, sizeof ff[0], compareleaf);\n-\n-\t// print.\n-\tfprint(2, \"%d samples (avg %.1g threads)\\n\", nsample, (double)nsamplethread/nsample);\n-\tfor(i = 0; i < nfunc; i++) {\n-\t\tf = ff[i];\n-\t\tfprint(2, \"%6.2f%%\\t\", 100.0*(double)f->leaf/nsample);\n-\t\tif(stacks)\n-\t\t\tfprint(2, \"%6.2f%%\\t\", 100.0*(double)f->onstack/nsample);\n-\t\tfprint(2, \"%s\\n\", f->s.name);\n-\t}\n-}\n-\n-typedef struct Trace Trace;\n-struct Trace {\n-\tint\tcount;\n-\tint\tnpc;\n-\tuvlong\t*pc;\n-\tTrace\t*next;\n-};\n-\n-void\n-dumppprof(void)\n-{\n-\tuvlong i, n, *p, *e;\n-\tint ntrace;\n-\tTrace *trace, *tp, *up, *prev;\n-\n-\tif(!pprof)\n-\t\treturn;\n-\te = ppdata + nppdata;\n-\t// Create list of traces.  First, count the traces\n-\tntrace = 0;\n-\tfor(p = ppdata; p < e;) {\n-\t\tn = *p++;\n-\t\tp += n;\n-\t\tif(n == 0)\n-\t\t\tcontinue;\n-\t\tntrace++;\n-\t}\n-\tif(ntrace <= 0)\n-\t\treturn;\n-\t// Allocate and link the traces together.\n-\ttrace = malloc(ntrace * sizeof(Trace));\n-\tif(trace == nil)\n-\t\tsysfatal(\"out of memory\");\n-\ttp = trace;\n-\tfor(p = ppdata; p < e;) {\n-\t\tn = *p++;\n-\t\tif(n == 0)\n-\t\t\tcontinue;\n-\t\ttp->count = 1;\n-\t\ttp->npc = n;\n-\t\ttp->pc = p;\n-\t\ttp->next = tp+1;\n-\t\ttp++;\n-\t\tp += n;\n-\t}\n-\ttrace[ntrace-1].next = nil;\n-\t// Eliminate duplicates.  Lousy algorithm, although not as bad as it looks because\n-\t// the list collapses fast.\n-\tfor(tp = trace; tp != nil; tp = tp->next) {\n-\t\tprev = tp;\n-\t\tfor(up = tp->next; up != nil; up = up->next) {\n-\t\t\tif(up->npc == tp->npc && memcmp(up->pc, tp->pc, up->npc*sizeof up->pc[0]) == 0) {\n-\t\t\t\ttp->count++;\n-\t\t\t\tprev->next = up->next;\n-\t\t\t} else {\n-\t\t\t\tprev = up;\n-\t\t\t}\n-\t\t}\n-\t}\n-\t// Write file.\n-\t// See http://code.google.com/p/google-perftools/source/browse/trunk/doc/cpuprofile-fileformat.html\n-\t// 1) Header\n-\tarch->ppword(0);\t// must be zero\n-\tarch->ppword(3);\t// 3 words follow in header\n-\tarch->ppword(0);\t// must be zero\n-\tarch->ppword(delta_msec * 1000);\t// sampling period in microseconds\n-\tarch->ppword(0);\t// must be zero (padding)\n-\t// 2) One record for each trace.\n-\tfor(tp = trace; tp != nil; tp = tp->next) {\n-\t\tarch->ppword(tp->count);\n-\t\tarch->ppword(tp->npc);\n-\t\tfor(i = 0; i < tp->npc; i++) {\n-\t\t\tarch->ppword(tp->pc[i]);\n-\t\t}\n-\t}\n-\t// 3) Binary trailer\n-\tarch->ppword(0);\t// must be zero\n-\tarch->ppword(1);\t// must be one\n-\tarch->ppword(0);\t// must be zero\n-\t// 4) Mapped objects.\n-\tBwrite(pproffd, ppmapdata, strlen(ppmapdata));\n-\t// 5) That's it.\n-\tBterm(pproffd);\n-}\n-\n-int\n-startprocess(char **argv)\n-{\n-\tint pid;\n-\n-\tif((pid = fork()) == 0) {\n-\t\tpid = getpid();\n-\t\tif(ctlproc(pid, \"hang\") < 0){\n-\t\t\tfprint(2, \"prof: child process could not hang\\n\");\n-\t\t\texits(0);\n-\t\t}\n-\t\texecv(argv[0], argv);\n-\t\tfprint(2, \"prof: could not exec %s: %r\\n\", argv[0]);\n-\t\texits(0);\n-\t}\n-\n-\tif(pid == -1) {\n-\t\tfprint(2, \"prof: could not fork\\n\");\n-\t\texit(1);\n-\t}\n-\tif(ctlproc(pid, \"attached\") < 0 || ctlproc(pid, \"waitstop\") < 0) {\n-\t\tfprint(2, \"prof: could not attach to child process: %r\\n\");\n-\t\texit(1);\n-\t}\n-\treturn pid;\n-}\n-\n-void\n-detach(void)\n-{\n-\tint i;\n-\n-\tfor(i = 0; i < nthread; i++)\n-\t\tdetachproc(map[i]);\n-}\n-\n-int\n-main(int argc, char *argv[])\n-{\n-\tint i;\n-\tchar *ppfile;\n-\n-\tARGBEGIN{\n-\tcase 'P':\n-\t\tpprof =1;\n-\t\tppfile = EARGF(Usage());\n-\t\tpproffd = Bopen(ppfile, OWRITE);\n-\t\tif(pproffd == nil) {\n-\t\t\tfprint(2, \"prof: cannot open %s: %r\\n\", ppfile);\n-\t\t\texit(2);\n-\t\t}\n-\t\tbreak;\n-\tcase 'd':\n-\t\tdelta_msec = atoi(EARGF(Usage()));\n-\t\tbreak;\n-\tcase 't':\n-\t\ttotal_sec = atoi(EARGF(Usage()));\n-\t\tbreak;\n-\tcase 'p':\n-\t\tpid = atoi(EARGF(Usage()));\n-\t\tbreak;\n-\tcase 'f':\n-\t\tfunctions = 1;\n-\t\tbreak;\n-\tcase 'h':\n-\t\thistograms = 1;\n-\t\tbreak;\n-\tcase 'l':\n-\t\tlinenums = 1;\n-\t\tbreak;\n-\tcase 'r':\n-\t\tregisters = 1;\n-\t\tbreak;\n-\tcase 's':\n-\t\tstacks++;\n-\t\tbreak;\n-\tdefault:\n-\t\tUsage();\n-\t}ARGEND\n-\tif(pid <= 0 && argc == 0)\n-\t\tUsage();\n-\tif(functions+linenums+registers+stacks+pprof == 0)\n-\t\thistograms = 1;\n-\tif(!machbyname(\"amd64\")) {\n-\t\tfprint(2, \"prof: no amd64 support\\n\", pid);\n-\t\texit(1);\n-\t}\n-\tif(argc > 0)\n-\t\tfile = argv[0];\n-\telse if(pid) {\n-\t\tfile = proctextfile(pid);\n-\t\tif (file == NULL) {\n-\t\t\tfprint(2, \"prof: can't find file for pid %d: %r\\n\", pid);\n-\t\t\tfprint(2, \"prof: on Darwin, need to provide file name explicitly\\n\");\n-\t\t\texit(1);\n-\t\t}\n-\t}\n-\tfd = open(file, 0);\n-\tif(fd < 0) {\n-\t\tfprint(2, \"prof: can't open %s: %r\\n\", file);\n-\t\texit(1);\n-\t}\n-\tif(crackhdr(fd, &fhdr)) {\n-\t\thave_syms = syminit(fd, &fhdr);\n-\t\tif(!have_syms) {\n-\t\t\tfprint(2, \"prof: no symbols for %s: %r\\n\", file);\n-\t\t}\n-\t} else {\n-\t\tfprint(2, \"prof: crack header for %s: %r\\n\", file);\n-\t\texit(1);\n-\t}\n-\tif(pid <= 0)\n-\t\tpid = startprocess(argv);\n-\tattachproc(pid, &fhdr);\t// initializes thread list\n-\tif(setarch() < 0) {\n-\t\tdetach();\n-\t\tfprint(2, \"prof: can't identify binary architecture for pid %d\\n\", pid);\n-\t\texit(1);\n-\t}\n-\tif(getthreads() <= 0) {\n-\t\tdetach();\n-\t\tfprint(2, \"prof: can't find threads for pid %d\\n\", pid);\n-\t\texit(1);\n-\t}\n-\tfor(i = 0; i < nthread; i++)\n-\t\tctlproc(thread[i], \"start\");\n-\tsamples();\n-\tdetach();\n-\tdumphistogram();\n-\tdumppprof();\n-\texit(0);\n-}"}]}