GET /repos/golang/go/commits/1c5438aae896edcd1e9f9618f4776517f08053b3?access_token=token
host: api.github.com
accept: application/vnd.github.v3+json

HTTP/1.1 200 OK
server: GitHub.com
date: Sun, 28 Feb 2016 20:39:43 GMT
content-type: application/json; charset=utf-8
content-length: 51381
connection: close
status: 200 OK
x-ratelimit-limit: 5000
x-ratelimit-remaining: 4770
x-ratelimit-reset: 1456694697
cache-control: private, max-age=60, s-maxage=60
vary: Accept, Authorization, Cookie, X-GitHub-OTP, Accept-Encoding
etag: "1eaaa67b80c2ffe4ab4916cf99044ced"
last-modified: Tue, 07 May 2013 00:33:44 GMT
x-oauth-scopes: public_repo
x-accepted-oauth-scopes: 
x-github-media-type: github.v3; format=json
access-control-allow-credentials: true
access-control-expose-headers: ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval
access-control-allow-origin: *
content-security-policy: default-src 'none'
strict-transport-security: max-age=31536000; includeSubdomains; preload
x-content-type-options: nosniff
x-frame-options: deny
x-xss-protection: 1; mode=block
x-served-by: dc1ce2bfb41810a06c705e83b388572d
x-github-request-id: 4E320659:3F85:118818B:56D35B0F

{"sha":"1c5438aae896edcd1e9f9618f4776517f08053b3","commit":{"author":{"name":"Andrew Gerrand","email":"adg@golang.org","date":"2013-05-07T00:33:44Z"},"committer":{"name":"Andrew Gerrand","email":"adg@golang.org","date":"2013-05-07T00:33:44Z"},"message":"go1.1rc2","tree":{"sha":"7d2f489e27c89279743243f6df58cb88f5c30e0b","url":"https://api.github.com/repos/golang/go/git/trees/7d2f489e27c89279743243f6df58cb88f5c30e0b"},"url":"https://api.github.com/repos/golang/go/git/commits/1c5438aae896edcd1e9f9618f4776517f08053b3","comment_count":0},"url":"https://api.github.com/repos/golang/go/commits/1c5438aae896edcd1e9f9618f4776517f08053b3","html_url":"https://github.com/golang/go/commit/1c5438aae896edcd1e9f9618f4776517f08053b3","comments_url":"https://api.github.com/repos/golang/go/commits/1c5438aae896edcd1e9f9618f4776517f08053b3/comments","author":{"login":"adg","id":8446613,"avatar_url":"https://avatars.githubusercontent.com/u/8446613?v=3","gravatar_id":"","url":"https://api.github.com/users/adg","html_url":"https://github.com/adg","followers_url":"https://api.github.com/users/adg/followers","following_url":"https://api.github.com/users/adg/following{/other_user}","gists_url":"https://api.github.com/users/adg/gists{/gist_id}","starred_url":"https://api.github.com/users/adg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/adg/subscriptions","organizations_url":"https://api.github.com/users/adg/orgs","repos_url":"https://api.github.com/users/adg/repos","events_url":"https://api.github.com/users/adg/events{/privacy}","received_events_url":"https://api.github.com/users/adg/received_events","type":"User","site_admin":false},"committer":{"login":"adg","id":8446613,"avatar_url":"https://avatars.githubusercontent.com/u/8446613?v=3","gravatar_id":"","url":"https://api.github.com/users/adg","html_url":"https://github.com/adg","followers_url":"https://api.github.com/users/adg/followers","following_url":"https://api.github.com/users/adg/following{/other_user}","gists_url":"https://api.github.com/users/adg/gists{/gist_id}","starred_url":"https://api.github.com/users/adg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/adg/subscriptions","organizations_url":"https://api.github.com/users/adg/orgs","repos_url":"https://api.github.com/users/adg/repos","events_url":"https://api.github.com/users/adg/events{/privacy}","received_events_url":"https://api.github.com/users/adg/received_events","type":"User","site_admin":false},"parents":[{"sha":"9e93d5014e6a2e0ef9daf89489c7b12531fc95f3","url":"https://api.github.com/repos/golang/go/commits/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3","html_url":"https://github.com/golang/go/commit/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3"}],"stats":{"total":1782,"additions":1,"deletions":1781},"files":[{"sha":"f02a1e8c7039d2353dde67875992eee49ac74814","filename":"VERSION","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/golang/go/blob/1c5438aae896edcd1e9f9618f4776517f08053b3/VERSION","raw_url":"https://github.com/golang/go/raw/1c5438aae896edcd1e9f9618f4776517f08053b3/VERSION","contents_url":"https://api.github.com/repos/golang/go/contents/VERSION?ref=1c5438aae896edcd1e9f9618f4776517f08053b3","patch":"@@ -0,0 +1 @@\n+go1.1rc2\n\\ No newline at end of file"},{"sha":"3f528d751750246ccfa3df22e482501702149c38","filename":"src/cmd/cov/Makefile","status":"removed","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/golang/go/blob/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/cov/Makefile","raw_url":"https://github.com/golang/go/raw/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/cov/Makefile","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/cov/Makefile?ref=9e93d5014e6a2e0ef9daf89489c7b12531fc95f3","patch":"@@ -1,5 +0,0 @@\n-# Copyright 2012 The Go Authors. All rights reserved.\n-# Use of this source code is governed by a BSD-style\n-# license that can be found in the LICENSE file.\n-\n-include ../../Make.dist"},{"sha":"ab5d1220ad5976f86824ea2de53139ce08a1b82e","filename":"src/cmd/cov/doc.go","status":"removed","additions":0,"deletions":36,"changes":36,"blob_url":"https://github.com/golang/go/blob/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/cov/doc.go","raw_url":"https://github.com/golang/go/raw/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/cov/doc.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/cov/doc.go?ref=9e93d5014e6a2e0ef9daf89489c7b12531fc95f3","patch":"@@ -1,36 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-\n-Cov is a rudimentary code coverage tool.\n-\n-Usage:\n-\tgo tool cov [-lsv] [-g substring] [-m minlines] [6.out args]\n-\n-Given a command to run, it runs the command while tracking which\n-sections of code have been executed.  When the command finishes,\n-cov prints the line numbers of sections of code in the binary that\n-were not executed.   With no arguments it assumes the command \"6.out\".\n-\n-\n-The options are:\n-\n-\t-l\n-\t\tprint full path names instead of paths relative to the current directory\n-\t-s\n-\t\tshow the source code that didn't execute, in addition to the line numbers.\n-\t-v\n-\t\tprint debugging information during the run.\n-\t-g substring\n-\t\trestrict the coverage analysis to functions or files whose names contain substring\n-\t-m minlines\n-\t\tonly report uncovered sections of code larger than minlines lines\n-\n-The program is the same for all architectures: 386, amd64, and arm.\n-\n-*/\n-package main"},{"sha":"33ef49e17d599ee1220eba2ac80fd7e5c6444c81","filename":"src/cmd/cov/main.c","status":"removed","additions":0,"deletions":484,"changes":484,"blob_url":"https://github.com/golang/go/blob/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/cov/main.c","raw_url":"https://github.com/golang/go/raw/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/cov/main.c","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/cov/main.c?ref=9e93d5014e6a2e0ef9daf89489c7b12531fc95f3","patch":"@@ -1,484 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-/*\n- * code coverage\n- */\n-\n-#include <u.h>\n-#include <libc.h>\n-#include <bio.h>\n-#include \"tree.h\"\n-\n-#include <ureg_amd64.h>\n-#include <mach.h>\n-typedef struct Ureg Ureg;\n-\n-void\n-usage(void)\n-{\n-\tfprint(2, \"usage: cov [-lsv] [-g substring] [-m minlines] [6.out args...]\\n\");\n-\tfprint(2, \"-g specifies pattern of interesting functions or files\\n\");\n-\texits(\"usage\");\n-}\n-\n-typedef struct Range Range;\n-struct Range\n-{\n-\tuvlong pc;\n-\tuvlong epc;\n-};\n-\n-int chatty;\n-int fd;\n-int longnames;\n-int pid;\n-int doshowsrc;\n-Map *mem;\n-Map *text;\n-Fhdr fhdr;\n-char *substring;\n-char cwd[1000];\n-int ncwd;\n-int minlines = -1000;\n-\n-Tree breakpoints;\t// code ranges not run\n-\n-/*\n- * comparison for Range structures\n- * they are \"equal\" if they overlap, so\n- * that a search for [pc, pc+1) finds the\n- * Range containing pc.\n- */\n-int\n-rangecmp(void *va, void *vb)\n-{\n-\tRange *a = va, *b = vb;\n-\tif(a->epc <= b->pc)\n-\t\treturn 1;\n-\tif(b->epc <= a->pc)\n-\t\treturn -1;\n-\treturn 0;\n-}\n-\n-/*\n- * remember that we ran the section of code [pc, epc).\n- */\n-void\n-ran(uvlong pc, uvlong epc)\n-{\n-\tRange key;\n-\tRange *r;\n-\tuvlong oldepc;\n-\n-\tif(chatty)\n-\t\tprint(\"run %#llux-%#llux\\n\", pc, epc);\n-\n-\tkey.pc = pc;\n-\tkey.epc = pc+1;\n-\tr = treeget(&breakpoints, &key);\n-\tif(r == nil)\n-\t\tsysfatal(\"unchecked breakpoint at %#llux+%d\", pc, (int)(epc-pc));\n-\n-\t// Might be that the tail of the sequence\n-\t// was run already, so r->epc is before the end.\n-\t// Adjust len.\n-\tif(epc > r->epc)\n-\t\tepc = r->epc;\n-\n-\tif(r->pc == pc) {\n-\t\tr->pc = epc;\n-\t} else {\n-\t\t// Chop r to before pc;\n-\t\t// add new entry for after if needed.\n-\t\t// Changing r->epc does not affect r's position in the tree.\n-\t\toldepc = r->epc;\n-\t\tr->epc = pc;\n-\t\tif(epc < oldepc) {\n-\t\t\tRange *n;\n-\t\t\tn = malloc(sizeof *n);\n-\t\t\tif(n == nil)\n-\t\t\t\tsysfatal(\"out of memory\");\n-\t\t\tn->pc = epc;\n-\t\t\tn->epc = oldepc;\n-\t\t\ttreeput(&breakpoints, n, n);\n-\t\t}\n-\t}\n-}\n-\n-void\n-showsrc(char *file, int line1, int line2)\n-{\n-\tBiobuf *b;\n-\tchar *p;\n-\tint n, stop;\n-\n-\tif((b = Bopen(file, OREAD)) == nil) {\n-\t\tprint(\"\\topen %s: %r\\n\", file);\n-\t\treturn;\n-\t}\n-\n-\tfor(n=1; n<line1 && (p = Brdstr(b, '\\n', 1)) != nil; n++)\n-\t\tfree(p);\n-\n-\t// print up to five lines (this one and 4 more).\n-\t// if there are more than five lines, print 4 and \"...\"\n-\tstop = n+4;\n-\tif(stop > line2)\n-\t\tstop = line2;\n-\tif(stop < line2)\n-\t\tstop--;\n-\tfor(; n<=stop && (p = Brdstr(b, '\\n', 1)) != nil; n++) {\n-\t\tprint(\"  %d %s\\n\", n, p);\n-\t\tfree(p);\n-\t}\n-\tif(n < line2)\n-\t\tprint(\"  ...\\n\");\n-\tBterm(b);\n-}\n-\n-/*\n- * if s is in the current directory or below,\n- * return the relative path.\n- */\n-char*\n-shortname(char *s)\n-{\n-\tif(!longnames && strlen(s) > ncwd && memcmp(s, cwd, ncwd) == 0 && s[ncwd] == '/')\n-\t\treturn s+ncwd+1;\n-\treturn s;\n-}\n-\n-/*\n- * we've decided that [pc, epc) did not run.\n- * do something about it.\n- */\n-void\n-missing(uvlong pc, uvlong epc)\n-{\n-\tchar file[1000];\n-\tint line1, line2;\n-\tchar buf[100];\n-\tSymbol s;\n-\tchar *p;\n-\tuvlong uv;\n-\n-\tif(!findsym(pc, CTEXT, &s) || !fileline(file, sizeof file, pc)) {\n-\tnotfound:\n-\t\tprint(\"%#llux-%#llux\\n\", pc, epc);\n-\t\treturn;\n-\t}\n-\tp = strrchr(file, ':');\n-\t*p++ = 0;\n-\tline1 = atoi(p);\n-\tfor(uv=pc; uv<epc; ) {\n-\t\tif(!fileline(file, sizeof file, epc-2))\n-\t\t\tgoto notfound;\n-\t\tuv += machdata->instsize(text, uv);\n-\t}\n-\tp = strrchr(file, ':');\n-\t*p++ = 0;\n-\tline2 = atoi(p);\n-\n-\tif(line2+1-line2 < minlines)\n-\t\treturn;\n-\n-\tif(pc == s.value) {\n-\t\t// never entered function\n-\t\tprint(\"%s:%d %s never called (%#llux-%#llux)\\n\", shortname(file), line1, s.name, pc, epc);\n-\t\treturn;\n-\t}\n-\tif(pc <= s.value+13) {\n-\t\t// probably stub for stack growth.\n-\t\t// check whether last instruction is call to morestack.\n-\t\t// the -5 below is the length of\n-\t\t//\tCALL sys.morestack.\n-\t\tbuf[0] = 0;\n-\t\tmachdata->das(text, epc-5, 0, buf, sizeof buf);\n-\t\tif(strstr(buf, \"morestack\"))\n-\t\t\treturn;\n-\t}\n-\n-\tif(epc - pc == 5) {\n-\t\t// check for CALL sys.panicindex\n-\t\tbuf[0] = 0;\n-\t\tmachdata->das(text, pc, 0, buf, sizeof buf);\n-\t\tif(strstr(buf, \"panicindex\"))\n-\t\t\treturn;\n-\t}\n-\n-\tif(epc - pc == 2 || epc -pc == 3) {\n-\t\t// check for XORL inside shift.\n-\t\t// (on x86 have to implement large left or unsigned right shift with explicit zeroing).\n-\t\t//\tf+90 0x00002c9f\tCMPL\tCX,$20\n-\t\t//\tf+93 0x00002ca2\tJCS\tf+97(SB)\n-\t\t//\tf+95 0x00002ca4\tXORL\tAX,AX <<<\n-\t\t//\tf+97 0x00002ca6\tSHLL\tCL,AX\n-\t\t//\tf+99 0x00002ca8\tMOVL\t$1,CX\n-\t\t//\n-\t\t//\tf+c8 0x00002cd7\tCMPL\tCX,$40\n-\t\t//\tf+cb 0x00002cda\tJCS\tf+d0(SB)\n-\t\t//\tf+cd 0x00002cdc\tXORQ\tAX,AX <<<\n-\t\t//\tf+d0 0x00002cdf\tSHLQ\tCL,AX\n-\t\t//\tf+d3 0x00002ce2\tMOVQ\t$1,CX\n-\t\tbuf[0] = 0;\n-\t\tmachdata->das(text, pc, 0, buf, sizeof buf);\n-\t\tif(strncmp(buf, \"XOR\", 3) == 0) {\n-\t\t\tmachdata->das(text, epc, 0, buf, sizeof buf);\n-\t\t\tif(strncmp(buf, \"SHL\", 3) == 0 || strncmp(buf, \"SHR\", 3) == 0)\n-\t\t\t\treturn;\n-\t\t}\n-\t}\n-\n-\tif(epc - pc == 3) {\n-\t\t// check for SAR inside shift.\n-\t\t// (on x86 have to implement large signed right shift as >>31).\n-\t\t//\tf+36 0x00016216\tCMPL\tCX,$20\n-\t\t//\tf+39 0x00016219\tJCS\tf+3e(SB)\n-\t\t//\tf+3b 0x0001621b\tSARL\t$1f,AX <<<\n-\t\t//\tf+3e 0x0001621e\tSARL\tCL,AX\n-\t\t//\tf+40 0x00016220\tXORL\tCX,CX\n-\t\t//\tf+42 0x00016222\tCMPL\tCX,AX\n-\t\tbuf[0] = 0;\n-\t\tmachdata->das(text, pc, 0, buf, sizeof buf);\n-\t\tif(strncmp(buf, \"SAR\", 3) == 0) {\n-\t\t\tmachdata->das(text, epc, 0, buf, sizeof buf);\n-\t\t\tif(strncmp(buf, \"SAR\", 3) == 0)\n-\t\t\t\treturn;\n-\t\t}\n-\t}\n-\n-\t// show first instruction to make clear where we were.\n-\tmachdata->das(text, pc, 0, buf, sizeof buf);\n-\n-\tif(line1 != line2)\n-\t\tprint(\"%s:%d,%d %#llux-%#llux %s\\n\",\n-\t\t\tshortname(file), line1, line2, pc, epc, buf);\n-\telse\n-\t\tprint(\"%s:%d %#llux-%#llux %s\\n\",\n-\t\t\tshortname(file), line1, pc, epc, buf);\n-\tif(doshowsrc)\n-\t\tshowsrc(file, line1, line2);\n-}\n-\n-/*\n- * walk the tree, calling missing for each non-empty\n- * section of missing code.\n- */\n-void\n-walktree(TreeNode *t)\n-{\n-\tRange *n;\n-\n-\tif(t == nil)\n-\t\treturn;\n-\twalktree(t->left);\n-\tn = t->key;\n-\tif(n->pc < n->epc)\n-\t\tmissing(n->pc, n->epc);\n-\twalktree(t->right);\n-}\n-\n-/*\n- * set a breakpoint all over [pc, epc)\n- * and remember that we did.\n- */\n-void\n-breakpoint(uvlong pc, uvlong epc)\n-{\n-\tRange *r;\n-\n-\tr = malloc(sizeof *r);\n-\tif(r == nil)\n-\t\tsysfatal(\"out of memory\");\n-\tr->pc = pc;\n-\tr->epc = epc;\n-\ttreeput(&breakpoints, r, r);\n-\n-\tfor(; pc < epc; pc+=machdata->bpsize)\n-\t\tput1(mem, pc, machdata->bpinst, machdata->bpsize);\n-}\n-\n-/*\n- * install breakpoints over all text symbols\n- * that match the pattern.\n- */\n-void\n-cover(void)\n-{\n-\tSymbol s;\n-\tchar *lastfn;\n-\tuvlong lastpc;\n-\tint i;\n-\tchar buf[200];\n-\n-\tlastfn = nil;\n-\tlastpc = 0;\n-\tfor(i=0; textsym(&s, i); i++) {\n-\t\tswitch(s.type) {\n-\t\tcase 'T':\n-\t\tcase 't':\n-\t\t\tif(lastpc != 0) {\n-\t\t\t\tbreakpoint(lastpc, s.value);\n-\t\t\t\tlastpc = 0;\n-\t\t\t}\n-\t\t\t// Ignore second entry for a given name;\n-\t\t\t// that's the debugging blob.\n-\t\t\tif(lastfn && strcmp(s.name, lastfn) == 0)\n-\t\t\t\tbreak;\n-\t\t\tlastfn = s.name;\n-\t\t\tbuf[0] = 0;\n-\t\t\tfileline(buf, sizeof buf, s.value);\n-\t\t\tif(substring == nil || strstr(buf, substring) || strstr(s.name, substring))\n-\t\t\t\tlastpc = s.value;\n-\t\t}\n-\t}\n-}\n-\n-uvlong\n-rgetzero(Map *map, char *reg)\n-{\n-\tUSED(map);\n-\tUSED(reg);\n-\n-\treturn 0;\n-}\n-\n-/*\n- * remove the breakpoints at pc and successive instructions,\n- * up to and including the first jump or other control flow transfer.\n- */\n-void\n-uncover(uvlong pc)\n-{\n-\tuchar buf[1000];\n-\tint n, n1, n2;\n-\tuvlong foll[2];\n-\n-\t// Double-check that we stopped at a breakpoint.\n-\tif(get1(mem, pc, buf, machdata->bpsize) < 0)\n-\t\tsysfatal(\"read mem inst at %#llux: %r\", pc);\n-\tif(memcmp(buf, machdata->bpinst, machdata->bpsize) != 0)\n-\t\tsysfatal(\"stopped at %#llux; not at breakpoint %d\", pc, machdata->bpsize);\n-\n-\t// Figure out how many bytes of straight-line code\n-\t// there are in the text starting at pc.\n-\tn = 0;\n-\twhile(n < sizeof buf) {\n-\t\tn1 = machdata->instsize(text, pc+n);\n-\t\tif(n+n1 > sizeof buf)\n-\t\t\tbreak;\n-\t\tn2 = machdata->foll(text, pc+n, rgetzero, foll);\n-\t\tn += n1;\n-\t\tif(n2 != 1 || foll[0] != pc+n)\n-\t\t\tbreak;\n-\t}\n-\n-\t// Record that this section of code ran.\n-\tran(pc, pc+n);\n-\n-\t// Put original instructions back.\n-\tif(get1(text, pc, buf, n) < 0)\n-\t\tsysfatal(\"get1: %r\");\n-\tif(put1(mem, pc, buf, n) < 0)\n-\t\tsysfatal(\"put1: %r\");\n-}\n-\n-int\n-startprocess(char **argv)\n-{\n-\tint pid;\n-\n-\tif((pid = fork()) < 0)\n-\t\tsysfatal(\"fork: %r\");\n-\tif(pid == 0) {\n-\t\tpid = getpid();\n-\t\tif(ctlproc(pid, \"hang\") < 0)\n-\t\t\tsysfatal(\"ctlproc hang: %r\");\n-\t\texec(argv[0], argv);\n-\t\tsysfatal(\"exec %s: %r\", argv[0]);\n-\t}\n-\tif(ctlproc(pid, \"attached\") < 0 || ctlproc(pid, \"waitstop\") < 0)\n-\t\tsysfatal(\"attach %d %s: %r\", pid, argv[0]);\n-\treturn pid;\n-}\n-\n-int\n-go(void)\n-{\n-\tuvlong pc;\n-\tchar buf[100];\n-\tint n;\n-\n-\tfor(n = 0;; n++) {\n-\t\tctlproc(pid, \"startstop\");\n-\t\tif(get8(mem, offsetof(Ureg, ip), &pc) < 0) {\n-\t\t\trerrstr(buf, sizeof buf);\n-\t\t\tif(strstr(buf, \"exited\") || strstr(buf, \"No such process\"))\n-\t\t\t\treturn n;\n-\t\t\tsysfatal(\"cannot read pc: %r\");\n-\t\t}\n-\t\tpc--;\n-\t\tif(put8(mem, offsetof(Ureg, ip), pc) < 0)\n-\t\t\tsysfatal(\"cannot write pc: %r\");\n-\t\tuncover(pc);\n-\t}\n-}\n-\n-void\n-main(int argc, char **argv)\n-{\n-\tint n;\n-\n-\tARGBEGIN{\n-\tcase 'g':\n-\t\tsubstring = EARGF(usage());\n-\t\tbreak;\n-\tcase 'l':\n-\t\tlongnames++;\n-\t\tbreak;\n-\tcase 'n':\n-\t\tminlines = atoi(EARGF(usage()));\n-\t\tbreak;\n-\tcase 's':\n-\t\tdoshowsrc = 1;\n-\t\tbreak;\n-\tcase 'v':\n-\t\tchatty++;\n-\t\tbreak;\n-\tdefault:\n-\t\tusage();\n-\t}ARGEND\n-\n-\tgetwd(cwd, sizeof cwd);\n-\tncwd = strlen(cwd);\n-\n-\tif(argc == 0) {\n-\t\t*--argv = \"6.out\";\n-\t}\n-\tfd = open(argv[0], OREAD);\n-\tif(fd < 0)\n-\t\tsysfatal(\"open %s: %r\", argv[0]);\n-\tif(crackhdr(fd, &fhdr) <= 0)\n-\t\tsysfatal(\"crackhdr: %r\");\n-\tmachbytype(fhdr.type);\n-\tif(syminit(fd, &fhdr) <= 0)\n-\t\tsysfatal(\"syminit: %r\");\n-\ttext = loadmap(nil, fd, &fhdr);\n-\tif(text == nil)\n-\t\tsysfatal(\"loadmap: %r\");\n-\tpid = startprocess(argv);\n-\tmem = attachproc(pid, &fhdr);\n-\tif(mem == nil)\n-\t\tsysfatal(\"attachproc: %r\");\n-\tbreakpoints.cmp = rangecmp;\n-\tcover();\n-\tn = go();\n-\twalktree(breakpoints.root);\n-\tif(chatty)\n-\t\tprint(\"%d breakpoints\\n\", n);\n-\tdetachproc(mem);\n-\texits(0);\n-}\n-"},{"sha":"366a47efd48fb297806e980e7bc29e0b0302ae4d","filename":"src/cmd/cov/tree.c","status":"removed","additions":0,"deletions":245,"changes":245,"blob_url":"https://github.com/golang/go/blob/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/cov/tree.c","raw_url":"https://github.com/golang/go/raw/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/cov/tree.c","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/cov/tree.c?ref=9e93d5014e6a2e0ef9daf89489c7b12531fc95f3","patch":"@@ -1,245 +0,0 @@\n-// Renamed from Map to Tree to avoid conflict with libmach.\n-\n-/*\n-Copyright (c) 2003-2007 Russ Cox, Tom Bergan, Austin Clements,\n-\tMassachusetts Institute of Technology\n-Portions Copyright (c) 2009 The Go Authors. All rights reserved.\n-\n-Permission is hereby granted, free of charge, to any person obtaining\n-a copy of this software and associated documentation files (the\n-\"Software\"), to deal in the Software without restriction, including\n-without limitation the rights to use, copy, modify, merge, publish,\n-distribute, sublicense, and/or sell copies of the Software, and to\n-permit persons to whom the Software is furnished to do so, subject to\n-the following conditions:\n-\n-The above copyright notice and this permission notice shall be\n-included in all copies or substantial portions of the Software.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n-*/\n-\n-// Mutable map structure, but still based on\n-// Okasaki, Red Black Trees in a Functional Setting, JFP 1999,\n-// which is a lot easier than the traditional red-black\n-// and plenty fast enough for me.  (Also I could copy\n-// and edit fmap.c.)\n-\n-#include <u.h>\n-#include <libc.h>\n-#include \"tree.h\"\n-\n-enum\n-{\n-\tRed = 0,\n-\tBlack = 1\n-};\n-\n-\n-// Red-black trees are binary trees with this property:\n-//\t1. No red node has a red parent.\n-//\t2. Every path from the root to a leaf contains the\n-//\t\tsame number of black nodes.\n-\n-static TreeNode*\n-rwTreeNode(TreeNode *p, int color, TreeNode *left, void *key, void *value, TreeNode *right)\n-{\n-\tif(p == nil)\n-\t\tp = malloc(sizeof *p);\n-\tif(p == nil)\n-\t\tsysfatal(\"out of memory\");\n-\tp->color = color;\n-\tp->left = left;\n-\tp->key = key;\n-\tp->value = value;\n-\tp->right = right;\n-\treturn p;\n-}\n-\n-static TreeNode*\n-balance(TreeNode *m0)\n-{\n-\tvoid *xk, *xv, *yk, *yv, *zk, *zv;\n-\tTreeNode *a, *b, *c, *d;\n-\tTreeNode *m1, *m2;\n-\tint color;\n-\tTreeNode *left, *right;\n-\tvoid *key, *value;\n-\n-\tcolor = m0->color;\n-\tleft = m0->left;\n-\tkey = m0->key;\n-\tvalue = m0->value;\n-\tright = m0->right;\n-\n-\t// Okasaki notation: (T is mkTreeNode, B is Black, R is Red, x, y, z are key-value.\n-\t//\n-\t// balance B (T R (T R a x b) y c) z d\n-\t// balance B (T R a x (T R b y c)) z d\n-\t// balance B a x (T R (T R b y c) z d)\n-\t// balance B a x (T R b y (T R c z d))\n-\t//\n-\t//     = T R (T B a x b) y (T B c z d)\n-\n-\tif(color == Black){\n-\t\tif(left && left->color == Red){\n-\t\t\tif(left->left && left->left->color == Red){\n-\t\t\t\ta = left->left->left;\n-\t\t\t\txk = left->left->key;\n-\t\t\t\txv = left->left->value;\n-\t\t\t\tb = left->left->right;\n-\t\t\t\tyk = left->key;\n-\t\t\t\tyv = left->value;\n-\t\t\t\tc = left->right;\n-\t\t\t\tzk = key;\n-\t\t\t\tzv = value;\n-\t\t\t\td = right;\n-\t\t\t\tm1 = left;\n-\t\t\t\tm2 = left->left;\n-\t\t\t\tgoto hard;\n-\t\t\t}else if(left->right && left->right->color == Red){\n-\t\t\t\ta = left->left;\n-\t\t\t\txk = left->key;\n-\t\t\t\txv = left->value;\n-\t\t\t\tb = left->right->left;\n-\t\t\t\tyk = left->right->key;\n-\t\t\t\tyv = left->right->value;\n-\t\t\t\tc = left->right->right;\n-\t\t\t\tzk = key;\n-\t\t\t\tzv = value;\n-\t\t\t\td = right;\n-\t\t\t\tm1 = left;\n-\t\t\t\tm2 = left->right;\n-\t\t\t\tgoto hard;\n-\t\t\t}\n-\t\t}else if(right && right->color == Red){\n-\t\t\tif(right->left && right->left->color == Red){\n-\t\t\t\ta = left;\n-\t\t\t\txk = key;\n-\t\t\t\txv = value;\n-\t\t\t\tb = right->left->left;\n-\t\t\t\tyk = right->left->key;\n-\t\t\t\tyv = right->left->value;\n-\t\t\t\tc = right->left->right;\n-\t\t\t\tzk = right->key;\n-\t\t\t\tzv = right->value;\n-\t\t\t\td = right->right;\n-\t\t\t\tm1 = right;\n-\t\t\t\tm2 = right->left;\n-\t\t\t\tgoto hard;\n-\t\t\t}else if(right->right && right->right->color == Red){\n-\t\t\t\ta = left;\n-\t\t\t\txk = key;\n-\t\t\t\txv = value;\n-\t\t\t\tb = right->left;\n-\t\t\t\tyk = right->key;\n-\t\t\t\tyv = right->value;\n-\t\t\t\tc = right->right->left;\n-\t\t\t\tzk = right->right->key;\n-\t\t\t\tzv = right->right->value;\n-\t\t\t\td = right->right->right;\n-\t\t\t\tm1 = right;\n-\t\t\t\tm2 = right->right;\n-\t\t\t\tgoto hard;\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn rwTreeNode(m0, color, left, key, value, right);\n-\n-hard:\n-\treturn rwTreeNode(m0, Red, rwTreeNode(m1, Black, a, xk, xv, b),\n-\t\tyk, yv, rwTreeNode(m2, Black, c, zk, zv, d));\n-}\n-\n-static TreeNode*\n-ins0(TreeNode *p, void *k, void *v, TreeNode *rw)\n-{\n-\tif(p == nil)\n-\t\treturn rwTreeNode(rw, Red, nil, k, v, nil);\n-\tif(p->key == k){\n-\t\tif(rw)\n-\t\t\treturn rwTreeNode(rw, p->color, p->left, k, v, p->right);\n-\t\tp->value = v;\n-\t\treturn p;\n-\t}\n-\tif(p->key < k)\n-\t\tp->left = ins0(p->left, k, v, rw);\n-\telse\n-\t\tp->right = ins0(p->right, k, v, rw);\n-\treturn balance(p);\n-}\n-\n-static TreeNode*\n-ins1(Tree *m, TreeNode *p, void *k, void *v, TreeNode *rw)\n-{\n-\tint i;\n-\n-\tif(p == nil)\n-\t\treturn rwTreeNode(rw, Red, nil, k, v, nil);\n-\ti = m->cmp(p->key, k);\n-\tif(i == 0){\n-\t\tif(rw)\n-\t\t\treturn rwTreeNode(rw, p->color, p->left, k, v, p->right);\n-\t\tp->value = v;\n-\t\treturn p;\n-\t}\n-\tif(i < 0)\n-\t\tp->left = ins1(m, p->left, k, v, rw);\n-\telse\n-\t\tp->right = ins1(m, p->right, k, v, rw);\n-\treturn balance(p);\n-}\n-\n-void\n-treeputelem(Tree *m, void *key, void *val, TreeNode *rw)\n-{\n-\tif(m->cmp)\n-\t\tm->root = ins1(m, m->root, key, val, rw);\n-\telse\n-\t\tm->root = ins0(m->root, key, val, rw);\n-}\n-\n-void\n-treeput(Tree *m, void *key, void *val)\n-{\n-\ttreeputelem(m, key, val, nil);\n-}\n-\n-void*\n-treeget(Tree *m, void *key)\n-{\n-\tint i;\n-\tTreeNode *p;\n-\n-\tp = m->root;\n-\tif(m->cmp){\n-\t\tfor(;;){\n-\t\t\tif(p == nil)\n-\t\t\t\treturn nil;\n-\t\t\ti = m->cmp(p->key, key);\n-\t\t\tif(i < 0)\n-\t\t\t\tp = p->left;\n-\t\t\telse if(i > 0)\n-\t\t\t\tp = p->right;\n-\t\t\telse\n-\t\t\t\treturn p->value;\n-\t\t}\n-\t}else{\n-\t\tfor(;;){\n-\t\t\tif(p == nil)\n-\t\t\t\treturn nil;\n-\t\t\tif(p->key == key)\n-\t\t\t\treturn p->value;\n-\t\t\tif(p->key < key)\n-\t\t\t\tp = p->left;\n-\t\t\telse\n-\t\t\t\tp = p->right;\n-\t\t}\n-\t}\n-}"},{"sha":"a716d83ada4b743e32a18f01a1026adfd789e319","filename":"src/cmd/cov/tree.h","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/golang/go/blob/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/cov/tree.h","raw_url":"https://github.com/golang/go/raw/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/cov/tree.h","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/cov/tree.h?ref=9e93d5014e6a2e0ef9daf89489c7b12531fc95f3","patch":"@@ -1,47 +0,0 @@\n-// Renamed from Map to Tree to avoid conflict with libmach.\n-\n-/*\n-Copyright (c) 2003-2007 Russ Cox, Tom Bergan, Austin Clements,\n-                        Massachusetts Institute of Technology\n-Portions Copyright (c) 2009 The Go Authors. All rights reserved.\n-\n-Permission is hereby granted, free of charge, to any person obtaining\n-a copy of this software and associated documentation files (the\n-\"Software\"), to deal in the Software without restriction, including\n-without limitation the rights to use, copy, modify, merge, publish,\n-distribute, sublicense, and/or sell copies of the Software, and to\n-permit persons to whom the Software is furnished to do so, subject to\n-the following conditions:\n-\n-The above copyright notice and this permission notice shall be\n-included in all copies or substantial portions of the Software.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n-*/\n-\n-typedef struct Tree Tree;\n-typedef struct TreeNode TreeNode;\n-struct Tree\n-{\n-        int (*cmp)(void*, void*);\n-        TreeNode *root;\n-};\n-\n-struct TreeNode\n-{\n-        int color;\n-        TreeNode *left;\n-        void *key;\n-        void *value;\n-        TreeNode *right;\n-};\n-\n-void *treeget(Tree*, void*);\n-void treeput(Tree*, void*, void*);\n-void treeputelem(Tree*, void*, void*, TreeNode*);"},{"sha":"3f528d751750246ccfa3df22e482501702149c38","filename":"src/cmd/prof/Makefile","status":"removed","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/golang/go/blob/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/prof/Makefile","raw_url":"https://github.com/golang/go/raw/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/prof/Makefile","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/prof/Makefile?ref=9e93d5014e6a2e0ef9daf89489c7b12531fc95f3","patch":"@@ -1,5 +0,0 @@\n-# Copyright 2012 The Go Authors. All rights reserved.\n-# Use of this source code is governed by a BSD-style\n-# license that can be found in the LICENSE file.\n-\n-include ../../Make.dist"},{"sha":"2640167d3f656d924fb16be6a386bc3736cbc9ab","filename":"src/cmd/prof/doc.go","status":"removed","additions":0,"deletions":49,"changes":49,"blob_url":"https://github.com/golang/go/blob/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/prof/doc.go","raw_url":"https://github.com/golang/go/raw/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/prof/doc.go","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/prof/doc.go?ref=9e93d5014e6a2e0ef9daf89489c7b12531fc95f3","patch":"@@ -1,49 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore\n-\n-/*\n-\n-Prof is a rudimentary real-time profiler.\n-\n-Given a command to run or the process id (pid) of a command already\n-running, it samples the program's state at regular intervals and reports\n-on its behavior.  With no options, it prints a histogram of the locations\n-in the code that were sampled during execution.\n-\n-Since it is a real-time profiler, unlike a traditional profiler it samples\n-the program's state even when it is not running, such as when it is\n-asleep or waiting for I/O.  Each thread contributes equally to the\n-statistics.\n-\n-Usage:\n-\tgo tool prof -p pid [-t total_secs] [-d delta_msec] [6.out args ...]\n-\n-The output modes (default -h) are:\n-\n-\t-P file.prof:\n-\t\tWrite the profile information to file.prof, in the format used by pprof.\n-\t\tAt the moment, this only works on Linux amd64 binaries and requires that the\n-\t\tbinary be written using 6l -e to produce ELF debug info.\n-\t\tSee http://code.google.com/p/google-perftools for details.\n-\t-h: histograms\n-\t\tHow many times a sample occurred at each location.\n-\t-f: dynamic functions\n-\t\tAt each sample period, print the name of the executing function.\n-\t-l: dynamic file and line numbers\n-\t\tAt each sample period, print the file and line number of the executing instruction.\n-\t-r: dynamic registers\n-\t\tAt each sample period, print the register contents.\n-\t-s: dynamic function stack traces\n-\t\tAt each sample period, print the symbolic stack trace.\n-\n-Flag -t sets the maximum real time to sample, in seconds, and -d\n-sets the sampling interval in milliseconds.  The default is to sample\n-every 100ms until the program completes.\n-\n-It is installed as go tool prof and is architecture-independent.\n-\n-*/\n-package main"},{"sha":"6c591ba180b78c2e488e472b4dd7b212c5038e82","filename":"src/cmd/prof/main.c","status":"removed","additions":0,"deletions":910,"changes":910,"blob_url":"https://github.com/golang/go/blob/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/prof/main.c","raw_url":"https://github.com/golang/go/raw/9e93d5014e6a2e0ef9daf89489c7b12531fc95f3/src/cmd/prof/main.c","contents_url":"https://api.github.com/repos/golang/go/contents/src/cmd/prof/main.c?ref=9e93d5014e6a2e0ef9daf89489c7b12531fc95f3","patch":"@@ -1,910 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !plan9\n-\n-#include <u.h>\n-#include <time.h>\n-#include <libc.h>\n-#include <bio.h>\n-#include <ctype.h>\n-\n-#define Ureg Ureg_amd64\n-\t#include <ureg_amd64.h>\n-#undef Ureg\n-#define Ureg Ureg_x86\n-\t#include <ureg_x86.h>\n-#undef Ureg\n-#include <mach.h>\n-\n-char* file = \"6.out\";\n-static Fhdr fhdr;\n-int have_syms;\n-int fd;\n-struct Ureg_amd64 ureg_amd64;\n-struct Ureg_x86 ureg_x86;\n-int total_sec = 0;\n-int delta_msec = 100;\n-int nsample;\n-int nsamplethread;\n-\n-// pprof data, stored as sequences of N followed by N PC values.\n-// See http://code.google.com/p/google-perftools .\n-uvlong\t*ppdata;\t// traces\n-Biobuf*\tpproffd;\t// file descriptor to write trace info\n-long\tppstart;\t// start position of current trace\n-long\tnppdata;\t// length of data\n-long\tppalloc;\t// size of allocated data\n-char\tppmapdata[10*1024];\t// the map information for the output file\n-\n-// output formats\n-int pprof;\t// print pprof output to named file\n-int functions;\t// print functions\n-int histograms;\t// print histograms\n-int linenums;\t// print file and line numbers rather than function names\n-int registers;\t// print registers\n-int stacks;\t\t// print stack traces\n-\n-int pid;\t\t// main process pid\n-\n-int nthread;\t// number of threads\n-int thread[32];\t// thread pids\n-Map *map[32];\t// thread maps\n-\n-void\n-Usage(void)\n-{\n-\tfprint(2, \"Usage: prof -p pid [-t total_secs] [-d delta_msec]\\n\");\n-\tfprint(2, \"       prof [-t total_secs] [-d delta_msec] 6.out args ...\\n\");\n-\tfprint(2, \"\\tformats (default -h):\\n\");\n-\tfprint(2, \"\\t\\t-P file.prof: write [c]pprof output to file.prof\\n\");\n-\tfprint(2, \"\\t\\t-h: histograms\\n\");\n-\tfprint(2, \"\\t\\t-f: dynamic functions\\n\");\n-\tfprint(2, \"\\t\\t-l: dynamic file and line numbers\\n\");\n-\tfprint(2, \"\\t\\t-r: dynamic registers\\n\");\n-\tfprint(2, \"\\t\\t-s: dynamic function stack traces\\n\");\n-\tfprint(2, \"\\t\\t-hs: include stack info in histograms\\n\");\n-\texit(2);\n-}\n-\n-typedef struct PC PC;\n-struct PC {\n-\tuvlong pc;\n-\tuvlong callerpc;\n-\tunsigned int count;\n-\tPC* next;\n-};\n-\n-enum {\n-\tNcounters = 256\n-};\n-\n-PC *counters[Ncounters];\n-\n-// Set up by setarch() to make most of the code architecture-independent.\n-typedef struct Arch Arch;\n-struct Arch {\n-\tchar*\tname;\n-\tvoid\t(*regprint)(void);\n-\tint\t(*getregs)(Map*);\n-\tint\t(*getPC)(Map*);\n-\tint\t(*getSP)(Map*);\n-\tuvlong\t(*uregPC)(void);\n-\tuvlong\t(*uregSP)(void);\n-\tvoid\t(*ppword)(uvlong w);\n-};\n-\n-void\n-amd64_regprint(void)\n-{\n-\tfprint(2, \"ax\\t0x%llux\\n\", ureg_amd64.ax);\n-\tfprint(2, \"bx\\t0x%llux\\n\", ureg_amd64.bx);\n-\tfprint(2, \"cx\\t0x%llux\\n\", ureg_amd64.cx);\n-\tfprint(2, \"dx\\t0x%llux\\n\", ureg_amd64.dx);\n-\tfprint(2, \"si\\t0x%llux\\n\", ureg_amd64.si);\n-\tfprint(2, \"di\\t0x%llux\\n\", ureg_amd64.di);\n-\tfprint(2, \"bp\\t0x%llux\\n\", ureg_amd64.bp);\n-\tfprint(2, \"r8\\t0x%llux\\n\", ureg_amd64.r8);\n-\tfprint(2, \"r9\\t0x%llux\\n\", ureg_amd64.r9);\n-\tfprint(2, \"r10\\t0x%llux\\n\", ureg_amd64.r10);\n-\tfprint(2, \"r11\\t0x%llux\\n\", ureg_amd64.r11);\n-\tfprint(2, \"r12\\t0x%llux\\n\", ureg_amd64.r12);\n-\tfprint(2, \"r13\\t0x%llux\\n\", ureg_amd64.r13);\n-\tfprint(2, \"r14\\t0x%llux\\n\", ureg_amd64.r14);\n-\tfprint(2, \"r15\\t0x%llux\\n\", ureg_amd64.r15);\n-\tfprint(2, \"ds\\t0x%llux\\n\", ureg_amd64.ds);\n-\tfprint(2, \"es\\t0x%llux\\n\", ureg_amd64.es);\n-\tfprint(2, \"fs\\t0x%llux\\n\", ureg_amd64.fs);\n-\tfprint(2, \"gs\\t0x%llux\\n\", ureg_amd64.gs);\n-\tfprint(2, \"type\\t0x%llux\\n\", ureg_amd64.type);\n-\tfprint(2, \"error\\t0x%llux\\n\", ureg_amd64.error);\n-\tfprint(2, \"pc\\t0x%llux\\n\", ureg_amd64.ip);\n-\tfprint(2, \"cs\\t0x%llux\\n\", ureg_amd64.cs);\n-\tfprint(2, \"flags\\t0x%llux\\n\", ureg_amd64.flags);\n-\tfprint(2, \"sp\\t0x%llux\\n\", ureg_amd64.sp);\n-\tfprint(2, \"ss\\t0x%llux\\n\", ureg_amd64.ss);\n-}\n-\n-int\n-amd64_getregs(Map *map)\n-{\n-\tint i;\n-\tunion {\n-\t\tuvlong regs[1];\n-\t\tstruct Ureg_amd64 ureg;\n-\t} u;\n-\n-\tfor(i = 0; i < sizeof ureg_amd64; i+=8) {\n-\t\tif(get8(map, (uvlong)i, &u.regs[i/8]) < 0)\n-\t\t\treturn -1;\n-\t}\n-\tureg_amd64 = u.ureg;\n-\treturn 0;\n-}\n-\n-int\n-amd64_getPC(Map *map)\n-{\n-\tuvlong x;\n-\tint r;\n-\n-\tr = get8(map, offsetof(struct Ureg_amd64, ip), &x);\n-\tureg_amd64.ip = x;\n-\treturn r;\n-}\n-\n-int\n-amd64_getSP(Map *map)\n-{\n-\tuvlong x;\n-\tint r;\n-\n-\tr = get8(map, offsetof(struct Ureg_amd64, sp), &x);\n-\tureg_amd64.sp = x;\n-\treturn r;\n-}\n-\n-uvlong\n-amd64_uregPC(void)\n-{\n-\treturn ureg_amd64.ip;\n-}\n-\n-uvlong\n-amd64_uregSP(void)\n-{\n-\treturn ureg_amd64.sp;\n-}\n-\n-void\n-amd64_ppword(uvlong w)\n-{\n-\tuchar buf[8];\n-\n-\tbuf[0] = w;\n-\tbuf[1] = w >> 8;\n-\tbuf[2] = w >> 16;\n-\tbuf[3] = w >> 24;\n-\tbuf[4] = w >> 32;\n-\tbuf[5] = w >> 40;\n-\tbuf[6] = w >> 48;\n-\tbuf[7] = w >> 56;\n-\tBwrite(pproffd, buf, 8);\n-}\n-\n-void\n-x86_regprint(void)\n-{\n-\tfprint(2, \"ax\\t0x%ux\\n\", ureg_x86.ax);\n-\tfprint(2, \"bx\\t0x%ux\\n\", ureg_x86.bx);\n-\tfprint(2, \"cx\\t0x%ux\\n\", ureg_x86.cx);\n-\tfprint(2, \"dx\\t0x%ux\\n\", ureg_x86.dx);\n-\tfprint(2, \"si\\t0x%ux\\n\", ureg_x86.si);\n-\tfprint(2, \"di\\t0x%ux\\n\", ureg_x86.di);\n-\tfprint(2, \"bp\\t0x%ux\\n\", ureg_x86.bp);\n-\tfprint(2, \"ds\\t0x%ux\\n\", ureg_x86.ds);\n-\tfprint(2, \"es\\t0x%ux\\n\", ureg_x86.es);\n-\tfprint(2, \"fs\\t0x%ux\\n\", ureg_x86.fs);\n-\tfprint(2, \"gs\\t0x%ux\\n\", ureg_x86.gs);\n-\tfprint(2, \"cs\\t0x%ux\\n\", ureg_x86.cs);\n-\tfprint(2, \"flags\\t0x%ux\\n\", ureg_x86.flags);\n-\tfprint(2, \"pc\\t0x%ux\\n\", ureg_x86.pc);\n-\tfprint(2, \"sp\\t0x%ux\\n\", ureg_x86.sp);\n-\tfprint(2, \"ss\\t0x%ux\\n\", ureg_x86.ss);\n-}\n-\n-int\n-x86_getregs(Map *map)\n-{\n-\tint i;\n-\n-\tfor(i = 0; i < sizeof ureg_x86; i+=4) {\n-\t\tif(get4(map, (uvlong)i, &((uint32*)&ureg_x86)[i/4]) < 0)\n-\t\t\treturn -1;\n-\t}\n-\treturn 0;\n-}\n-\n-int\n-x86_getPC(Map* map)\n-{\n-\treturn get4(map, offsetof(struct Ureg_x86, pc), &ureg_x86.pc);\n-}\n-\n-int\n-x86_getSP(Map* map)\n-{\n-\treturn get4(map, offsetof(struct Ureg_x86, sp), &ureg_x86.sp);\n-}\n-\n-uvlong\n-x86_uregPC(void)\n-{\n-\treturn (uvlong)ureg_x86.pc;\n-}\n-\n-uvlong\n-x86_uregSP(void)\n-{\n-\treturn (uvlong)ureg_x86.sp;\n-}\n-\n-void\n-x86_ppword(uvlong w)\n-{\n-\tuchar buf[4];\n-\n-\tbuf[0] = w;\n-\tbuf[1] = w >> 8;\n-\tbuf[2] = w >> 16;\n-\tbuf[3] = w >> 24;\n-\tBwrite(pproffd, buf, 4);\n-}\n-\n-Arch archtab[] = {\n-\t{\n-\t\t\"amd64\",\n-\t\tamd64_regprint,\n-\t\tamd64_getregs,\n-\t\tamd64_getPC,\n-\t\tamd64_getSP,\n-\t\tamd64_uregPC,\n-\t\tamd64_uregSP,\n-\t\tamd64_ppword,\n-\t},\n-\t{\n-\t\t\"386\",\n-\t\tx86_regprint,\n-\t\tx86_getregs,\n-\t\tx86_getPC,\n-\t\tx86_getSP,\n-\t\tx86_uregPC,\n-\t\tx86_uregSP,\n-\t\tx86_ppword,\n-\t},\n-\t{\n-\t\tnil\n-\t}\n-};\n-\n-Arch *arch;\n-\n-int\n-setarch(void)\n-{\n-\tint i;\n-\n-\tif(mach != nil) {\n-\t\tfor(i = 0; archtab[i].name != nil; i++) {\n-\t\t\tif (strcmp(mach->name, archtab[i].name) == 0) {\n-\t\t\t\tarch = &archtab[i];\n-\t\t\t\treturn 0;\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn -1;\n-}\n-\n-int\n-getthreads(void)\n-{\n-\tint i, j, curn, found;\n-\tMap *curmap[nelem(map)];\n-\tint curthread[nelem(map)];\n-\tstatic int complained = 0;\n-\n-\tcurn = procthreadpids(pid, curthread, nelem(curthread));\n-\tif(curn <= 0)\n-\t\treturn curn;\n-\n-\tif(curn > nelem(map)) {\n-\t\tif(complained == 0) {\n-\t\t\tfprint(2, \"prof: too many threads; limiting to %d\\n\", nthread, nelem(map));\n-\t\t\tcomplained = 1;\n-\t\t}\n-\t\tcurn = nelem(map);\n-\t}\n-\tif(curn == nthread && memcmp(thread, curthread, curn*sizeof(*thread)) == 0)\n-\t\treturn curn;\t// no changes\n-\n-\t// Number of threads has changed (might be the init case).\n-\t// A bit expensive but rare enough not to bother being clever.\n-\tfor(i = 0; i < curn; i++) {\n-\t\tfound = 0;\n-\t\tfor(j = 0; j < nthread; j++) {\n-\t\t\tif(curthread[i] == thread[j]) {\n-\t\t\t\tfound = 1;\n-\t\t\t\tcurmap[i] = map[j];\n-\t\t\t\tmap[j] = nil;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\tif(found)\n-\t\t\tcontinue;\n-\n-\t\t// map new thread\n-\t\tcurmap[i] = attachproc(curthread[i], &fhdr);\n-\t\tif(curmap[i] == nil) {\n-\t\t\tfprint(2, \"prof: can't attach to %d: %r\\n\", curthread[i]);\n-\t\t\treturn -1;\n-\t\t}\n-\t}\n-\n-\tfor(j = 0; j < nthread; j++)\n-\t\tif(map[j] != nil)\n-\t\t\tdetachproc(map[j]);\n-\n-\tnthread = curn;\n-\tmemmove(thread, curthread, nthread*sizeof thread[0]);\n-\tmemmove(map, curmap, sizeof map);\n-\treturn nthread;\n-}\n-\n-int\n-sample(Map *map)\n-{\n-\tstatic int n;\n-\n-\tn++;\n-\tif(registers) {\n-\t\tif(arch->getregs(map) < 0)\n-\t\t\tgoto bad;\n-\t} else {\n-\t\t// we need only two registers\n-\t\tif(arch->getPC(map) < 0)\n-\t\t\tgoto bad;\n-\t\tif(arch->getSP(map) < 0)\n-\t\t\tgoto bad;\n-\t}\n-\treturn 1;\n-bad:\n-\tif(n == 1)\n-\t\tfprint(2, \"prof: can't read registers: %r\\n\");\n-\treturn 0;\n-}\n-\n-void\n-addtohistogram(uvlong pc, uvlong callerpc, uvlong sp)\n-{\n-\tint h;\n-\tPC *x;\n-\t\n-\tUSED(sp);\n-\n-\th = (pc + callerpc*101) % Ncounters;\n-\tfor(x = counters[h]; x != NULL; x = x->next) {\n-\t\tif(x->pc == pc && x->callerpc == callerpc) {\n-\t\t\tx->count++;\n-\t\t\treturn;\n-\t\t}\n-\t}\n-\tx = malloc(sizeof(PC));\n-\tif(x == nil)\n-\t\tsysfatal(\"out of memory\");\n-\tx->pc = pc;\n-\tx->callerpc = callerpc;\n-\tx->count = 1;\n-\tx->next = counters[h];\n-\tcounters[h] = x;\n-}\n-\n-void\n-addppword(uvlong pc)\n-{\n-\tif(pc == 0) {\n-\t\treturn;\n-\t}\n-\tif(nppdata == ppalloc) {\n-\t\tppalloc = (1000+nppdata)*2;\n-\t\tppdata = realloc(ppdata, ppalloc * sizeof ppdata[0]);\n-\t\tif(ppdata == nil) {\n-\t\t\tfprint(2, \"prof: realloc failed: %r\\n\");\n-\t\t\texit(2);\n-\t\t}\n-\t}\n-\tppdata[nppdata++] = pc;\n-}\n-\n-void\n-startpptrace(void)\n-{\n-\tppstart = nppdata;\n-\taddppword(~0);\n-}\n-\n-void\n-endpptrace(void)\n-{\n-\tppdata[ppstart] = nppdata-ppstart-1;\n-}\n-\n-uvlong nextpc;\n-\n-void\n-xptrace(Map *map, uvlong pc, uvlong sp, Symbol *sym)\n-{\n-\tUSED(map);\n-\n-\tchar buf[1024];\n-\tif(sym == nil){\n-\t\tfprint(2, \"syms\\n\");\n-\t\treturn;\n-\t}\n-\tif(histograms)\n-\t\taddtohistogram(nextpc, pc, sp);\n-\tif(!histograms || stacks > 1 || pprof) {\n-\t\tif(nextpc == 0)\n-\t\t\tnextpc = sym->value;\n-\t\tif(stacks){\n-\t\t\tfprint(2, \"%s(\", sym->name);\n-\t\t\tfprint(2, \")\");\n-\t\t\tif(nextpc != sym->value)\n-\t\t\t\tfprint(2, \"+%#llux \", nextpc - sym->value);\n-\t\t\tif(have_syms && linenums && fileline(buf, sizeof buf, pc)) {\n-\t\t\t\tfprint(2, \" %s\", buf);\n-\t\t\t}\n-\t\t\tfprint(2, \"\\n\");\n-\t\t}\n-\t\tif (pprof) {\n-\t\t\taddppword(nextpc);\n-\t\t}\n-\t}\n-\tnextpc = pc;\n-}\n-\n-void\n-stacktracepcsp(Map *map, uvlong pc, uvlong sp)\n-{\n-\tnextpc = pc;\n-\tif(pprof){\n-\t\tstartpptrace();\n-\t}\n-\tif(machdata->ctrace==nil)\n-\t\tfprint(2, \"no machdata->ctrace\\n\");\n-\telse if(machdata->ctrace(map, pc, sp, 0, xptrace) <= 0)\n-\t\tfprint(2, \"no stack frame: pc=%#p sp=%#p\\n\", pc, sp);\n-\telse {\n-\t\taddtohistogram(nextpc, 0, sp);\n-\t\tif(stacks)\n-\t\t\tfprint(2, \"\\n\");\n-\t}\n-\tif(pprof){\n-\t\tendpptrace();\n-\t}\n-}\n-\n-void\n-printpc(Map *map, uvlong pc, uvlong sp)\n-{\n-\tchar buf[1024];\n-\tif(registers)\n-\t\tarch->regprint();\n-\tif(have_syms > 0 && linenums &&  fileline(buf, sizeof buf, pc))\n-\t\tfprint(2, \"%s\\n\", buf);\n-\tif(have_syms > 0 && functions) {\n-\t\tsymoff(buf, sizeof(buf), pc, CANY);\n-\t\tfprint(2, \"%s\\n\", buf);\n-\t}\n-\tif(stacks || pprof){\n-\t\tstacktracepcsp(map, pc, sp);\n-\t}\n-\telse if(histograms){\n-\t\taddtohistogram(pc, 0, sp);\n-\t}\n-}\n-\n-void\n-ppmaps(void)\n-{\n-\tint fd, n;\n-\tchar tmp[100];\n-\tSeg *seg;\n-\n-\t// If it's Linux, the info is in /proc/$pid/maps\n-\tsnprint(tmp, sizeof tmp, \"/proc/%d/maps\", pid);\n-\tfd = open(tmp, 0);\n-\tif(fd >= 0) {\n-\t\tn = read(fd, ppmapdata, sizeof ppmapdata - 1);\n-\t\tclose(fd);\n-\t\tif(n < 0) {\n-\t\t\tfprint(2, \"prof: can't read %s: %r\\n\", tmp);\n-\t\t\texit(2);\n-\t\t}\n-\t\tppmapdata[n] = 0;\n-\t\treturn;\n-\t}\n-\n-\t// It's probably a mac. Synthesize an entry for the text file.\n-\t// The register segment may come first but it has a zero offset, so grab the first non-zero offset segment.\n-\tfor(n = 0; n < 3; n++){\n-\t\tseg = &map[0]->seg[n];\n-\t\tif(seg->b == 0) {\n-\t\t\tcontinue;\n-\t\t}\n-\t\tsnprint(ppmapdata, sizeof ppmapdata,\n-\t\t\t\"%.16x-%.16x r-xp %d 00:00 34968549                           %s\\n\",\n-\t\t\tseg->b, seg->e, seg->f, \"/home/r/6.out\"\n-\t\t);\n-\t\treturn;\n-\t}\n-\tfprint(2, \"prof: no text segment in maps for %s\\n\", file);\n-\texit(2);\n-}\n-\n-void\n-samples(void)\n-{\n-\tint i, pid, msec;\n-\tstruct timespec req;\n-\tint getmaps;\n-\n-\treq.tv_sec = delta_msec/1000;\n-\treq.tv_nsec = 1000000*(delta_msec % 1000);\n-\tgetmaps = 0;\n-\tif(pprof)\n-\t\tgetmaps= 1;\n-\tfor(msec = 0; total_sec <= 0 || msec < 1000*total_sec; msec += delta_msec) {\n-\t\tnsample++;\n-\t\tnsamplethread += nthread;\n-\t\tfor(i = 0; i < nthread; i++) {\n-\t\t\tpid = thread[i];\n-\t\t\tif(ctlproc(pid, \"stop\") < 0)\n-\t\t\t\treturn;\n-\t\t\tif(!sample(map[i])) {\n-\t\t\t\tctlproc(pid, \"start\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tprintpc(map[i], arch->uregPC(), arch->uregSP());\n-\t\t\tctlproc(pid, \"start\");\n-\t\t}\n-\t\tnanosleep(&req, NULL);\n-\t\tgetthreads();\n-\t\tif(nthread == 0)\n-\t\t\tbreak;\n-\t\tif(getmaps) {\n-\t\t\tgetmaps = 0;\n-\t\t\tppmaps();\n-\t\t}\n-\t}\n-}\n-\n-typedef struct Func Func;\n-struct Func\n-{\n-\tFunc *next;\n-\tSymbol s;\n-\tuint onstack;\n-\tuint leaf;\n-};\n-\n-Func *func[257];\n-int nfunc;\n-\n-Func*\n-findfunc(uvlong pc)\n-{\n-\tFunc *f;\n-\tuint h;\n-\tSymbol s;\n-\n-\tif(pc == 0)\n-\t\treturn nil;\n-\n-\tif(!findsym(pc, CTEXT, &s))\n-\t\treturn nil;\n-\n-\th = s.value % nelem(func);\n-\tfor(f = func[h]; f != NULL; f = f->next)\n-\t\tif(f->s.value == s.value)\n-\t\t\treturn f;\n-\n-\tf = malloc(sizeof *f);\n-\tif(f == nil)\n-\t\tsysfatal(\"out of memory\");\n-\tmemset(f, 0, sizeof *f);\n-\tf->s = s;\n-\tf->next = func[h];\n-\tfunc[h] = f;\n-\tnfunc++;\n-\treturn f;\n-}\n-\n-int\n-compareleaf(const void *va, const void *vb)\n-{\n-\tFunc *a, *b;\n-\n-\ta = *(Func**)va;\n-\tb = *(Func**)vb;\n-\tif(a->leaf != b->leaf)\n-\t\treturn b->leaf - a->leaf;\n-\tif(a->onstack != b->onstack)\n-\t\treturn b->onstack - a->onstack;\n-\treturn strcmp(a->s.name, b->s.name);\n-}\n-\n-void\n-dumphistogram(void)\n-{\n-\tint i, h, n;\n-\tPC *x;\n-\tFunc *f, **ff;\n-\n-\tif(!histograms)\n-\t\treturn;\n-\n-\t// assign counts to functions.\n-\tfor(h = 0; h < Ncounters; h++) {\n-\t\tfor(x = counters[h]; x != NULL; x = x->next) {\n-\t\t\tf = findfunc(x->pc);\n-\t\t\tif(f) {\n-\t\t\t\tf->onstack += x->count;\n-\t\t\t\tf->leaf += x->count;\n-\t\t\t}\n-\t\t\tf = findfunc(x->callerpc);\n-\t\t\tif(f)\n-\t\t\t\tf->leaf -= x->count;\n-\t\t}\n-\t}\n-\n-\t// build array\n-\tff = malloc(nfunc*sizeof ff[0]);\n-\tif(ff == nil)\n-\t\tsysfatal(\"out of memory\");\n-\tn = 0;\n-\tfor(h = 0; h < nelem(func); h++)\n-\t\tfor(f = func[h]; f != NULL; f = f->next)\n-\t\t\tff[n++] = f;\n-\n-\t// sort by leaf counts\n-\tqsort(ff, nfunc, sizeof ff[0], compareleaf);\n-\n-\t// print.\n-\tfprint(2, \"%d samples (avg %.1g threads)\\n\", nsample, (double)nsamplethread/nsample);\n-\tfor(i = 0; i < nfunc; i++) {\n-\t\tf = ff[i];\n-\t\tfprint(2, \"%6.2f%%\\t\", 100.0*(double)f->leaf/nsample);\n-\t\tif(stacks)\n-\t\t\tfprint(2, \"%6.2f%%\\t\", 100.0*(double)f->onstack/nsample);\n-\t\tfprint(2, \"%s\\n\", f->s.name);\n-\t}\n-}\n-\n-typedef struct Trace Trace;\n-struct Trace {\n-\tint\tcount;\n-\tint\tnpc;\n-\tuvlong\t*pc;\n-\tTrace\t*next;\n-};\n-\n-void\n-dumppprof(void)\n-{\n-\tuvlong i, n, *p, *e;\n-\tint ntrace;\n-\tTrace *trace, *tp, *up, *prev;\n-\n-\tif(!pprof)\n-\t\treturn;\n-\te = ppdata + nppdata;\n-\t// Create list of traces.  First, count the traces\n-\tntrace = 0;\n-\tfor(p = ppdata; p < e;) {\n-\t\tn = *p++;\n-\t\tp += n;\n-\t\tif(n == 0)\n-\t\t\tcontinue;\n-\t\tntrace++;\n-\t}\n-\tif(ntrace <= 0)\n-\t\treturn;\n-\t// Allocate and link the traces together.\n-\ttrace = malloc(ntrace * sizeof(Trace));\n-\tif(trace == nil)\n-\t\tsysfatal(\"out of memory\");\n-\ttp = trace;\n-\tfor(p = ppdata; p < e;) {\n-\t\tn = *p++;\n-\t\tif(n == 0)\n-\t\t\tcontinue;\n-\t\ttp->count = 1;\n-\t\ttp->npc = n;\n-\t\ttp->pc = p;\n-\t\ttp->next = tp+1;\n-\t\ttp++;\n-\t\tp += n;\n-\t}\n-\ttrace[ntrace-1].next = nil;\n-\t// Eliminate duplicates.  Lousy algorithm, although not as bad as it looks because\n-\t// the list collapses fast.\n-\tfor(tp = trace; tp != nil; tp = tp->next) {\n-\t\tprev = tp;\n-\t\tfor(up = tp->next; up != nil; up = up->next) {\n-\t\t\tif(up->npc == tp->npc && memcmp(up->pc, tp->pc, up->npc*sizeof up->pc[0]) == 0) {\n-\t\t\t\ttp->count++;\n-\t\t\t\tprev->next = up->next;\n-\t\t\t} else {\n-\t\t\t\tprev = up;\n-\t\t\t}\n-\t\t}\n-\t}\n-\t// Write file.\n-\t// See http://code.google.com/p/google-perftools/source/browse/trunk/doc/cpuprofile-fileformat.html\n-\t// 1) Header\n-\tarch->ppword(0);\t// must be zero\n-\tarch->ppword(3);\t// 3 words follow in header\n-\tarch->ppword(0);\t// must be zero\n-\tarch->ppword(delta_msec * 1000);\t// sampling period in microseconds\n-\tarch->ppword(0);\t// must be zero (padding)\n-\t// 2) One record for each trace.\n-\tfor(tp = trace; tp != nil; tp = tp->next) {\n-\t\tarch->ppword(tp->count);\n-\t\tarch->ppword(tp->npc);\n-\t\tfor(i = 0; i < tp->npc; i++) {\n-\t\t\tarch->ppword(tp->pc[i]);\n-\t\t}\n-\t}\n-\t// 3) Binary trailer\n-\tarch->ppword(0);\t// must be zero\n-\tarch->ppword(1);\t// must be one\n-\tarch->ppword(0);\t// must be zero\n-\t// 4) Mapped objects.\n-\tBwrite(pproffd, ppmapdata, strlen(ppmapdata));\n-\t// 5) That's it.\n-\tBterm(pproffd);\n-}\n-\n-int\n-startprocess(char **argv)\n-{\n-\tint pid;\n-\n-\tif((pid = fork()) == 0) {\n-\t\tpid = getpid();\n-\t\tif(ctlproc(pid, \"hang\") < 0){\n-\t\t\tfprint(2, \"prof: child process could not hang\\n\");\n-\t\t\texits(0);\n-\t\t}\n-\t\texecv(argv[0], argv);\n-\t\tfprint(2, \"prof: could not exec %s: %r\\n\", argv[0]);\n-\t\texits(0);\n-\t}\n-\n-\tif(pid == -1) {\n-\t\tfprint(2, \"prof: could not fork\\n\");\n-\t\texit(1);\n-\t}\n-\tif(ctlproc(pid, \"attached\") < 0 || ctlproc(pid, \"waitstop\") < 0) {\n-\t\tfprint(2, \"prof: could not attach to child process: %r\\n\");\n-\t\texit(1);\n-\t}\n-\treturn pid;\n-}\n-\n-void\n-detach(void)\n-{\n-\tint i;\n-\n-\tfor(i = 0; i < nthread; i++)\n-\t\tdetachproc(map[i]);\n-}\n-\n-int\n-main(int argc, char *argv[])\n-{\n-\tint i;\n-\tchar *ppfile;\n-\n-\tARGBEGIN{\n-\tcase 'P':\n-\t\tpprof =1;\n-\t\tppfile = EARGF(Usage());\n-\t\tpproffd = Bopen(ppfile, OWRITE);\n-\t\tif(pproffd == nil) {\n-\t\t\tfprint(2, \"prof: cannot open %s: %r\\n\", ppfile);\n-\t\t\texit(2);\n-\t\t}\n-\t\tbreak;\n-\tcase 'd':\n-\t\tdelta_msec = atoi(EARGF(Usage()));\n-\t\tbreak;\n-\tcase 't':\n-\t\ttotal_sec = atoi(EARGF(Usage()));\n-\t\tbreak;\n-\tcase 'p':\n-\t\tpid = atoi(EARGF(Usage()));\n-\t\tbreak;\n-\tcase 'f':\n-\t\tfunctions = 1;\n-\t\tbreak;\n-\tcase 'h':\n-\t\thistograms = 1;\n-\t\tbreak;\n-\tcase 'l':\n-\t\tlinenums = 1;\n-\t\tbreak;\n-\tcase 'r':\n-\t\tregisters = 1;\n-\t\tbreak;\n-\tcase 's':\n-\t\tstacks++;\n-\t\tbreak;\n-\tdefault:\n-\t\tUsage();\n-\t}ARGEND\n-\tif(pid <= 0 && argc == 0)\n-\t\tUsage();\n-\tif(functions+linenums+registers+stacks+pprof == 0)\n-\t\thistograms = 1;\n-\tif(!machbyname(\"amd64\")) {\n-\t\tfprint(2, \"prof: no amd64 support\\n\", pid);\n-\t\texit(1);\n-\t}\n-\tif(argc > 0)\n-\t\tfile = argv[0];\n-\telse if(pid) {\n-\t\tfile = proctextfile(pid);\n-\t\tif (file == NULL) {\n-\t\t\tfprint(2, \"prof: can't find file for pid %d: %r\\n\", pid);\n-\t\t\tfprint(2, \"prof: on Darwin, need to provide file name explicitly\\n\");\n-\t\t\texit(1);\n-\t\t}\n-\t}\n-\tfd = open(file, 0);\n-\tif(fd < 0) {\n-\t\tfprint(2, \"prof: can't open %s: %r\\n\", file);\n-\t\texit(1);\n-\t}\n-\tif(crackhdr(fd, &fhdr)) {\n-\t\thave_syms = syminit(fd, &fhdr);\n-\t\tif(!have_syms) {\n-\t\t\tfprint(2, \"prof: no symbols for %s: %r\\n\", file);\n-\t\t}\n-\t} else {\n-\t\tfprint(2, \"prof: crack header for %s: %r\\n\", file);\n-\t\texit(1);\n-\t}\n-\tif(pid <= 0)\n-\t\tpid = startprocess(argv);\n-\tattachproc(pid, &fhdr);\t// initializes thread list\n-\tif(setarch() < 0) {\n-\t\tdetach();\n-\t\tfprint(2, \"prof: can't identify binary architecture for pid %d\\n\", pid);\n-\t\texit(1);\n-\t}\n-\tif(getthreads() <= 0) {\n-\t\tdetach();\n-\t\tfprint(2, \"prof: can't find threads for pid %d\\n\", pid);\n-\t\texit(1);\n-\t}\n-\tfor(i = 0; i < nthread; i++)\n-\t\tctlproc(thread[i], \"start\");\n-\tsamples();\n-\tdetach();\n-\tdumphistogram();\n-\tdumppprof();\n-\texit(0);\n-}"}]}